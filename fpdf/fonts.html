<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>fpdf.fonts API documentation</title>
<meta name="description" content="Font-related classes &amp; constants.
Includes the definition of the character widths of all PDF standard fonts â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fpdf.fonts</code></h1>
</header>
<section id="section-intro">
<p>Font-related classes &amp; constants.
Includes the definition of the character widths of all PDF standard fonts.</p>
<p>The contents of this module are internal to fpdf2, and not part of the public API.
They may change at any time without prior warning or any deprecation period,
in non-backward-compatible ways.</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fpdf.fonts.CoreFont"><code class="flex name class">
<span>class <span class="ident">CoreFont</span></span>
<span>(</span><span>fpdf, fontkey, style)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L209-L245" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class CoreFont:
    # RAM usage optimization:
    __slots__ = (
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
    )

    def __init__(self, fpdf, fontkey, style):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;core&#34;
        self.name = CORE_FONTS[fontkey]
        self.sp = 250  # strikethrough horizontal position
        self.ss = 50  # strikethrough size (height)
        self.up = -100  # underline horizontal position
        self.ut = 50  # underline height
        self.cw = CORE_FONTS_CHARWIDTHS[fontkey]
        self.fontkey = fontkey
        self.emphasis = TextEmphasis.coerce(style)

    def get_text_width(self, text, font_size_pt, _):
        return (len(text), sum(self.cw[c] for c in text) * font_size_pt * 0.001)

    # Disabling this check - method kept as is to have same method/signature on CoreConf and TTFFont:
    # pylint: disable=no-self-use
    def encode_text(self, text):
        return f&#34;({escape_parens(text)}) Tj&#34;

    def __repr__(self):
        return f&#34;CoreFont(i={self.i}, fontkey={self.fontkey})&#34;</code></pre>
</details>
<div class="desc"></div>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.fonts.CoreFont.cw"><code class="name">var <span class="ident">cw</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L209-L245" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class CoreFont:
    # RAM usage optimization:
    __slots__ = (
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
    )

    def __init__(self, fpdf, fontkey, style):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;core&#34;
        self.name = CORE_FONTS[fontkey]
        self.sp = 250  # strikethrough horizontal position
        self.ss = 50  # strikethrough size (height)
        self.up = -100  # underline horizontal position
        self.ut = 50  # underline height
        self.cw = CORE_FONTS_CHARWIDTHS[fontkey]
        self.fontkey = fontkey
        self.emphasis = TextEmphasis.coerce(style)

    def get_text_width(self, text, font_size_pt, _):
        return (len(text), sum(self.cw[c] for c in text) * font_size_pt * 0.001)

    # Disabling this check - method kept as is to have same method/signature on CoreConf and TTFFont:
    # pylint: disable=no-self-use
    def encode_text(self, text):
        return f&#34;({escape_parens(text)}) Tj&#34;

    def __repr__(self):
        return f&#34;CoreFont(i={self.i}, fontkey={self.fontkey})&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.CoreFont.emphasis"><code class="name">var <span class="ident">emphasis</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L209-L245" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class CoreFont:
    # RAM usage optimization:
    __slots__ = (
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
    )

    def __init__(self, fpdf, fontkey, style):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;core&#34;
        self.name = CORE_FONTS[fontkey]
        self.sp = 250  # strikethrough horizontal position
        self.ss = 50  # strikethrough size (height)
        self.up = -100  # underline horizontal position
        self.ut = 50  # underline height
        self.cw = CORE_FONTS_CHARWIDTHS[fontkey]
        self.fontkey = fontkey
        self.emphasis = TextEmphasis.coerce(style)

    def get_text_width(self, text, font_size_pt, _):
        return (len(text), sum(self.cw[c] for c in text) * font_size_pt * 0.001)

    # Disabling this check - method kept as is to have same method/signature on CoreConf and TTFFont:
    # pylint: disable=no-self-use
    def encode_text(self, text):
        return f&#34;({escape_parens(text)}) Tj&#34;

    def __repr__(self):
        return f&#34;CoreFont(i={self.i}, fontkey={self.fontkey})&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.CoreFont.fontkey"><code class="name">var <span class="ident">fontkey</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L209-L245" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class CoreFont:
    # RAM usage optimization:
    __slots__ = (
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
    )

    def __init__(self, fpdf, fontkey, style):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;core&#34;
        self.name = CORE_FONTS[fontkey]
        self.sp = 250  # strikethrough horizontal position
        self.ss = 50  # strikethrough size (height)
        self.up = -100  # underline horizontal position
        self.ut = 50  # underline height
        self.cw = CORE_FONTS_CHARWIDTHS[fontkey]
        self.fontkey = fontkey
        self.emphasis = TextEmphasis.coerce(style)

    def get_text_width(self, text, font_size_pt, _):
        return (len(text), sum(self.cw[c] for c in text) * font_size_pt * 0.001)

    # Disabling this check - method kept as is to have same method/signature on CoreConf and TTFFont:
    # pylint: disable=no-self-use
    def encode_text(self, text):
        return f&#34;({escape_parens(text)}) Tj&#34;

    def __repr__(self):
        return f&#34;CoreFont(i={self.i}, fontkey={self.fontkey})&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.CoreFont.i"><code class="name">var <span class="ident">i</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L209-L245" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class CoreFont:
    # RAM usage optimization:
    __slots__ = (
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
    )

    def __init__(self, fpdf, fontkey, style):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;core&#34;
        self.name = CORE_FONTS[fontkey]
        self.sp = 250  # strikethrough horizontal position
        self.ss = 50  # strikethrough size (height)
        self.up = -100  # underline horizontal position
        self.ut = 50  # underline height
        self.cw = CORE_FONTS_CHARWIDTHS[fontkey]
        self.fontkey = fontkey
        self.emphasis = TextEmphasis.coerce(style)

    def get_text_width(self, text, font_size_pt, _):
        return (len(text), sum(self.cw[c] for c in text) * font_size_pt * 0.001)

    # Disabling this check - method kept as is to have same method/signature on CoreConf and TTFFont:
    # pylint: disable=no-self-use
    def encode_text(self, text):
        return f&#34;({escape_parens(text)}) Tj&#34;

    def __repr__(self):
        return f&#34;CoreFont(i={self.i}, fontkey={self.fontkey})&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.CoreFont.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L209-L245" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class CoreFont:
    # RAM usage optimization:
    __slots__ = (
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
    )

    def __init__(self, fpdf, fontkey, style):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;core&#34;
        self.name = CORE_FONTS[fontkey]
        self.sp = 250  # strikethrough horizontal position
        self.ss = 50  # strikethrough size (height)
        self.up = -100  # underline horizontal position
        self.ut = 50  # underline height
        self.cw = CORE_FONTS_CHARWIDTHS[fontkey]
        self.fontkey = fontkey
        self.emphasis = TextEmphasis.coerce(style)

    def get_text_width(self, text, font_size_pt, _):
        return (len(text), sum(self.cw[c] for c in text) * font_size_pt * 0.001)

    # Disabling this check - method kept as is to have same method/signature on CoreConf and TTFFont:
    # pylint: disable=no-self-use
    def encode_text(self, text):
        return f&#34;({escape_parens(text)}) Tj&#34;

    def __repr__(self):
        return f&#34;CoreFont(i={self.i}, fontkey={self.fontkey})&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.CoreFont.sp"><code class="name">var <span class="ident">sp</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L209-L245" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class CoreFont:
    # RAM usage optimization:
    __slots__ = (
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
    )

    def __init__(self, fpdf, fontkey, style):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;core&#34;
        self.name = CORE_FONTS[fontkey]
        self.sp = 250  # strikethrough horizontal position
        self.ss = 50  # strikethrough size (height)
        self.up = -100  # underline horizontal position
        self.ut = 50  # underline height
        self.cw = CORE_FONTS_CHARWIDTHS[fontkey]
        self.fontkey = fontkey
        self.emphasis = TextEmphasis.coerce(style)

    def get_text_width(self, text, font_size_pt, _):
        return (len(text), sum(self.cw[c] for c in text) * font_size_pt * 0.001)

    # Disabling this check - method kept as is to have same method/signature on CoreConf and TTFFont:
    # pylint: disable=no-self-use
    def encode_text(self, text):
        return f&#34;({escape_parens(text)}) Tj&#34;

    def __repr__(self):
        return f&#34;CoreFont(i={self.i}, fontkey={self.fontkey})&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.CoreFont.ss"><code class="name">var <span class="ident">ss</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L209-L245" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class CoreFont:
    # RAM usage optimization:
    __slots__ = (
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
    )

    def __init__(self, fpdf, fontkey, style):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;core&#34;
        self.name = CORE_FONTS[fontkey]
        self.sp = 250  # strikethrough horizontal position
        self.ss = 50  # strikethrough size (height)
        self.up = -100  # underline horizontal position
        self.ut = 50  # underline height
        self.cw = CORE_FONTS_CHARWIDTHS[fontkey]
        self.fontkey = fontkey
        self.emphasis = TextEmphasis.coerce(style)

    def get_text_width(self, text, font_size_pt, _):
        return (len(text), sum(self.cw[c] for c in text) * font_size_pt * 0.001)

    # Disabling this check - method kept as is to have same method/signature on CoreConf and TTFFont:
    # pylint: disable=no-self-use
    def encode_text(self, text):
        return f&#34;({escape_parens(text)}) Tj&#34;

    def __repr__(self):
        return f&#34;CoreFont(i={self.i}, fontkey={self.fontkey})&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.CoreFont.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L209-L245" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class CoreFont:
    # RAM usage optimization:
    __slots__ = (
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
    )

    def __init__(self, fpdf, fontkey, style):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;core&#34;
        self.name = CORE_FONTS[fontkey]
        self.sp = 250  # strikethrough horizontal position
        self.ss = 50  # strikethrough size (height)
        self.up = -100  # underline horizontal position
        self.ut = 50  # underline height
        self.cw = CORE_FONTS_CHARWIDTHS[fontkey]
        self.fontkey = fontkey
        self.emphasis = TextEmphasis.coerce(style)

    def get_text_width(self, text, font_size_pt, _):
        return (len(text), sum(self.cw[c] for c in text) * font_size_pt * 0.001)

    # Disabling this check - method kept as is to have same method/signature on CoreConf and TTFFont:
    # pylint: disable=no-self-use
    def encode_text(self, text):
        return f&#34;({escape_parens(text)}) Tj&#34;

    def __repr__(self):
        return f&#34;CoreFont(i={self.i}, fontkey={self.fontkey})&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.CoreFont.up"><code class="name">var <span class="ident">up</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L209-L245" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class CoreFont:
    # RAM usage optimization:
    __slots__ = (
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
    )

    def __init__(self, fpdf, fontkey, style):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;core&#34;
        self.name = CORE_FONTS[fontkey]
        self.sp = 250  # strikethrough horizontal position
        self.ss = 50  # strikethrough size (height)
        self.up = -100  # underline horizontal position
        self.ut = 50  # underline height
        self.cw = CORE_FONTS_CHARWIDTHS[fontkey]
        self.fontkey = fontkey
        self.emphasis = TextEmphasis.coerce(style)

    def get_text_width(self, text, font_size_pt, _):
        return (len(text), sum(self.cw[c] for c in text) * font_size_pt * 0.001)

    # Disabling this check - method kept as is to have same method/signature on CoreConf and TTFFont:
    # pylint: disable=no-self-use
    def encode_text(self, text):
        return f&#34;({escape_parens(text)}) Tj&#34;

    def __repr__(self):
        return f&#34;CoreFont(i={self.i}, fontkey={self.fontkey})&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.CoreFont.ut"><code class="name">var <span class="ident">ut</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L209-L245" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class CoreFont:
    # RAM usage optimization:
    __slots__ = (
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
    )

    def __init__(self, fpdf, fontkey, style):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;core&#34;
        self.name = CORE_FONTS[fontkey]
        self.sp = 250  # strikethrough horizontal position
        self.ss = 50  # strikethrough size (height)
        self.up = -100  # underline horizontal position
        self.ut = 50  # underline height
        self.cw = CORE_FONTS_CHARWIDTHS[fontkey]
        self.fontkey = fontkey
        self.emphasis = TextEmphasis.coerce(style)

    def get_text_width(self, text, font_size_pt, _):
        return (len(text), sum(self.cw[c] for c in text) * font_size_pt * 0.001)

    # Disabling this check - method kept as is to have same method/signature on CoreConf and TTFFont:
    # pylint: disable=no-self-use
    def encode_text(self, text):
        return f&#34;({escape_parens(text)}) Tj&#34;

    def __repr__(self):
        return f&#34;CoreFont(i={self.i}, fontkey={self.fontkey})&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.fonts.CoreFont.encode_text"><code class="name flex">
<span>def <span class="ident">encode_text</span></span>(<span>self, text)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L241-L242" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def encode_text(self, text):
    return f&#34;({escape_parens(text)}) Tj&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.CoreFont.get_text_width"><code class="name flex">
<span>def <span class="ident">get_text_width</span></span>(<span>self, text, font_size_pt, _)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L236-L237" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def get_text_width(self, text, font_size_pt, _):
    return (len(text), sum(self.cw[c] for c in text) * font_size_pt * 0.001)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fpdf.fonts.FontFace"><code class="flex name class">
<span>class <span class="ident">FontFace</span></span>
<span>(</span><span>family=None, emphasis=None, size_pt=None, color=None, fill_color=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L46-L119" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class FontFace:
    &#34;&#34;&#34;
    Represent basic font styling properties.
    This is a subset of `fpdf.graphics_state.GraphicsStateMixin` properties.
    &#34;&#34;&#34;

    __slots__ = (  # RAM usage optimization
        &#34;family&#34;,
        &#34;emphasis&#34;,
        &#34;size_pt&#34;,
        &#34;color&#34;,
        &#34;fill_color&#34;,
    )
    family: Optional[str]
    emphasis: Optional[TextEmphasis]  # None means &#34;no override&#34;
    #                                   Whereas &#34;&#34; means &#34;no emphasis&#34;
    #                                   This can be a combination: B | U
    size_pt: Optional[int]
    # Colors are single number grey scales or (red, green, blue) tuples:
    color: Optional[Union[DeviceGray, DeviceRGB]]
    fill_color: Optional[Union[DeviceGray, DeviceRGB]]

    def __init__(
        self, family=None, emphasis=None, size_pt=None, color=None, fill_color=None
    ):
        self.family = family
        self.emphasis = None if emphasis is None else TextEmphasis.coerce(emphasis)
        self.size_pt = size_pt
        self.color = None if color is None else convert_to_device_color(color)
        self.fill_color = (
            None if fill_color is None else convert_to_device_color(fill_color)
        )

    replace = replace
    &#34;&#34;&#34;
    Create a new FontFace instance, with new values for some attributes.
    Same as `dataclasses.replace()`
    &#34;&#34;&#34;

    @staticmethod
    def _override(current_value, override_value):
        &#34;&#34;&#34;Override the current value if an override value is provided&#34;&#34;&#34;
        return current_value if override_value is None else override_value

    @staticmethod
    def combine(default_style, override_style):
        &#34;&#34;&#34;
        Create a combined FontFace with all the supplied features of the two styles. When both
        the default and override styles provide a feature, prefer the override style.
        Override specified FontFace style features
        Override this FontFace&#39;s values with the values of `other`.
        Values of `other` that are None in this FontFace will be kept unchanged.
        &#34;&#34;&#34;
        if override_style is None:
            return default_style
        if default_style is None:
            return override_style
        if not isinstance(override_style, FontFace):
            raise TypeError(f&#34;Cannot combine FontFace with {type(override_style)}&#34;)
        if not isinstance(default_style, FontFace):
            raise TypeError(f&#34;Cannot combine FontFace with {type(default_style)}&#34;)
        return FontFace(
            family=FontFace._override(default_style.family, override_style.family),
            emphasis=FontFace._override(
                default_style.emphasis,
                override_style.emphasis,
            ),
            size_pt=FontFace._override(default_style.size_pt, override_style.size_pt),
            color=FontFace._override(default_style.color, override_style.color),
            fill_color=FontFace._override(
                default_style.fill_color, override_style.fill_color
            ),
        )</code></pre>
</details>
<div class="desc"><p>Represent basic font styling properties.
This is a subset of <code><a title="fpdf.graphics_state.GraphicsStateMixin" href="graphics_state.html#fpdf.graphics_state.GraphicsStateMixin">GraphicsStateMixin</a></code> properties.</p></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fpdf.fonts.TextStyle" href="#fpdf.fonts.TextStyle">TextStyle</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fpdf.fonts.FontFace.combine"><code class="name flex">
<span>def <span class="ident">combine</span></span>(<span>default_style, override_style)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L91-L119" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def combine(default_style, override_style):
    &#34;&#34;&#34;
    Create a combined FontFace with all the supplied features of the two styles. When both
    the default and override styles provide a feature, prefer the override style.
    Override specified FontFace style features
    Override this FontFace&#39;s values with the values of `other`.
    Values of `other` that are None in this FontFace will be kept unchanged.
    &#34;&#34;&#34;
    if override_style is None:
        return default_style
    if default_style is None:
        return override_style
    if not isinstance(override_style, FontFace):
        raise TypeError(f&#34;Cannot combine FontFace with {type(override_style)}&#34;)
    if not isinstance(default_style, FontFace):
        raise TypeError(f&#34;Cannot combine FontFace with {type(default_style)}&#34;)
    return FontFace(
        family=FontFace._override(default_style.family, override_style.family),
        emphasis=FontFace._override(
            default_style.emphasis,
            override_style.emphasis,
        ),
        size_pt=FontFace._override(default_style.size_pt, override_style.size_pt),
        color=FontFace._override(default_style.color, override_style.color),
        fill_color=FontFace._override(
            default_style.fill_color, override_style.fill_color
        ),
    )</code></pre>
</details>
<div class="desc"><p>Create a combined FontFace with all the supplied features of the two styles. When both
the default and override styles provide a feature, prefer the override style.
Override specified FontFace style features
Override this FontFace's values with the values of <code>other</code>.
Values of <code>other</code> that are None in this FontFace will be kept unchanged.</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.fonts.FontFace.color"><code class="name">var <span class="ident">color</span> :Â <a title="fpdf.drawing.DeviceGray" href="drawing.html#fpdf.drawing.DeviceGray">DeviceGray</a>Â |Â <a title="fpdf.drawing.DeviceRGB" href="drawing.html#fpdf.drawing.DeviceRGB">DeviceRGB</a>Â |Â None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L46-L119" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class FontFace:
    &#34;&#34;&#34;
    Represent basic font styling properties.
    This is a subset of `fpdf.graphics_state.GraphicsStateMixin` properties.
    &#34;&#34;&#34;

    __slots__ = (  # RAM usage optimization
        &#34;family&#34;,
        &#34;emphasis&#34;,
        &#34;size_pt&#34;,
        &#34;color&#34;,
        &#34;fill_color&#34;,
    )
    family: Optional[str]
    emphasis: Optional[TextEmphasis]  # None means &#34;no override&#34;
    #                                   Whereas &#34;&#34; means &#34;no emphasis&#34;
    #                                   This can be a combination: B | U
    size_pt: Optional[int]
    # Colors are single number grey scales or (red, green, blue) tuples:
    color: Optional[Union[DeviceGray, DeviceRGB]]
    fill_color: Optional[Union[DeviceGray, DeviceRGB]]

    def __init__(
        self, family=None, emphasis=None, size_pt=None, color=None, fill_color=None
    ):
        self.family = family
        self.emphasis = None if emphasis is None else TextEmphasis.coerce(emphasis)
        self.size_pt = size_pt
        self.color = None if color is None else convert_to_device_color(color)
        self.fill_color = (
            None if fill_color is None else convert_to_device_color(fill_color)
        )

    replace = replace
    &#34;&#34;&#34;
    Create a new FontFace instance, with new values for some attributes.
    Same as `dataclasses.replace()`
    &#34;&#34;&#34;

    @staticmethod
    def _override(current_value, override_value):
        &#34;&#34;&#34;Override the current value if an override value is provided&#34;&#34;&#34;
        return current_value if override_value is None else override_value

    @staticmethod
    def combine(default_style, override_style):
        &#34;&#34;&#34;
        Create a combined FontFace with all the supplied features of the two styles. When both
        the default and override styles provide a feature, prefer the override style.
        Override specified FontFace style features
        Override this FontFace&#39;s values with the values of `other`.
        Values of `other` that are None in this FontFace will be kept unchanged.
        &#34;&#34;&#34;
        if override_style is None:
            return default_style
        if default_style is None:
            return override_style
        if not isinstance(override_style, FontFace):
            raise TypeError(f&#34;Cannot combine FontFace with {type(override_style)}&#34;)
        if not isinstance(default_style, FontFace):
            raise TypeError(f&#34;Cannot combine FontFace with {type(default_style)}&#34;)
        return FontFace(
            family=FontFace._override(default_style.family, override_style.family),
            emphasis=FontFace._override(
                default_style.emphasis,
                override_style.emphasis,
            ),
            size_pt=FontFace._override(default_style.size_pt, override_style.size_pt),
            color=FontFace._override(default_style.color, override_style.color),
            fill_color=FontFace._override(
                default_style.fill_color, override_style.fill_color
            ),
        )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.FontFace.emphasis"><code class="name">var <span class="ident">emphasis</span> :Â <a title="fpdf.enums.TextEmphasis" href="enums.html#fpdf.enums.TextEmphasis">TextEmphasis</a>Â |Â None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L46-L119" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class FontFace:
    &#34;&#34;&#34;
    Represent basic font styling properties.
    This is a subset of `fpdf.graphics_state.GraphicsStateMixin` properties.
    &#34;&#34;&#34;

    __slots__ = (  # RAM usage optimization
        &#34;family&#34;,
        &#34;emphasis&#34;,
        &#34;size_pt&#34;,
        &#34;color&#34;,
        &#34;fill_color&#34;,
    )
    family: Optional[str]
    emphasis: Optional[TextEmphasis]  # None means &#34;no override&#34;
    #                                   Whereas &#34;&#34; means &#34;no emphasis&#34;
    #                                   This can be a combination: B | U
    size_pt: Optional[int]
    # Colors are single number grey scales or (red, green, blue) tuples:
    color: Optional[Union[DeviceGray, DeviceRGB]]
    fill_color: Optional[Union[DeviceGray, DeviceRGB]]

    def __init__(
        self, family=None, emphasis=None, size_pt=None, color=None, fill_color=None
    ):
        self.family = family
        self.emphasis = None if emphasis is None else TextEmphasis.coerce(emphasis)
        self.size_pt = size_pt
        self.color = None if color is None else convert_to_device_color(color)
        self.fill_color = (
            None if fill_color is None else convert_to_device_color(fill_color)
        )

    replace = replace
    &#34;&#34;&#34;
    Create a new FontFace instance, with new values for some attributes.
    Same as `dataclasses.replace()`
    &#34;&#34;&#34;

    @staticmethod
    def _override(current_value, override_value):
        &#34;&#34;&#34;Override the current value if an override value is provided&#34;&#34;&#34;
        return current_value if override_value is None else override_value

    @staticmethod
    def combine(default_style, override_style):
        &#34;&#34;&#34;
        Create a combined FontFace with all the supplied features of the two styles. When both
        the default and override styles provide a feature, prefer the override style.
        Override specified FontFace style features
        Override this FontFace&#39;s values with the values of `other`.
        Values of `other` that are None in this FontFace will be kept unchanged.
        &#34;&#34;&#34;
        if override_style is None:
            return default_style
        if default_style is None:
            return override_style
        if not isinstance(override_style, FontFace):
            raise TypeError(f&#34;Cannot combine FontFace with {type(override_style)}&#34;)
        if not isinstance(default_style, FontFace):
            raise TypeError(f&#34;Cannot combine FontFace with {type(default_style)}&#34;)
        return FontFace(
            family=FontFace._override(default_style.family, override_style.family),
            emphasis=FontFace._override(
                default_style.emphasis,
                override_style.emphasis,
            ),
            size_pt=FontFace._override(default_style.size_pt, override_style.size_pt),
            color=FontFace._override(default_style.color, override_style.color),
            fill_color=FontFace._override(
                default_style.fill_color, override_style.fill_color
            ),
        )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.FontFace.family"><code class="name">var <span class="ident">family</span> :Â strÂ |Â None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L46-L119" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class FontFace:
    &#34;&#34;&#34;
    Represent basic font styling properties.
    This is a subset of `fpdf.graphics_state.GraphicsStateMixin` properties.
    &#34;&#34;&#34;

    __slots__ = (  # RAM usage optimization
        &#34;family&#34;,
        &#34;emphasis&#34;,
        &#34;size_pt&#34;,
        &#34;color&#34;,
        &#34;fill_color&#34;,
    )
    family: Optional[str]
    emphasis: Optional[TextEmphasis]  # None means &#34;no override&#34;
    #                                   Whereas &#34;&#34; means &#34;no emphasis&#34;
    #                                   This can be a combination: B | U
    size_pt: Optional[int]
    # Colors are single number grey scales or (red, green, blue) tuples:
    color: Optional[Union[DeviceGray, DeviceRGB]]
    fill_color: Optional[Union[DeviceGray, DeviceRGB]]

    def __init__(
        self, family=None, emphasis=None, size_pt=None, color=None, fill_color=None
    ):
        self.family = family
        self.emphasis = None if emphasis is None else TextEmphasis.coerce(emphasis)
        self.size_pt = size_pt
        self.color = None if color is None else convert_to_device_color(color)
        self.fill_color = (
            None if fill_color is None else convert_to_device_color(fill_color)
        )

    replace = replace
    &#34;&#34;&#34;
    Create a new FontFace instance, with new values for some attributes.
    Same as `dataclasses.replace()`
    &#34;&#34;&#34;

    @staticmethod
    def _override(current_value, override_value):
        &#34;&#34;&#34;Override the current value if an override value is provided&#34;&#34;&#34;
        return current_value if override_value is None else override_value

    @staticmethod
    def combine(default_style, override_style):
        &#34;&#34;&#34;
        Create a combined FontFace with all the supplied features of the two styles. When both
        the default and override styles provide a feature, prefer the override style.
        Override specified FontFace style features
        Override this FontFace&#39;s values with the values of `other`.
        Values of `other` that are None in this FontFace will be kept unchanged.
        &#34;&#34;&#34;
        if override_style is None:
            return default_style
        if default_style is None:
            return override_style
        if not isinstance(override_style, FontFace):
            raise TypeError(f&#34;Cannot combine FontFace with {type(override_style)}&#34;)
        if not isinstance(default_style, FontFace):
            raise TypeError(f&#34;Cannot combine FontFace with {type(default_style)}&#34;)
        return FontFace(
            family=FontFace._override(default_style.family, override_style.family),
            emphasis=FontFace._override(
                default_style.emphasis,
                override_style.emphasis,
            ),
            size_pt=FontFace._override(default_style.size_pt, override_style.size_pt),
            color=FontFace._override(default_style.color, override_style.color),
            fill_color=FontFace._override(
                default_style.fill_color, override_style.fill_color
            ),
        )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.FontFace.fill_color"><code class="name">var <span class="ident">fill_color</span> :Â <a title="fpdf.drawing.DeviceGray" href="drawing.html#fpdf.drawing.DeviceGray">DeviceGray</a>Â |Â <a title="fpdf.drawing.DeviceRGB" href="drawing.html#fpdf.drawing.DeviceRGB">DeviceRGB</a>Â |Â None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L46-L119" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class FontFace:
    &#34;&#34;&#34;
    Represent basic font styling properties.
    This is a subset of `fpdf.graphics_state.GraphicsStateMixin` properties.
    &#34;&#34;&#34;

    __slots__ = (  # RAM usage optimization
        &#34;family&#34;,
        &#34;emphasis&#34;,
        &#34;size_pt&#34;,
        &#34;color&#34;,
        &#34;fill_color&#34;,
    )
    family: Optional[str]
    emphasis: Optional[TextEmphasis]  # None means &#34;no override&#34;
    #                                   Whereas &#34;&#34; means &#34;no emphasis&#34;
    #                                   This can be a combination: B | U
    size_pt: Optional[int]
    # Colors are single number grey scales or (red, green, blue) tuples:
    color: Optional[Union[DeviceGray, DeviceRGB]]
    fill_color: Optional[Union[DeviceGray, DeviceRGB]]

    def __init__(
        self, family=None, emphasis=None, size_pt=None, color=None, fill_color=None
    ):
        self.family = family
        self.emphasis = None if emphasis is None else TextEmphasis.coerce(emphasis)
        self.size_pt = size_pt
        self.color = None if color is None else convert_to_device_color(color)
        self.fill_color = (
            None if fill_color is None else convert_to_device_color(fill_color)
        )

    replace = replace
    &#34;&#34;&#34;
    Create a new FontFace instance, with new values for some attributes.
    Same as `dataclasses.replace()`
    &#34;&#34;&#34;

    @staticmethod
    def _override(current_value, override_value):
        &#34;&#34;&#34;Override the current value if an override value is provided&#34;&#34;&#34;
        return current_value if override_value is None else override_value

    @staticmethod
    def combine(default_style, override_style):
        &#34;&#34;&#34;
        Create a combined FontFace with all the supplied features of the two styles. When both
        the default and override styles provide a feature, prefer the override style.
        Override specified FontFace style features
        Override this FontFace&#39;s values with the values of `other`.
        Values of `other` that are None in this FontFace will be kept unchanged.
        &#34;&#34;&#34;
        if override_style is None:
            return default_style
        if default_style is None:
            return override_style
        if not isinstance(override_style, FontFace):
            raise TypeError(f&#34;Cannot combine FontFace with {type(override_style)}&#34;)
        if not isinstance(default_style, FontFace):
            raise TypeError(f&#34;Cannot combine FontFace with {type(default_style)}&#34;)
        return FontFace(
            family=FontFace._override(default_style.family, override_style.family),
            emphasis=FontFace._override(
                default_style.emphasis,
                override_style.emphasis,
            ),
            size_pt=FontFace._override(default_style.size_pt, override_style.size_pt),
            color=FontFace._override(default_style.color, override_style.color),
            fill_color=FontFace._override(
                default_style.fill_color, override_style.fill_color
            ),
        )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.FontFace.size_pt"><code class="name">var <span class="ident">size_pt</span> :Â intÂ |Â None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L46-L119" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class FontFace:
    &#34;&#34;&#34;
    Represent basic font styling properties.
    This is a subset of `fpdf.graphics_state.GraphicsStateMixin` properties.
    &#34;&#34;&#34;

    __slots__ = (  # RAM usage optimization
        &#34;family&#34;,
        &#34;emphasis&#34;,
        &#34;size_pt&#34;,
        &#34;color&#34;,
        &#34;fill_color&#34;,
    )
    family: Optional[str]
    emphasis: Optional[TextEmphasis]  # None means &#34;no override&#34;
    #                                   Whereas &#34;&#34; means &#34;no emphasis&#34;
    #                                   This can be a combination: B | U
    size_pt: Optional[int]
    # Colors are single number grey scales or (red, green, blue) tuples:
    color: Optional[Union[DeviceGray, DeviceRGB]]
    fill_color: Optional[Union[DeviceGray, DeviceRGB]]

    def __init__(
        self, family=None, emphasis=None, size_pt=None, color=None, fill_color=None
    ):
        self.family = family
        self.emphasis = None if emphasis is None else TextEmphasis.coerce(emphasis)
        self.size_pt = size_pt
        self.color = None if color is None else convert_to_device_color(color)
        self.fill_color = (
            None if fill_color is None else convert_to_device_color(fill_color)
        )

    replace = replace
    &#34;&#34;&#34;
    Create a new FontFace instance, with new values for some attributes.
    Same as `dataclasses.replace()`
    &#34;&#34;&#34;

    @staticmethod
    def _override(current_value, override_value):
        &#34;&#34;&#34;Override the current value if an override value is provided&#34;&#34;&#34;
        return current_value if override_value is None else override_value

    @staticmethod
    def combine(default_style, override_style):
        &#34;&#34;&#34;
        Create a combined FontFace with all the supplied features of the two styles. When both
        the default and override styles provide a feature, prefer the override style.
        Override specified FontFace style features
        Override this FontFace&#39;s values with the values of `other`.
        Values of `other` that are None in this FontFace will be kept unchanged.
        &#34;&#34;&#34;
        if override_style is None:
            return default_style
        if default_style is None:
            return override_style
        if not isinstance(override_style, FontFace):
            raise TypeError(f&#34;Cannot combine FontFace with {type(override_style)}&#34;)
        if not isinstance(default_style, FontFace):
            raise TypeError(f&#34;Cannot combine FontFace with {type(default_style)}&#34;)
        return FontFace(
            family=FontFace._override(default_style.family, override_style.family),
            emphasis=FontFace._override(
                default_style.emphasis,
                override_style.emphasis,
            ),
            size_pt=FontFace._override(default_style.size_pt, override_style.size_pt),
            color=FontFace._override(default_style.color, override_style.color),
            fill_color=FontFace._override(
                default_style.fill_color, override_style.fill_color
            ),
        )</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.fonts.FontFace.replace"><code class="name flex">
<span>def <span class="ident">replace</span></span>(<span>obj, /, **changes)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replace(obj, /, **changes):
    &#34;&#34;&#34;Return a new object replacing specified fields with new values.

    This is especially useful for frozen classes.  Example usage::

      @dataclass(frozen=True)
      class C:
          x: int
          y: int

      c = C(1, 2)
      c1 = replace(c, x=3)
      assert c1.x == 3 and c1.y == 2
    &#34;&#34;&#34;
    if not _is_dataclass_instance(obj):
        raise TypeError(&#34;replace() should be called on dataclass instances&#34;)
    return _replace(obj, **changes)</code></pre>
</details>
<div class="desc"><p>Return a new object replacing specified fields with new values.</p>
<p>This is especially useful for frozen classes.
Example usage::</p>
<p>@dataclass(frozen=True)
class C:
x: int
y: int</p>
<p>c = C(1, 2)
c1 = replace(c, x=3)
assert c1.x == 3 and c1.y == 2</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.fonts.Glyph"><code class="flex name class">
<span>class <span class="ident">Glyph</span></span>
<span>(</span><span>glyph_id:Â int, unicode:Â Tuple, glyph_name:Â str, glyph_width:Â int)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L584-L600" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@dataclass(order=True)
class Glyph:
    &#34;&#34;&#34;
    This represents one glyph on the font
    Unicode is a tuple because ligatures or character substitution
    can map a sequence of unicode characters to a single glyph
    &#34;&#34;&#34;

    # RAM usage optimization:
    __slots__ = (&#34;glyph_id&#34;, &#34;unicode&#34;, &#34;glyph_name&#34;, &#34;glyph_width&#34;)
    glyph_id: int
    unicode: Tuple
    glyph_name: str
    glyph_width: int

    def __hash__(self):
        return self.glyph_id</code></pre>
</details>
<div class="desc"><p>This represents one glyph on the font
Unicode is a tuple because ligatures or character substitution
can map a sequence of unicode characters to a single glyph</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.fonts.Glyph.glyph_id"><code class="name">var <span class="ident">glyph_id</span> :Â int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L584-L600" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@dataclass(order=True)
class Glyph:
    &#34;&#34;&#34;
    This represents one glyph on the font
    Unicode is a tuple because ligatures or character substitution
    can map a sequence of unicode characters to a single glyph
    &#34;&#34;&#34;

    # RAM usage optimization:
    __slots__ = (&#34;glyph_id&#34;, &#34;unicode&#34;, &#34;glyph_name&#34;, &#34;glyph_width&#34;)
    glyph_id: int
    unicode: Tuple
    glyph_name: str
    glyph_width: int

    def __hash__(self):
        return self.glyph_id</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.Glyph.glyph_name"><code class="name">var <span class="ident">glyph_name</span> :Â str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L584-L600" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@dataclass(order=True)
class Glyph:
    &#34;&#34;&#34;
    This represents one glyph on the font
    Unicode is a tuple because ligatures or character substitution
    can map a sequence of unicode characters to a single glyph
    &#34;&#34;&#34;

    # RAM usage optimization:
    __slots__ = (&#34;glyph_id&#34;, &#34;unicode&#34;, &#34;glyph_name&#34;, &#34;glyph_width&#34;)
    glyph_id: int
    unicode: Tuple
    glyph_name: str
    glyph_width: int

    def __hash__(self):
        return self.glyph_id</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.Glyph.glyph_width"><code class="name">var <span class="ident">glyph_width</span> :Â int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L584-L600" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@dataclass(order=True)
class Glyph:
    &#34;&#34;&#34;
    This represents one glyph on the font
    Unicode is a tuple because ligatures or character substitution
    can map a sequence of unicode characters to a single glyph
    &#34;&#34;&#34;

    # RAM usage optimization:
    __slots__ = (&#34;glyph_id&#34;, &#34;unicode&#34;, &#34;glyph_name&#34;, &#34;glyph_width&#34;)
    glyph_id: int
    unicode: Tuple
    glyph_name: str
    glyph_width: int

    def __hash__(self):
        return self.glyph_id</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.Glyph.unicode"><code class="name">var <span class="ident">unicode</span> :Â Tuple</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L584-L600" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@dataclass(order=True)
class Glyph:
    &#34;&#34;&#34;
    This represents one glyph on the font
    Unicode is a tuple because ligatures or character substitution
    can map a sequence of unicode characters to a single glyph
    &#34;&#34;&#34;

    # RAM usage optimization:
    __slots__ = (&#34;glyph_id&#34;, &#34;unicode&#34;, &#34;glyph_name&#34;, &#34;glyph_width&#34;)
    glyph_id: int
    unicode: Tuple
    glyph_name: str
    glyph_width: int

    def __hash__(self):
        return self.glyph_id</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fpdf.fonts.PDFFontDescriptor"><code class="flex name class">
<span>class <span class="ident">PDFFontDescriptor</span></span>
<span>(</span><span>ascent, descent, cap_height, flags, font_b_box, italic_angle, stem_v, missing_width)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L559-L581" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFFontDescriptor(PDFObject):
    def __init__(
        self,
        ascent,
        descent,
        cap_height,
        flags,
        font_b_box,
        italic_angle,
        stem_v,
        missing_width,
    ):
        super().__init__()
        self.type = Name(&#34;FontDescriptor&#34;)
        self.ascent = ascent
        self.descent = descent
        self.cap_height = cap_height
        self.flags = flags
        self.font_b_box = font_b_box
        self.italic_angle = italic_angle
        self.stem_v = stem_v
        self.missing_width = missing_width
        self.font_name = None</code></pre>
</details>
<div class="desc"></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fpdf.syntax.PDFObject" href="syntax.html#fpdf.syntax.PDFObject">PDFObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fpdf.fonts.PDFFontDescriptor.content_stream"><code class="name flex">
<span>def <span class="ident">content_stream</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.syntax.PDFObject" href="syntax.html#fpdf.syntax.PDFObject">PDFObject</a></code>.<code><a title="fpdf.syntax.PDFObject.content_stream" href="syntax.html#fpdf.syntax.PDFObject.content_stream">content_stream</a></code>
</p>
<div class="desc inherited"><p>Subclasses can override this method to indicate the presence of a content stream</p></div>
</dd>
<dt id="fpdf.fonts.PDFFontDescriptor.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self, obj_dict=None)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.syntax.PDFObject" href="syntax.html#fpdf.syntax.PDFObject">PDFObject</a></code>.<code><a title="fpdf.syntax.PDFObject.serialize" href="syntax.html#fpdf.syntax.PDFObject.serialize">serialize</a></code>
</p>
<div class="desc inherited"><p>Serialize the PDF object as an obj&lt;&lt;/&gt;&gt;endobj text block</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.fonts.SubsetMap"><code class="flex name class">
<span>class <span class="ident">SubsetMap</span></span>
<span>(</span><span>font:Â <a title="fpdf.fonts.TTFFont" href="#fpdf.fonts.TTFFont">TTFFont</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L603-L684" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class SubsetMap:
    &#34;&#34;&#34;
    Holds a mapping of used characters and their position in the font&#39;s subset

    Characters that must be mapped on their actual unicode must be part of the
    `identities` list during object instantiation. These non-negative values should
    only appear once in the list. `pick()` can be used to get the characters
    corresponding position in the subset. If it&#39;s not yet part of the object, a new
    position is acquired automatically. This implementation always tries to return
    the lowest possible representation.
    &#34;&#34;&#34;

    def __init__(self, font: TTFFont):
        super().__init__()
        self.font = font
        self._next = 0

        # 0x00 &#34;.notdef&#34; and 0x20 &#34;space&#34; are reserved
        self._reserved = [0x00, 0x20]

        # Maps Glyph instances to character IDs (integers):
        self._char_id_per_glyph = {}
        for x in self._reserved:
            glyph = self.get_glyph(unicode=x)
            if glyph:
                self._char_id_per_glyph[glyph] = int(x)

    def __repr__(self):
        return (
            f&#34;SubsetMap(font={self.font}, _next={self._next},&#34;
            f&#34; _reserved={self._reserved}, _char_id_per_glyph={self._char_id_per_glyph})&#34;
        )

    def __len__(self):
        return len(self._char_id_per_glyph)

    def items(self):
        for glyph, char_id in self._char_id_per_glyph.items():
            yield glyph, char_id

    # pylint: disable=method-cache-max-size-none
    @lru_cache(maxsize=None)
    def pick(self, unicode: int):
        glyph = self.get_glyph(unicode=unicode)
        if glyph is None and unicode not in self.font.missing_glyphs:
            self.font.missing_glyphs.append(unicode)
        return self.pick_glyph(glyph)

    def pick_glyph(self, glyph):
        char_id = self._char_id_per_glyph.get(glyph)
        if glyph and char_id is None:
            while self._next in self._reserved:
                self._next += 1
                if self._next &gt; self._reserved[0]:
                    del self._reserved[0]
            char_id = self._next
            self._char_id_per_glyph[glyph] = char_id
            self._next += 1
        return char_id

    # pylint: disable=method-cache-max-size-none
    @lru_cache(maxsize=None)
    def get_glyph(
        self, glyph=None, unicode=None, glyph_name=None, glyph_width=None
    ) -&gt; Glyph:
        if glyph:
            return Glyph(glyph, tuple(unicode), glyph_name, glyph_width)
        glyph_id = self.font.glyph_ids.get(unicode)
        if isinstance(unicode, int) and glyph_id is not None:
            return Glyph(
                glyph_id,
                (unicode,),
                self.font.cmap[unicode],
                self.font.cw[unicode],
            )
        if unicode == 0x00:
            glyph_id = next(iter(self.font.cmap))
            return Glyph(glyph_id, (0x00,), &#34;.notdef&#34;, 0)
        return None

    def get_all_glyph_names(self):
        return [glyph.glyph_name for glyph in self._char_id_per_glyph]</code></pre>
</details>
<div class="desc"><p>Holds a mapping of used characters and their position in the font's subset</p>
<p>Characters that must be mapped on their actual unicode must be part of the
<code>identities</code> list during object instantiation. These non-negative values should
only appear once in the list. <code>pick()</code> can be used to get the characters
corresponding position in the subset. If it's not yet part of the object, a new
position is acquired automatically. This implementation always tries to return
the lowest possible representation.</p></div>
<h3>Methods</h3>
<dl>
<dt id="fpdf.fonts.SubsetMap.get_all_glyph_names"><code class="name flex">
<span>def <span class="ident">get_all_glyph_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L683-L684" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def get_all_glyph_names(self):
    return [glyph.glyph_name for glyph in self._char_id_per_glyph]</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.SubsetMap.get_glyph"><code class="name flex">
<span>def <span class="ident">get_glyph</span></span>(<span>self, glyph=None, unicode=None, glyph_name=None, glyph_width=None) â€‘>Â <a title="fpdf.fonts.Glyph" href="#fpdf.fonts.Glyph">Glyph</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L664-L681" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@lru_cache(maxsize=None)
def get_glyph(
    self, glyph=None, unicode=None, glyph_name=None, glyph_width=None
) -&gt; Glyph:
    if glyph:
        return Glyph(glyph, tuple(unicode), glyph_name, glyph_width)
    glyph_id = self.font.glyph_ids.get(unicode)
    if isinstance(unicode, int) and glyph_id is not None:
        return Glyph(
            glyph_id,
            (unicode,),
            self.font.cmap[unicode],
            self.font.cw[unicode],
        )
    if unicode == 0x00:
        glyph_id = next(iter(self.font.cmap))
        return Glyph(glyph_id, (0x00,), &#34;.notdef&#34;, 0)
    return None</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.SubsetMap.items"><code class="name flex">
<span>def <span class="ident">items</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L639-L641" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def items(self):
    for glyph, char_id in self._char_id_per_glyph.items():
        yield glyph, char_id</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.SubsetMap.pick"><code class="name flex">
<span>def <span class="ident">pick</span></span>(<span>self, unicode:Â int)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L644-L649" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@lru_cache(maxsize=None)
def pick(self, unicode: int):
    glyph = self.get_glyph(unicode=unicode)
    if glyph is None and unicode not in self.font.missing_glyphs:
        self.font.missing_glyphs.append(unicode)
    return self.pick_glyph(glyph)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.SubsetMap.pick_glyph"><code class="name flex">
<span>def <span class="ident">pick_glyph</span></span>(<span>self, glyph)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L651-L661" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def pick_glyph(self, glyph):
    char_id = self._char_id_per_glyph.get(glyph)
    if glyph and char_id is None:
        while self._next in self._reserved:
            self._next += 1
            if self._next &gt; self._reserved[0]:
                del self._reserved[0]
        char_id = self._next
        self._char_id_per_glyph[glyph] = char_id
        self._next += 1
    return char_id</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fpdf.fonts.TTFFont"><code class="flex name class">
<span>class <span class="ident">TTFFont</span></span>
<span>(</span><span>fpdf, font_file_path, fontkey, style)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L248-L556" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
    )

    def __init__(self, fpdf, font_file_path, fontkey, style):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.fontkey = fontkey

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        self.ttfont = ttLib.TTFont(
            self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True
        )

        self.scale = 1000 / self.ttfont[&#34;head&#34;].unitsPerEm

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if &#34;glyf&#34; in self.ttfont and &#34;.notdef&#34; not in self.ttfont[&#34;glyf&#34;]:
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            (xMin, xMax, yMin, yMax) = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][&#34;.notdef&#34;] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (xMax - xMin, yMax - yMin)

        default_width = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0])

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap = self.ttfont.getBestCmap()
        if not self.cmap:
            raise NotImplementedError(
                &#34;Font not supported as it does not have a unicode cmap table - cf. issue #1396&#34;
            )

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)

    def __repr__(self):
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self, memo):
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        return copy

    def close(self):
        self.ttfont.close()
        self.hbfont = None

    def get_text_width(self, text, font_size_pt, text_shaping_params):
        if text_shaping_params:
            return self.shaped_text_width(text, font_size_pt, text_shaping_params)
        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)

    def shaped_text_width(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        if not hasattr(self, &#34;hbfont&#34;):
            self.hbfont = HarfBuzzFont(hb.Face(hb.Blob.from_file_path(self.ttffile)))
        self.hbfont.ptem = font_size_pt
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = text_shaping_params[&#34;features&#34;]
        if text_shaping_params[&#34;fragment_direction&#34;]:
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if text_shaping_params[&#34;script&#34;]:
            buf.script = text_shaping_params[&#34;script&#34;]
        if text_shaping_params[&#34;language&#34;]:
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text):
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            txt_mapped += chr(self.subset.pick(uni))
        return f&#39;({escape_parens(txt_mapped.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))}) Tj&#39;

    def shape_text(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list, index):
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.fonts.TTFFont.cmap"><code class="name">var <span class="ident">cmap</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L248-L556" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
    )

    def __init__(self, fpdf, font_file_path, fontkey, style):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.fontkey = fontkey

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        self.ttfont = ttLib.TTFont(
            self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True
        )

        self.scale = 1000 / self.ttfont[&#34;head&#34;].unitsPerEm

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if &#34;glyf&#34; in self.ttfont and &#34;.notdef&#34; not in self.ttfont[&#34;glyf&#34;]:
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            (xMin, xMax, yMin, yMax) = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][&#34;.notdef&#34;] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (xMax - xMin, yMax - yMin)

        default_width = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0])

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap = self.ttfont.getBestCmap()
        if not self.cmap:
            raise NotImplementedError(
                &#34;Font not supported as it does not have a unicode cmap table - cf. issue #1396&#34;
            )

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)

    def __repr__(self):
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self, memo):
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        return copy

    def close(self):
        self.ttfont.close()
        self.hbfont = None

    def get_text_width(self, text, font_size_pt, text_shaping_params):
        if text_shaping_params:
            return self.shaped_text_width(text, font_size_pt, text_shaping_params)
        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)

    def shaped_text_width(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        if not hasattr(self, &#34;hbfont&#34;):
            self.hbfont = HarfBuzzFont(hb.Face(hb.Blob.from_file_path(self.ttffile)))
        self.hbfont.ptem = font_size_pt
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = text_shaping_params[&#34;features&#34;]
        if text_shaping_params[&#34;fragment_direction&#34;]:
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if text_shaping_params[&#34;script&#34;]:
            buf.script = text_shaping_params[&#34;script&#34;]
        if text_shaping_params[&#34;language&#34;]:
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text):
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            txt_mapped += chr(self.subset.pick(uni))
        return f&#39;({escape_parens(txt_mapped.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))}) Tj&#39;

    def shape_text(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list, index):
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.cw"><code class="name">var <span class="ident">cw</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L248-L556" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
    )

    def __init__(self, fpdf, font_file_path, fontkey, style):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.fontkey = fontkey

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        self.ttfont = ttLib.TTFont(
            self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True
        )

        self.scale = 1000 / self.ttfont[&#34;head&#34;].unitsPerEm

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if &#34;glyf&#34; in self.ttfont and &#34;.notdef&#34; not in self.ttfont[&#34;glyf&#34;]:
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            (xMin, xMax, yMin, yMax) = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][&#34;.notdef&#34;] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (xMax - xMin, yMax - yMin)

        default_width = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0])

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap = self.ttfont.getBestCmap()
        if not self.cmap:
            raise NotImplementedError(
                &#34;Font not supported as it does not have a unicode cmap table - cf. issue #1396&#34;
            )

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)

    def __repr__(self):
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self, memo):
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        return copy

    def close(self):
        self.ttfont.close()
        self.hbfont = None

    def get_text_width(self, text, font_size_pt, text_shaping_params):
        if text_shaping_params:
            return self.shaped_text_width(text, font_size_pt, text_shaping_params)
        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)

    def shaped_text_width(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        if not hasattr(self, &#34;hbfont&#34;):
            self.hbfont = HarfBuzzFont(hb.Face(hb.Blob.from_file_path(self.ttffile)))
        self.hbfont.ptem = font_size_pt
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = text_shaping_params[&#34;features&#34;]
        if text_shaping_params[&#34;fragment_direction&#34;]:
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if text_shaping_params[&#34;script&#34;]:
            buf.script = text_shaping_params[&#34;script&#34;]
        if text_shaping_params[&#34;language&#34;]:
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text):
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            txt_mapped += chr(self.subset.pick(uni))
        return f&#39;({escape_parens(txt_mapped.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))}) Tj&#39;

    def shape_text(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list, index):
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.desc"><code class="name">var <span class="ident">desc</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L248-L556" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
    )

    def __init__(self, fpdf, font_file_path, fontkey, style):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.fontkey = fontkey

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        self.ttfont = ttLib.TTFont(
            self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True
        )

        self.scale = 1000 / self.ttfont[&#34;head&#34;].unitsPerEm

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if &#34;glyf&#34; in self.ttfont and &#34;.notdef&#34; not in self.ttfont[&#34;glyf&#34;]:
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            (xMin, xMax, yMin, yMax) = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][&#34;.notdef&#34;] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (xMax - xMin, yMax - yMin)

        default_width = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0])

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap = self.ttfont.getBestCmap()
        if not self.cmap:
            raise NotImplementedError(
                &#34;Font not supported as it does not have a unicode cmap table - cf. issue #1396&#34;
            )

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)

    def __repr__(self):
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self, memo):
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        return copy

    def close(self):
        self.ttfont.close()
        self.hbfont = None

    def get_text_width(self, text, font_size_pt, text_shaping_params):
        if text_shaping_params:
            return self.shaped_text_width(text, font_size_pt, text_shaping_params)
        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)

    def shaped_text_width(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        if not hasattr(self, &#34;hbfont&#34;):
            self.hbfont = HarfBuzzFont(hb.Face(hb.Blob.from_file_path(self.ttffile)))
        self.hbfont.ptem = font_size_pt
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = text_shaping_params[&#34;features&#34;]
        if text_shaping_params[&#34;fragment_direction&#34;]:
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if text_shaping_params[&#34;script&#34;]:
            buf.script = text_shaping_params[&#34;script&#34;]
        if text_shaping_params[&#34;language&#34;]:
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text):
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            txt_mapped += chr(self.subset.pick(uni))
        return f&#39;({escape_parens(txt_mapped.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))}) Tj&#39;

    def shape_text(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list, index):
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.emphasis"><code class="name">var <span class="ident">emphasis</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L248-L556" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
    )

    def __init__(self, fpdf, font_file_path, fontkey, style):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.fontkey = fontkey

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        self.ttfont = ttLib.TTFont(
            self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True
        )

        self.scale = 1000 / self.ttfont[&#34;head&#34;].unitsPerEm

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if &#34;glyf&#34; in self.ttfont and &#34;.notdef&#34; not in self.ttfont[&#34;glyf&#34;]:
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            (xMin, xMax, yMin, yMax) = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][&#34;.notdef&#34;] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (xMax - xMin, yMax - yMin)

        default_width = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0])

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap = self.ttfont.getBestCmap()
        if not self.cmap:
            raise NotImplementedError(
                &#34;Font not supported as it does not have a unicode cmap table - cf. issue #1396&#34;
            )

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)

    def __repr__(self):
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self, memo):
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        return copy

    def close(self):
        self.ttfont.close()
        self.hbfont = None

    def get_text_width(self, text, font_size_pt, text_shaping_params):
        if text_shaping_params:
            return self.shaped_text_width(text, font_size_pt, text_shaping_params)
        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)

    def shaped_text_width(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        if not hasattr(self, &#34;hbfont&#34;):
            self.hbfont = HarfBuzzFont(hb.Face(hb.Blob.from_file_path(self.ttffile)))
        self.hbfont.ptem = font_size_pt
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = text_shaping_params[&#34;features&#34;]
        if text_shaping_params[&#34;fragment_direction&#34;]:
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if text_shaping_params[&#34;script&#34;]:
            buf.script = text_shaping_params[&#34;script&#34;]
        if text_shaping_params[&#34;language&#34;]:
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text):
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            txt_mapped += chr(self.subset.pick(uni))
        return f&#39;({escape_parens(txt_mapped.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))}) Tj&#39;

    def shape_text(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list, index):
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.fontkey"><code class="name">var <span class="ident">fontkey</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L248-L556" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
    )

    def __init__(self, fpdf, font_file_path, fontkey, style):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.fontkey = fontkey

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        self.ttfont = ttLib.TTFont(
            self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True
        )

        self.scale = 1000 / self.ttfont[&#34;head&#34;].unitsPerEm

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if &#34;glyf&#34; in self.ttfont and &#34;.notdef&#34; not in self.ttfont[&#34;glyf&#34;]:
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            (xMin, xMax, yMin, yMax) = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][&#34;.notdef&#34;] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (xMax - xMin, yMax - yMin)

        default_width = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0])

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap = self.ttfont.getBestCmap()
        if not self.cmap:
            raise NotImplementedError(
                &#34;Font not supported as it does not have a unicode cmap table - cf. issue #1396&#34;
            )

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)

    def __repr__(self):
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self, memo):
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        return copy

    def close(self):
        self.ttfont.close()
        self.hbfont = None

    def get_text_width(self, text, font_size_pt, text_shaping_params):
        if text_shaping_params:
            return self.shaped_text_width(text, font_size_pt, text_shaping_params)
        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)

    def shaped_text_width(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        if not hasattr(self, &#34;hbfont&#34;):
            self.hbfont = HarfBuzzFont(hb.Face(hb.Blob.from_file_path(self.ttffile)))
        self.hbfont.ptem = font_size_pt
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = text_shaping_params[&#34;features&#34;]
        if text_shaping_params[&#34;fragment_direction&#34;]:
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if text_shaping_params[&#34;script&#34;]:
            buf.script = text_shaping_params[&#34;script&#34;]
        if text_shaping_params[&#34;language&#34;]:
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text):
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            txt_mapped += chr(self.subset.pick(uni))
        return f&#39;({escape_parens(txt_mapped.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))}) Tj&#39;

    def shape_text(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list, index):
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.glyph_ids"><code class="name">var <span class="ident">glyph_ids</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L248-L556" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
    )

    def __init__(self, fpdf, font_file_path, fontkey, style):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.fontkey = fontkey

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        self.ttfont = ttLib.TTFont(
            self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True
        )

        self.scale = 1000 / self.ttfont[&#34;head&#34;].unitsPerEm

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if &#34;glyf&#34; in self.ttfont and &#34;.notdef&#34; not in self.ttfont[&#34;glyf&#34;]:
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            (xMin, xMax, yMin, yMax) = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][&#34;.notdef&#34;] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (xMax - xMin, yMax - yMin)

        default_width = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0])

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap = self.ttfont.getBestCmap()
        if not self.cmap:
            raise NotImplementedError(
                &#34;Font not supported as it does not have a unicode cmap table - cf. issue #1396&#34;
            )

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)

    def __repr__(self):
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self, memo):
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        return copy

    def close(self):
        self.ttfont.close()
        self.hbfont = None

    def get_text_width(self, text, font_size_pt, text_shaping_params):
        if text_shaping_params:
            return self.shaped_text_width(text, font_size_pt, text_shaping_params)
        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)

    def shaped_text_width(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        if not hasattr(self, &#34;hbfont&#34;):
            self.hbfont = HarfBuzzFont(hb.Face(hb.Blob.from_file_path(self.ttffile)))
        self.hbfont.ptem = font_size_pt
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = text_shaping_params[&#34;features&#34;]
        if text_shaping_params[&#34;fragment_direction&#34;]:
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if text_shaping_params[&#34;script&#34;]:
            buf.script = text_shaping_params[&#34;script&#34;]
        if text_shaping_params[&#34;language&#34;]:
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text):
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            txt_mapped += chr(self.subset.pick(uni))
        return f&#39;({escape_parens(txt_mapped.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))}) Tj&#39;

    def shape_text(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list, index):
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.hbfont"><code class="name">var <span class="ident">hbfont</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L248-L556" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
    )

    def __init__(self, fpdf, font_file_path, fontkey, style):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.fontkey = fontkey

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        self.ttfont = ttLib.TTFont(
            self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True
        )

        self.scale = 1000 / self.ttfont[&#34;head&#34;].unitsPerEm

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if &#34;glyf&#34; in self.ttfont and &#34;.notdef&#34; not in self.ttfont[&#34;glyf&#34;]:
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            (xMin, xMax, yMin, yMax) = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][&#34;.notdef&#34;] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (xMax - xMin, yMax - yMin)

        default_width = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0])

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap = self.ttfont.getBestCmap()
        if not self.cmap:
            raise NotImplementedError(
                &#34;Font not supported as it does not have a unicode cmap table - cf. issue #1396&#34;
            )

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)

    def __repr__(self):
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self, memo):
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        return copy

    def close(self):
        self.ttfont.close()
        self.hbfont = None

    def get_text_width(self, text, font_size_pt, text_shaping_params):
        if text_shaping_params:
            return self.shaped_text_width(text, font_size_pt, text_shaping_params)
        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)

    def shaped_text_width(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        if not hasattr(self, &#34;hbfont&#34;):
            self.hbfont = HarfBuzzFont(hb.Face(hb.Blob.from_file_path(self.ttffile)))
        self.hbfont.ptem = font_size_pt
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = text_shaping_params[&#34;features&#34;]
        if text_shaping_params[&#34;fragment_direction&#34;]:
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if text_shaping_params[&#34;script&#34;]:
            buf.script = text_shaping_params[&#34;script&#34;]
        if text_shaping_params[&#34;language&#34;]:
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text):
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            txt_mapped += chr(self.subset.pick(uni))
        return f&#39;({escape_parens(txt_mapped.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))}) Tj&#39;

    def shape_text(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list, index):
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.i"><code class="name">var <span class="ident">i</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L248-L556" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
    )

    def __init__(self, fpdf, font_file_path, fontkey, style):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.fontkey = fontkey

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        self.ttfont = ttLib.TTFont(
            self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True
        )

        self.scale = 1000 / self.ttfont[&#34;head&#34;].unitsPerEm

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if &#34;glyf&#34; in self.ttfont and &#34;.notdef&#34; not in self.ttfont[&#34;glyf&#34;]:
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            (xMin, xMax, yMin, yMax) = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][&#34;.notdef&#34;] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (xMax - xMin, yMax - yMin)

        default_width = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0])

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap = self.ttfont.getBestCmap()
        if not self.cmap:
            raise NotImplementedError(
                &#34;Font not supported as it does not have a unicode cmap table - cf. issue #1396&#34;
            )

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)

    def __repr__(self):
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self, memo):
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        return copy

    def close(self):
        self.ttfont.close()
        self.hbfont = None

    def get_text_width(self, text, font_size_pt, text_shaping_params):
        if text_shaping_params:
            return self.shaped_text_width(text, font_size_pt, text_shaping_params)
        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)

    def shaped_text_width(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        if not hasattr(self, &#34;hbfont&#34;):
            self.hbfont = HarfBuzzFont(hb.Face(hb.Blob.from_file_path(self.ttffile)))
        self.hbfont.ptem = font_size_pt
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = text_shaping_params[&#34;features&#34;]
        if text_shaping_params[&#34;fragment_direction&#34;]:
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if text_shaping_params[&#34;script&#34;]:
            buf.script = text_shaping_params[&#34;script&#34;]
        if text_shaping_params[&#34;language&#34;]:
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text):
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            txt_mapped += chr(self.subset.pick(uni))
        return f&#39;({escape_parens(txt_mapped.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))}) Tj&#39;

    def shape_text(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list, index):
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.missing_glyphs"><code class="name">var <span class="ident">missing_glyphs</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L248-L556" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
    )

    def __init__(self, fpdf, font_file_path, fontkey, style):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.fontkey = fontkey

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        self.ttfont = ttLib.TTFont(
            self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True
        )

        self.scale = 1000 / self.ttfont[&#34;head&#34;].unitsPerEm

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if &#34;glyf&#34; in self.ttfont and &#34;.notdef&#34; not in self.ttfont[&#34;glyf&#34;]:
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            (xMin, xMax, yMin, yMax) = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][&#34;.notdef&#34;] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (xMax - xMin, yMax - yMin)

        default_width = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0])

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap = self.ttfont.getBestCmap()
        if not self.cmap:
            raise NotImplementedError(
                &#34;Font not supported as it does not have a unicode cmap table - cf. issue #1396&#34;
            )

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)

    def __repr__(self):
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self, memo):
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        return copy

    def close(self):
        self.ttfont.close()
        self.hbfont = None

    def get_text_width(self, text, font_size_pt, text_shaping_params):
        if text_shaping_params:
            return self.shaped_text_width(text, font_size_pt, text_shaping_params)
        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)

    def shaped_text_width(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        if not hasattr(self, &#34;hbfont&#34;):
            self.hbfont = HarfBuzzFont(hb.Face(hb.Blob.from_file_path(self.ttffile)))
        self.hbfont.ptem = font_size_pt
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = text_shaping_params[&#34;features&#34;]
        if text_shaping_params[&#34;fragment_direction&#34;]:
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if text_shaping_params[&#34;script&#34;]:
            buf.script = text_shaping_params[&#34;script&#34;]
        if text_shaping_params[&#34;language&#34;]:
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text):
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            txt_mapped += chr(self.subset.pick(uni))
        return f&#39;({escape_parens(txt_mapped.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))}) Tj&#39;

    def shape_text(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list, index):
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L248-L556" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
    )

    def __init__(self, fpdf, font_file_path, fontkey, style):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.fontkey = fontkey

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        self.ttfont = ttLib.TTFont(
            self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True
        )

        self.scale = 1000 / self.ttfont[&#34;head&#34;].unitsPerEm

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if &#34;glyf&#34; in self.ttfont and &#34;.notdef&#34; not in self.ttfont[&#34;glyf&#34;]:
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            (xMin, xMax, yMin, yMax) = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][&#34;.notdef&#34;] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (xMax - xMin, yMax - yMin)

        default_width = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0])

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap = self.ttfont.getBestCmap()
        if not self.cmap:
            raise NotImplementedError(
                &#34;Font not supported as it does not have a unicode cmap table - cf. issue #1396&#34;
            )

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)

    def __repr__(self):
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self, memo):
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        return copy

    def close(self):
        self.ttfont.close()
        self.hbfont = None

    def get_text_width(self, text, font_size_pt, text_shaping_params):
        if text_shaping_params:
            return self.shaped_text_width(text, font_size_pt, text_shaping_params)
        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)

    def shaped_text_width(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        if not hasattr(self, &#34;hbfont&#34;):
            self.hbfont = HarfBuzzFont(hb.Face(hb.Blob.from_file_path(self.ttffile)))
        self.hbfont.ptem = font_size_pt
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = text_shaping_params[&#34;features&#34;]
        if text_shaping_params[&#34;fragment_direction&#34;]:
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if text_shaping_params[&#34;script&#34;]:
            buf.script = text_shaping_params[&#34;script&#34;]
        if text_shaping_params[&#34;language&#34;]:
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text):
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            txt_mapped += chr(self.subset.pick(uni))
        return f&#39;({escape_parens(txt_mapped.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))}) Tj&#39;

    def shape_text(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list, index):
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.scale"><code class="name">var <span class="ident">scale</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L248-L556" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
    )

    def __init__(self, fpdf, font_file_path, fontkey, style):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.fontkey = fontkey

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        self.ttfont = ttLib.TTFont(
            self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True
        )

        self.scale = 1000 / self.ttfont[&#34;head&#34;].unitsPerEm

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if &#34;glyf&#34; in self.ttfont and &#34;.notdef&#34; not in self.ttfont[&#34;glyf&#34;]:
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            (xMin, xMax, yMin, yMax) = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][&#34;.notdef&#34;] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (xMax - xMin, yMax - yMin)

        default_width = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0])

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap = self.ttfont.getBestCmap()
        if not self.cmap:
            raise NotImplementedError(
                &#34;Font not supported as it does not have a unicode cmap table - cf. issue #1396&#34;
            )

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)

    def __repr__(self):
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self, memo):
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        return copy

    def close(self):
        self.ttfont.close()
        self.hbfont = None

    def get_text_width(self, text, font_size_pt, text_shaping_params):
        if text_shaping_params:
            return self.shaped_text_width(text, font_size_pt, text_shaping_params)
        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)

    def shaped_text_width(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        if not hasattr(self, &#34;hbfont&#34;):
            self.hbfont = HarfBuzzFont(hb.Face(hb.Blob.from_file_path(self.ttffile)))
        self.hbfont.ptem = font_size_pt
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = text_shaping_params[&#34;features&#34;]
        if text_shaping_params[&#34;fragment_direction&#34;]:
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if text_shaping_params[&#34;script&#34;]:
            buf.script = text_shaping_params[&#34;script&#34;]
        if text_shaping_params[&#34;language&#34;]:
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text):
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            txt_mapped += chr(self.subset.pick(uni))
        return f&#39;({escape_parens(txt_mapped.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))}) Tj&#39;

    def shape_text(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list, index):
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.sp"><code class="name">var <span class="ident">sp</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L248-L556" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
    )

    def __init__(self, fpdf, font_file_path, fontkey, style):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.fontkey = fontkey

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        self.ttfont = ttLib.TTFont(
            self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True
        )

        self.scale = 1000 / self.ttfont[&#34;head&#34;].unitsPerEm

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if &#34;glyf&#34; in self.ttfont and &#34;.notdef&#34; not in self.ttfont[&#34;glyf&#34;]:
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            (xMin, xMax, yMin, yMax) = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][&#34;.notdef&#34;] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (xMax - xMin, yMax - yMin)

        default_width = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0])

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap = self.ttfont.getBestCmap()
        if not self.cmap:
            raise NotImplementedError(
                &#34;Font not supported as it does not have a unicode cmap table - cf. issue #1396&#34;
            )

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)

    def __repr__(self):
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self, memo):
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        return copy

    def close(self):
        self.ttfont.close()
        self.hbfont = None

    def get_text_width(self, text, font_size_pt, text_shaping_params):
        if text_shaping_params:
            return self.shaped_text_width(text, font_size_pt, text_shaping_params)
        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)

    def shaped_text_width(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        if not hasattr(self, &#34;hbfont&#34;):
            self.hbfont = HarfBuzzFont(hb.Face(hb.Blob.from_file_path(self.ttffile)))
        self.hbfont.ptem = font_size_pt
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = text_shaping_params[&#34;features&#34;]
        if text_shaping_params[&#34;fragment_direction&#34;]:
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if text_shaping_params[&#34;script&#34;]:
            buf.script = text_shaping_params[&#34;script&#34;]
        if text_shaping_params[&#34;language&#34;]:
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text):
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            txt_mapped += chr(self.subset.pick(uni))
        return f&#39;({escape_parens(txt_mapped.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))}) Tj&#39;

    def shape_text(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list, index):
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.ss"><code class="name">var <span class="ident">ss</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L248-L556" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
    )

    def __init__(self, fpdf, font_file_path, fontkey, style):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.fontkey = fontkey

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        self.ttfont = ttLib.TTFont(
            self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True
        )

        self.scale = 1000 / self.ttfont[&#34;head&#34;].unitsPerEm

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if &#34;glyf&#34; in self.ttfont and &#34;.notdef&#34; not in self.ttfont[&#34;glyf&#34;]:
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            (xMin, xMax, yMin, yMax) = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][&#34;.notdef&#34;] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (xMax - xMin, yMax - yMin)

        default_width = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0])

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap = self.ttfont.getBestCmap()
        if not self.cmap:
            raise NotImplementedError(
                &#34;Font not supported as it does not have a unicode cmap table - cf. issue #1396&#34;
            )

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)

    def __repr__(self):
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self, memo):
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        return copy

    def close(self):
        self.ttfont.close()
        self.hbfont = None

    def get_text_width(self, text, font_size_pt, text_shaping_params):
        if text_shaping_params:
            return self.shaped_text_width(text, font_size_pt, text_shaping_params)
        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)

    def shaped_text_width(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        if not hasattr(self, &#34;hbfont&#34;):
            self.hbfont = HarfBuzzFont(hb.Face(hb.Blob.from_file_path(self.ttffile)))
        self.hbfont.ptem = font_size_pt
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = text_shaping_params[&#34;features&#34;]
        if text_shaping_params[&#34;fragment_direction&#34;]:
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if text_shaping_params[&#34;script&#34;]:
            buf.script = text_shaping_params[&#34;script&#34;]
        if text_shaping_params[&#34;language&#34;]:
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text):
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            txt_mapped += chr(self.subset.pick(uni))
        return f&#39;({escape_parens(txt_mapped.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))}) Tj&#39;

    def shape_text(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list, index):
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.subset"><code class="name">var <span class="ident">subset</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L248-L556" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
    )

    def __init__(self, fpdf, font_file_path, fontkey, style):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.fontkey = fontkey

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        self.ttfont = ttLib.TTFont(
            self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True
        )

        self.scale = 1000 / self.ttfont[&#34;head&#34;].unitsPerEm

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if &#34;glyf&#34; in self.ttfont and &#34;.notdef&#34; not in self.ttfont[&#34;glyf&#34;]:
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            (xMin, xMax, yMin, yMax) = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][&#34;.notdef&#34;] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (xMax - xMin, yMax - yMin)

        default_width = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0])

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap = self.ttfont.getBestCmap()
        if not self.cmap:
            raise NotImplementedError(
                &#34;Font not supported as it does not have a unicode cmap table - cf. issue #1396&#34;
            )

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)

    def __repr__(self):
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self, memo):
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        return copy

    def close(self):
        self.ttfont.close()
        self.hbfont = None

    def get_text_width(self, text, font_size_pt, text_shaping_params):
        if text_shaping_params:
            return self.shaped_text_width(text, font_size_pt, text_shaping_params)
        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)

    def shaped_text_width(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        if not hasattr(self, &#34;hbfont&#34;):
            self.hbfont = HarfBuzzFont(hb.Face(hb.Blob.from_file_path(self.ttffile)))
        self.hbfont.ptem = font_size_pt
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = text_shaping_params[&#34;features&#34;]
        if text_shaping_params[&#34;fragment_direction&#34;]:
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if text_shaping_params[&#34;script&#34;]:
            buf.script = text_shaping_params[&#34;script&#34;]
        if text_shaping_params[&#34;language&#34;]:
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text):
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            txt_mapped += chr(self.subset.pick(uni))
        return f&#39;({escape_parens(txt_mapped.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))}) Tj&#39;

    def shape_text(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list, index):
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.ttffile"><code class="name">var <span class="ident">ttffile</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L248-L556" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
    )

    def __init__(self, fpdf, font_file_path, fontkey, style):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.fontkey = fontkey

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        self.ttfont = ttLib.TTFont(
            self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True
        )

        self.scale = 1000 / self.ttfont[&#34;head&#34;].unitsPerEm

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if &#34;glyf&#34; in self.ttfont and &#34;.notdef&#34; not in self.ttfont[&#34;glyf&#34;]:
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            (xMin, xMax, yMin, yMax) = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][&#34;.notdef&#34;] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (xMax - xMin, yMax - yMin)

        default_width = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0])

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap = self.ttfont.getBestCmap()
        if not self.cmap:
            raise NotImplementedError(
                &#34;Font not supported as it does not have a unicode cmap table - cf. issue #1396&#34;
            )

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)

    def __repr__(self):
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self, memo):
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        return copy

    def close(self):
        self.ttfont.close()
        self.hbfont = None

    def get_text_width(self, text, font_size_pt, text_shaping_params):
        if text_shaping_params:
            return self.shaped_text_width(text, font_size_pt, text_shaping_params)
        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)

    def shaped_text_width(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        if not hasattr(self, &#34;hbfont&#34;):
            self.hbfont = HarfBuzzFont(hb.Face(hb.Blob.from_file_path(self.ttffile)))
        self.hbfont.ptem = font_size_pt
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = text_shaping_params[&#34;features&#34;]
        if text_shaping_params[&#34;fragment_direction&#34;]:
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if text_shaping_params[&#34;script&#34;]:
            buf.script = text_shaping_params[&#34;script&#34;]
        if text_shaping_params[&#34;language&#34;]:
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text):
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            txt_mapped += chr(self.subset.pick(uni))
        return f&#39;({escape_parens(txt_mapped.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))}) Tj&#39;

    def shape_text(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list, index):
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.ttfont"><code class="name">var <span class="ident">ttfont</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L248-L556" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
    )

    def __init__(self, fpdf, font_file_path, fontkey, style):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.fontkey = fontkey

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        self.ttfont = ttLib.TTFont(
            self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True
        )

        self.scale = 1000 / self.ttfont[&#34;head&#34;].unitsPerEm

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if &#34;glyf&#34; in self.ttfont and &#34;.notdef&#34; not in self.ttfont[&#34;glyf&#34;]:
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            (xMin, xMax, yMin, yMax) = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][&#34;.notdef&#34;] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (xMax - xMin, yMax - yMin)

        default_width = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0])

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap = self.ttfont.getBestCmap()
        if not self.cmap:
            raise NotImplementedError(
                &#34;Font not supported as it does not have a unicode cmap table - cf. issue #1396&#34;
            )

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)

    def __repr__(self):
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self, memo):
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        return copy

    def close(self):
        self.ttfont.close()
        self.hbfont = None

    def get_text_width(self, text, font_size_pt, text_shaping_params):
        if text_shaping_params:
            return self.shaped_text_width(text, font_size_pt, text_shaping_params)
        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)

    def shaped_text_width(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        if not hasattr(self, &#34;hbfont&#34;):
            self.hbfont = HarfBuzzFont(hb.Face(hb.Blob.from_file_path(self.ttffile)))
        self.hbfont.ptem = font_size_pt
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = text_shaping_params[&#34;features&#34;]
        if text_shaping_params[&#34;fragment_direction&#34;]:
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if text_shaping_params[&#34;script&#34;]:
            buf.script = text_shaping_params[&#34;script&#34;]
        if text_shaping_params[&#34;language&#34;]:
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text):
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            txt_mapped += chr(self.subset.pick(uni))
        return f&#39;({escape_parens(txt_mapped.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))}) Tj&#39;

    def shape_text(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list, index):
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L248-L556" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
    )

    def __init__(self, fpdf, font_file_path, fontkey, style):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.fontkey = fontkey

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        self.ttfont = ttLib.TTFont(
            self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True
        )

        self.scale = 1000 / self.ttfont[&#34;head&#34;].unitsPerEm

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if &#34;glyf&#34; in self.ttfont and &#34;.notdef&#34; not in self.ttfont[&#34;glyf&#34;]:
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            (xMin, xMax, yMin, yMax) = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][&#34;.notdef&#34;] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (xMax - xMin, yMax - yMin)

        default_width = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0])

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap = self.ttfont.getBestCmap()
        if not self.cmap:
            raise NotImplementedError(
                &#34;Font not supported as it does not have a unicode cmap table - cf. issue #1396&#34;
            )

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)

    def __repr__(self):
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self, memo):
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        return copy

    def close(self):
        self.ttfont.close()
        self.hbfont = None

    def get_text_width(self, text, font_size_pt, text_shaping_params):
        if text_shaping_params:
            return self.shaped_text_width(text, font_size_pt, text_shaping_params)
        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)

    def shaped_text_width(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        if not hasattr(self, &#34;hbfont&#34;):
            self.hbfont = HarfBuzzFont(hb.Face(hb.Blob.from_file_path(self.ttffile)))
        self.hbfont.ptem = font_size_pt
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = text_shaping_params[&#34;features&#34;]
        if text_shaping_params[&#34;fragment_direction&#34;]:
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if text_shaping_params[&#34;script&#34;]:
            buf.script = text_shaping_params[&#34;script&#34;]
        if text_shaping_params[&#34;language&#34;]:
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text):
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            txt_mapped += chr(self.subset.pick(uni))
        return f&#39;({escape_parens(txt_mapped.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))}) Tj&#39;

    def shape_text(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list, index):
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.up"><code class="name">var <span class="ident">up</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L248-L556" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
    )

    def __init__(self, fpdf, font_file_path, fontkey, style):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.fontkey = fontkey

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        self.ttfont = ttLib.TTFont(
            self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True
        )

        self.scale = 1000 / self.ttfont[&#34;head&#34;].unitsPerEm

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if &#34;glyf&#34; in self.ttfont and &#34;.notdef&#34; not in self.ttfont[&#34;glyf&#34;]:
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            (xMin, xMax, yMin, yMax) = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][&#34;.notdef&#34;] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (xMax - xMin, yMax - yMin)

        default_width = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0])

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap = self.ttfont.getBestCmap()
        if not self.cmap:
            raise NotImplementedError(
                &#34;Font not supported as it does not have a unicode cmap table - cf. issue #1396&#34;
            )

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)

    def __repr__(self):
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self, memo):
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        return copy

    def close(self):
        self.ttfont.close()
        self.hbfont = None

    def get_text_width(self, text, font_size_pt, text_shaping_params):
        if text_shaping_params:
            return self.shaped_text_width(text, font_size_pt, text_shaping_params)
        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)

    def shaped_text_width(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        if not hasattr(self, &#34;hbfont&#34;):
            self.hbfont = HarfBuzzFont(hb.Face(hb.Blob.from_file_path(self.ttffile)))
        self.hbfont.ptem = font_size_pt
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = text_shaping_params[&#34;features&#34;]
        if text_shaping_params[&#34;fragment_direction&#34;]:
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if text_shaping_params[&#34;script&#34;]:
            buf.script = text_shaping_params[&#34;script&#34;]
        if text_shaping_params[&#34;language&#34;]:
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text):
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            txt_mapped += chr(self.subset.pick(uni))
        return f&#39;({escape_parens(txt_mapped.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))}) Tj&#39;

    def shape_text(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list, index):
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.ut"><code class="name">var <span class="ident">ut</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L248-L556" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
    )

    def __init__(self, fpdf, font_file_path, fontkey, style):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.fontkey = fontkey

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        self.ttfont = ttLib.TTFont(
            self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True
        )

        self.scale = 1000 / self.ttfont[&#34;head&#34;].unitsPerEm

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if &#34;glyf&#34; in self.ttfont and &#34;.notdef&#34; not in self.ttfont[&#34;glyf&#34;]:
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            (xMin, xMax, yMin, yMax) = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][&#34;.notdef&#34;] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (xMax - xMin, yMax - yMin)

        default_width = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0])

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap = self.ttfont.getBestCmap()
        if not self.cmap:
            raise NotImplementedError(
                &#34;Font not supported as it does not have a unicode cmap table - cf. issue #1396&#34;
            )

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)

    def __repr__(self):
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self, memo):
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        return copy

    def close(self):
        self.ttfont.close()
        self.hbfont = None

    def get_text_width(self, text, font_size_pt, text_shaping_params):
        if text_shaping_params:
            return self.shaped_text_width(text, font_size_pt, text_shaping_params)
        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)

    def shaped_text_width(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        if not hasattr(self, &#34;hbfont&#34;):
            self.hbfont = HarfBuzzFont(hb.Face(hb.Blob.from_file_path(self.ttffile)))
        self.hbfont.ptem = font_size_pt
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = text_shaping_params[&#34;features&#34;]
        if text_shaping_params[&#34;fragment_direction&#34;]:
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if text_shaping_params[&#34;script&#34;]:
            buf.script = text_shaping_params[&#34;script&#34;]
        if text_shaping_params[&#34;language&#34;]:
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text):
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            txt_mapped += chr(self.subset.pick(uni))
        return f&#39;({escape_parens(txt_mapped.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))}) Tj&#39;

    def shape_text(self, text, font_size_pt, text_shaping_params):
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list, index):
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.fonts.TTFFont.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L427-L429" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def close(self):
    self.ttfont.close()
    self.hbfont = None</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.encode_text"><code class="name flex">
<span>def <span class="ident">encode_text</span></span>(<span>self, text)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L480-L487" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def encode_text(self, text):
    txt_mapped = &#34;&#34;
    for char in text:
        uni = ord(char)
        # Instead of adding the actual character to the stream its code is
        # mapped to a position in the font&#39;s subset
        txt_mapped += chr(self.subset.pick(uni))
    return f&#39;({escape_parens(txt_mapped.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))}) Tj&#39;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.get_text_width"><code class="name flex">
<span>def <span class="ident">get_text_width</span></span>(<span>self, text, font_size_pt, text_shaping_params)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L431-L434" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def get_text_width(self, text, font_size_pt, text_shaping_params):
    if text_shaping_params:
        return self.shaped_text_width(text, font_size_pt, text_shaping_params)
    return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.perform_harfbuzz_shaping"><code class="name flex">
<span>def <span class="ident">perform_harfbuzz_shaping</span></span>(<span>self, text, font_size_pt, text_shaping_params)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L459-L478" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def perform_harfbuzz_shaping(self, text, font_size_pt, text_shaping_params):
    &#34;&#34;&#34;
    This method invokes Harfbuzz to perform text shaping of the input string
    &#34;&#34;&#34;
    if not hasattr(self, &#34;hbfont&#34;):
        self.hbfont = HarfBuzzFont(hb.Face(hb.Blob.from_file_path(self.ttffile)))
    self.hbfont.ptem = font_size_pt
    buf = hb.Buffer()
    buf.cluster_level = 1
    buf.add_str(&#34;&#34;.join(text))
    buf.guess_segment_properties()
    features = text_shaping_params[&#34;features&#34;]
    if text_shaping_params[&#34;fragment_direction&#34;]:
        buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
    if text_shaping_params[&#34;script&#34;]:
        buf.script = text_shaping_params[&#34;script&#34;]
    if text_shaping_params[&#34;language&#34;]:
        buf.language = text_shaping_params[&#34;language&#34;]
    hb.shape(self.hbfont, buf, features)
    return buf.glyph_infos, buf.glyph_positions</code></pre>
</details>
<div class="desc"><p>This method invokes Harfbuzz to perform text shaping of the input string</p></div>
</dd>
<dt id="fpdf.fonts.TTFFont.shape_text"><code class="name flex">
<span>def <span class="ident">shape_text</span></span>(<span>self, text, font_size_pt, text_shaping_params)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L489-L556" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def shape_text(self, text, font_size_pt, text_shaping_params):
    &#34;&#34;&#34;
    This method will invoke harfbuzz for text shaping, include the mapping code
    of the glyphs on the subset and map input characters to the cluster codes
    &#34;&#34;&#34;
    if len(text) == 0:
        return []
    glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
        text, font_size_pt, text_shaping_params
    )
    text_info = []

    # Find cluster gaps
    # Ex: text = &#34;ABCD&#34;
    # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
    # (ligature or substitution) - the glyph should have both unicodes and it should be translated
    # properly on the CID to GID mapping
    #
    def get_cluster_from_text_index(cluster_list, index):
        pos = bisect_left(cluster_list, index)
        if pos == 0:
            return cluster_list[0]
        if pos == len(cluster_list) or cluster_list[pos] != index:
            return cluster_list[pos - 1]
        return cluster_list[pos]

    cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
    cluster_mapping = {}
    for i in range(len(text)):
        cl = get_cluster_from_text_index(cluster_list, i)
        if cl in cluster_mapping:
            cluster_mapping[cl].append(i)
        else:
            cluster_mapping[cl] = [i]

    for cluster_seq, gi in enumerate(glyph_infos):
        unicode = []
        if gi.cluster in cluster_mapping:
            unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
            cluster_mapping.pop(gi.cluster)

        gname = self.ttfont.getGlyphName(gi.codepoint)
        gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
        glyph = self.subset.get_glyph(
            glyph=gi.codepoint,
            unicode=tuple(unicode),
            glyph_name=gname,
            glyph_width=gwidth,
        )
        force_positioning = False
        if (
            gwidth != glyph_positions[cluster_seq].x_advance
            or glyph_positions[cluster_seq].x_offset != 0
            or glyph_positions[cluster_seq].y_offset != 0
            or glyph_positions[cluster_seq].y_advance != 0
        ):
            force_positioning = True
        text_info.append(
            {
                &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                &#34;force_positioning&#34;: force_positioning,
            }
        )
    return text_info</code></pre>
</details>
<div class="desc"><p>This method will invoke harfbuzz for text shaping, include the mapping code
of the glyphs on the subset and map input characters to the cluster codes</p></div>
</dd>
<dt id="fpdf.fonts.TTFFont.shaped_text_width"><code class="name flex">
<span>def <span class="ident">shaped_text_width</span></span>(<span>self, text, font_size_pt, text_shaping_params)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L436-L455" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def shaped_text_width(self, text, font_size_pt, text_shaping_params):
    &#34;&#34;&#34;
    When texts are shaped, the length of a string is not always the sum of all individual character widths
    This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
    and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
    &#34;&#34;&#34;
    _, glyph_positions = self.perform_harfbuzz_shaping(
        text, font_size_pt, text_shaping_params
    )

    # If there is nothing to render (harfbuzz returns None), we return 0 text width
    if glyph_positions is None:
        return (0, 0)

    text_width = 0
    for pos in glyph_positions:
        text_width += (
            round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
        )
    return (len(glyph_positions), text_width)</code></pre>
</details>
<div class="desc"><p>When texts are shaped, the length of a string is not always the sum of all individual character widths
This method will invoke harfbuzz to perform the text shaping and return the sum of "x_advance"
and "x_offset" for each glyph. This method works for "left to right" or "right to left" texts.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.fonts.TextStyle"><code class="flex name class">
<span>class <span class="ident">TextStyle</span></span>
<span>(</span><span>font_family:Â strÂ |Â NoneÂ =Â None,<br>font_style:Â strÂ |Â NoneÂ =Â None,<br>font_size_pt:Â intÂ |Â NoneÂ =Â None,<br>color:Â intÂ |Â tupleÂ =Â None,<br>fill_color:Â intÂ |Â tupleÂ =Â None,<br>underline:Â boolÂ =Â False,<br>t_margin:Â intÂ |Â NoneÂ =Â None,<br>l_margin:Â intÂ |Â <a title="fpdf.enums.Align" href="enums.html#fpdf.enums.Align">Align</a>Â |Â strÂ |Â NoneÂ =Â None,<br>b_margin:Â intÂ |Â NoneÂ =Â None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L122-L190" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TextStyle(FontFace):
    &#34;&#34;&#34;
    Subclass of `FontFace` that allows to specify vertical &amp; horizontal spacing
    &#34;&#34;&#34;

    def __init__(
        self,
        font_family: Optional[str] = None,  # None means &#34;no override&#34;
        #                                     Whereas &#34;&#34; means &#34;no emphasis&#34;
        font_style: Optional[str] = None,
        font_size_pt: Optional[int] = None,
        color: Union[int, tuple] = None,  # grey scale or (red, green, blue),
        fill_color: Union[int, tuple] = None,  # grey scale or (red, green, blue),
        underline: bool = False,
        t_margin: Optional[int] = None,
        l_margin: Union[Optional[int], Optional[Align], Optional[str]] = None,
        b_margin: Optional[int] = None,
    ):
        super().__init__(
            font_family,
            ((font_style or &#34;&#34;) + &#34;U&#34;) if underline else font_style,
            font_size_pt,
            color,
            fill_color,
        )
        self.t_margin = t_margin or 0

        if isinstance(l_margin, (int, float)):
            self.l_margin = l_margin
        elif l_margin:
            self.l_margin = Align.coerce(l_margin)
        else:
            self.l_margin = 0

        self.b_margin = b_margin or 0

    def __repr__(self):
        return (
            super().__repr__()[:-1]
            + f&#34;, t_margin={self.t_margin}, l_margin={self.l_margin}, b_margin={self.b_margin})&#34;
        )

    # override parent method
    def replace(
        self,
        /,
        font_family=None,
        emphasis=None,
        font_size_pt=None,
        color=None,
        fill_color=None,
        t_margin=None,
        l_margin=None,
        b_margin=None,
    ):
        &#34;&#34;&#34;
        Create a new TextStyle instance, with new values for some attributes.
        Same as `dataclasses.replace()`
        &#34;&#34;&#34;
        return TextStyle(
            font_family=font_family or self.family,
            font_style=self.emphasis if emphasis is None else emphasis.style,
            font_size_pt=font_size_pt or self.size_pt,
            color=color or self.color,
            fill_color=fill_color or self.fill_color,
            t_margin=self.t_margin if t_margin is None else t_margin,
            l_margin=self.l_margin if l_margin is None else l_margin,
            b_margin=self.b_margin if b_margin is None else b_margin,
        )</code></pre>
</details>
<div class="desc"><p>Subclass of <code><a title="fpdf.fonts.FontFace" href="#fpdf.fonts.FontFace">FontFace</a></code> that allows to specify vertical &amp; horizontal spacing</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fpdf.fonts.FontFace" href="#fpdf.fonts.FontFace">FontFace</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>fpdf.fonts.TitleStyle</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fpdf.fonts.TextStyle.combine"><code class="name flex">
<span>def <span class="ident">combine</span></span>(<span>default_style, override_style)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.fonts.FontFace" href="#fpdf.fonts.FontFace">FontFace</a></code>.<code><a title="fpdf.fonts.FontFace.combine" href="#fpdf.fonts.FontFace.combine">combine</a></code>
</p>
<div class="desc inherited"><p>Create a combined FontFace with all the supplied features of the two styles. When both
the default and override styles provide a feature, prefer the â€¦</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.fonts.TextStyle.replace"><code class="name flex">
<span>def <span class="ident">replace</span></span>(<span>self,<br>/,<br>font_family=None,<br>emphasis=None,<br>font_size_pt=None,<br>color=None,<br>fill_color=None,<br>t_margin=None,<br>l_margin=None,<br>b_margin=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L165-L190" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def replace(
    self,
    /,
    font_family=None,
    emphasis=None,
    font_size_pt=None,
    color=None,
    fill_color=None,
    t_margin=None,
    l_margin=None,
    b_margin=None,
):
    &#34;&#34;&#34;
    Create a new TextStyle instance, with new values for some attributes.
    Same as `dataclasses.replace()`
    &#34;&#34;&#34;
    return TextStyle(
        font_family=font_family or self.family,
        font_style=self.emphasis if emphasis is None else emphasis.style,
        font_size_pt=font_size_pt or self.size_pt,
        color=color or self.color,
        fill_color=fill_color or self.fill_color,
        t_margin=self.t_margin if t_margin is None else t_margin,
        l_margin=self.l_margin if l_margin is None else l_margin,
        b_margin=self.b_margin if b_margin is None else b_margin,
    )</code></pre>
</details>
<div class="desc"><p>Create a new TextStyle instance, with new values for some attributes.
Same as <code>dataclasses.replace()</code></p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fpdf" href="index.html">fpdf</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fpdf.fonts.CoreFont" href="#fpdf.fonts.CoreFont">CoreFont</a></code></h4>
<ul class="two-column">
<li><code><a title="fpdf.fonts.CoreFont.cw" href="#fpdf.fonts.CoreFont.cw">cw</a></code></li>
<li><code><a title="fpdf.fonts.CoreFont.emphasis" href="#fpdf.fonts.CoreFont.emphasis">emphasis</a></code></li>
<li><code><a title="fpdf.fonts.CoreFont.encode_text" href="#fpdf.fonts.CoreFont.encode_text">encode_text</a></code></li>
<li><code><a title="fpdf.fonts.CoreFont.fontkey" href="#fpdf.fonts.CoreFont.fontkey">fontkey</a></code></li>
<li><code><a title="fpdf.fonts.CoreFont.get_text_width" href="#fpdf.fonts.CoreFont.get_text_width">get_text_width</a></code></li>
<li><code><a title="fpdf.fonts.CoreFont.i" href="#fpdf.fonts.CoreFont.i">i</a></code></li>
<li><code><a title="fpdf.fonts.CoreFont.name" href="#fpdf.fonts.CoreFont.name">name</a></code></li>
<li><code><a title="fpdf.fonts.CoreFont.sp" href="#fpdf.fonts.CoreFont.sp">sp</a></code></li>
<li><code><a title="fpdf.fonts.CoreFont.ss" href="#fpdf.fonts.CoreFont.ss">ss</a></code></li>
<li><code><a title="fpdf.fonts.CoreFont.type" href="#fpdf.fonts.CoreFont.type">type</a></code></li>
<li><code><a title="fpdf.fonts.CoreFont.up" href="#fpdf.fonts.CoreFont.up">up</a></code></li>
<li><code><a title="fpdf.fonts.CoreFont.ut" href="#fpdf.fonts.CoreFont.ut">ut</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.fonts.FontFace" href="#fpdf.fonts.FontFace">FontFace</a></code></h4>
<ul class="two-column">
<li><code><a title="fpdf.fonts.FontFace.color" href="#fpdf.fonts.FontFace.color">color</a></code></li>
<li><code><a title="fpdf.fonts.FontFace.combine" href="#fpdf.fonts.FontFace.combine">combine</a></code></li>
<li><code><a title="fpdf.fonts.FontFace.emphasis" href="#fpdf.fonts.FontFace.emphasis">emphasis</a></code></li>
<li><code><a title="fpdf.fonts.FontFace.family" href="#fpdf.fonts.FontFace.family">family</a></code></li>
<li><code><a title="fpdf.fonts.FontFace.fill_color" href="#fpdf.fonts.FontFace.fill_color">fill_color</a></code></li>
<li><code><a title="fpdf.fonts.FontFace.replace" href="#fpdf.fonts.FontFace.replace">replace</a></code></li>
<li><code><a title="fpdf.fonts.FontFace.size_pt" href="#fpdf.fonts.FontFace.size_pt">size_pt</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.fonts.Glyph" href="#fpdf.fonts.Glyph">Glyph</a></code></h4>
<ul class="">
<li><code><a title="fpdf.fonts.Glyph.glyph_id" href="#fpdf.fonts.Glyph.glyph_id">glyph_id</a></code></li>
<li><code><a title="fpdf.fonts.Glyph.glyph_name" href="#fpdf.fonts.Glyph.glyph_name">glyph_name</a></code></li>
<li><code><a title="fpdf.fonts.Glyph.glyph_width" href="#fpdf.fonts.Glyph.glyph_width">glyph_width</a></code></li>
<li><code><a title="fpdf.fonts.Glyph.unicode" href="#fpdf.fonts.Glyph.unicode">unicode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.fonts.PDFFontDescriptor" href="#fpdf.fonts.PDFFontDescriptor">PDFFontDescriptor</a></code></h4>
<ul class="">
<li><code><a title="fpdf.fonts.PDFFontDescriptor.content_stream" href="syntax.html#fpdf.fonts.PDFFontDescriptor.content_stream">content_stream</a></code></li>
<li><code><a title="fpdf.fonts.PDFFontDescriptor.serialize" href="syntax.html#fpdf.fonts.PDFFontDescriptor.serialize">serialize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.fonts.SubsetMap" href="#fpdf.fonts.SubsetMap">SubsetMap</a></code></h4>
<ul class="">
<li><code><a title="fpdf.fonts.SubsetMap.get_all_glyph_names" href="#fpdf.fonts.SubsetMap.get_all_glyph_names">get_all_glyph_names</a></code></li>
<li><code><a title="fpdf.fonts.SubsetMap.get_glyph" href="#fpdf.fonts.SubsetMap.get_glyph">get_glyph</a></code></li>
<li><code><a title="fpdf.fonts.SubsetMap.items" href="#fpdf.fonts.SubsetMap.items">items</a></code></li>
<li><code><a title="fpdf.fonts.SubsetMap.pick" href="#fpdf.fonts.SubsetMap.pick">pick</a></code></li>
<li><code><a title="fpdf.fonts.SubsetMap.pick_glyph" href="#fpdf.fonts.SubsetMap.pick_glyph">pick_glyph</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.fonts.TTFFont" href="#fpdf.fonts.TTFFont">TTFFont</a></code></h4>
<ul class="">
<li><code><a title="fpdf.fonts.TTFFont.close" href="#fpdf.fonts.TTFFont.close">close</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.cmap" href="#fpdf.fonts.TTFFont.cmap">cmap</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.cw" href="#fpdf.fonts.TTFFont.cw">cw</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.desc" href="#fpdf.fonts.TTFFont.desc">desc</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.emphasis" href="#fpdf.fonts.TTFFont.emphasis">emphasis</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.encode_text" href="#fpdf.fonts.TTFFont.encode_text">encode_text</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.fontkey" href="#fpdf.fonts.TTFFont.fontkey">fontkey</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.get_text_width" href="#fpdf.fonts.TTFFont.get_text_width">get_text_width</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.glyph_ids" href="#fpdf.fonts.TTFFont.glyph_ids">glyph_ids</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.hbfont" href="#fpdf.fonts.TTFFont.hbfont">hbfont</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.i" href="#fpdf.fonts.TTFFont.i">i</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.missing_glyphs" href="#fpdf.fonts.TTFFont.missing_glyphs">missing_glyphs</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.name" href="#fpdf.fonts.TTFFont.name">name</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.perform_harfbuzz_shaping" href="#fpdf.fonts.TTFFont.perform_harfbuzz_shaping">perform_harfbuzz_shaping</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.scale" href="#fpdf.fonts.TTFFont.scale">scale</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.shape_text" href="#fpdf.fonts.TTFFont.shape_text">shape_text</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.shaped_text_width" href="#fpdf.fonts.TTFFont.shaped_text_width">shaped_text_width</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.sp" href="#fpdf.fonts.TTFFont.sp">sp</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.ss" href="#fpdf.fonts.TTFFont.ss">ss</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.subset" href="#fpdf.fonts.TTFFont.subset">subset</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.ttffile" href="#fpdf.fonts.TTFFont.ttffile">ttffile</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.ttfont" href="#fpdf.fonts.TTFFont.ttfont">ttfont</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.type" href="#fpdf.fonts.TTFFont.type">type</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.up" href="#fpdf.fonts.TTFFont.up">up</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.ut" href="#fpdf.fonts.TTFFont.ut">ut</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.fonts.TextStyle" href="#fpdf.fonts.TextStyle">TextStyle</a></code></h4>
<ul class="">
<li><code><a title="fpdf.fonts.TextStyle.combine" href="#fpdf.fonts.TextStyle.combine">combine</a></code></li>
<li><code><a title="fpdf.fonts.TextStyle.replace" href="#fpdf.fonts.TextStyle.replace">replace</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
