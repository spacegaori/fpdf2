<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>fpdf.table API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fpdf.table</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="fpdf.table.draw_box_borders"><code class="name flex">
<span>def <span class="ident">draw_box_borders</span></span>(<span>pdf, x1, y1, x2, y2, border, fill_color=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/table.py#L872-L919" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def draw_box_borders(pdf, x1, y1, x2, y2, border, fill_color=None):
    &#34;&#34;&#34;Draws a box using the provided style - private helper used by table for drawing the cell and table borders.
    Difference between this and rect() is that border can be defined as &#34;L,R,T,B&#34; to draw only some of the four borders;
    compatible with get_border(i,k)

    See Also: rect()&#34;&#34;&#34;
    if fill_color:
        prev_fill_color = pdf.fill_color
        pdf.set_fill_color(fill_color)

    sl = []

    k = pdf.k

    # y top to bottom instead of bottom to top
    y1 = pdf.h - y1
    y2 = pdf.h - y2

    # scale
    x1 *= k
    x2 *= k
    y2 *= k
    y1 *= k

    if isinstance(border, str) and set(border).issuperset(&#34;LTRB&#34;):
        border = 1

    if fill_color:
        op = &#34;B&#34; if border == 1 else &#34;f&#34;
        sl.append(f&#34;{x1:.2f} {y2:.2f} &#34; f&#34;{x2 - x1:.2f} {y1 - y2:.2f} re {op}&#34;)
    elif border == 1:
        sl.append(f&#34;{x1:.2f} {y2:.2f} &#34; f&#34;{x2 - x1:.2f} {y1 - y2:.2f} re S&#34;)

    if isinstance(border, str):
        if &#34;L&#34; in border:
            sl.append(f&#34;{x1:.2f} {y2:.2f} m &#34; f&#34;{x1:.2f} {y1:.2f} l S&#34;)
        if &#34;B&#34; in border:
            sl.append(f&#34;{x1:.2f} {y2:.2f} m &#34; f&#34;{x2:.2f} {y2:.2f} l S&#34;)
        if &#34;R&#34; in border:
            sl.append(f&#34;{x2:.2f} {y2:.2f} m &#34; f&#34;{x2:.2f} {y1:.2f} l S&#34;)
        if &#34;T&#34; in border:
            sl.append(f&#34;{x1:.2f} {y1:.2f} m &#34; f&#34;{x2:.2f} {y1:.2f} l S&#34;)

    s = &#34; &#34;.join(sl)
    pdf._out(s)  # pylint: disable=protected-access

    if fill_color:
        pdf.set_fill_color(prev_fill_color)</code></pre>
</details>
<div class="desc"><p>Draws a box using the provided style - private helper used by table for drawing the cell and table borders.
Difference between this and rect() is that border can be defined as "L,R,T,B" to draw only some of the four borders;
compatible with get_border(i,k)</p>
<p>See Also: rect()</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fpdf.table.Cell"><code class="flex name class">
<span>class <span class="ident">Cell</span></span>
<span>(</span><span>text: str,<br>align: str | <a title="fpdf.enums.Align" href="enums.html#fpdf.enums.Align">Align</a> | None,<br>v_align: str | <a title="fpdf.enums.VAlign" href="enums.html#fpdf.enums.VAlign">VAlign</a> | None,<br>style: <a title="fpdf.fonts.FontFace" href="fonts.html#fpdf.fonts.FontFace">FontFace</a> | None,<br>img: str | None,<br>img_fill_width: bool,<br>colspan: int,<br>rowspan: int,<br>padding: int | tuple | None,<br>link: str | int | None,<br>border: <a title="fpdf.enums.CellBordersLayout" href="enums.html#fpdf.enums.CellBordersLayout">CellBordersLayout</a> | None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/table.py#L818-L848" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@dataclass(frozen=True)
class Cell:
    &#34;Internal representation of a table cell&#34;

    __slots__ = (  # RAM usage optimization
        &#34;text&#34;,
        &#34;align&#34;,
        &#34;v_align&#34;,
        &#34;style&#34;,
        &#34;img&#34;,
        &#34;img_fill_width&#34;,
        &#34;colspan&#34;,
        &#34;rowspan&#34;,
        &#34;padding&#34;,
        &#34;link&#34;,
        &#34;border&#34;,
    )
    text: str
    align: Optional[Union[str, Align]]
    v_align: Optional[Union[str, VAlign]]
    style: Optional[FontFace]
    img: Optional[str]
    img_fill_width: bool
    colspan: int
    rowspan: int
    padding: Optional[Union[int, tuple, type(None)]]
    link: Optional[Union[str, int]]
    border: Optional[CellBordersLayout]

    def write(self, text, align=None):
        raise NotImplementedError(&#34;Not implemented yet&#34;)</code></pre>
</details>
<div class="desc"><p>Internal representation of a table cell</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.table.Cell.align"><code class="name">var <span class="ident">align</span> : str | <a title="fpdf.enums.Align" href="enums.html#fpdf.enums.Align">Align</a> | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/table.py#L818-L848" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@dataclass(frozen=True)
class Cell:
    &#34;Internal representation of a table cell&#34;

    __slots__ = (  # RAM usage optimization
        &#34;text&#34;,
        &#34;align&#34;,
        &#34;v_align&#34;,
        &#34;style&#34;,
        &#34;img&#34;,
        &#34;img_fill_width&#34;,
        &#34;colspan&#34;,
        &#34;rowspan&#34;,
        &#34;padding&#34;,
        &#34;link&#34;,
        &#34;border&#34;,
    )
    text: str
    align: Optional[Union[str, Align]]
    v_align: Optional[Union[str, VAlign]]
    style: Optional[FontFace]
    img: Optional[str]
    img_fill_width: bool
    colspan: int
    rowspan: int
    padding: Optional[Union[int, tuple, type(None)]]
    link: Optional[Union[str, int]]
    border: Optional[CellBordersLayout]

    def write(self, text, align=None):
        raise NotImplementedError(&#34;Not implemented yet&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.table.Cell.border"><code class="name">var <span class="ident">border</span> : <a title="fpdf.enums.CellBordersLayout" href="enums.html#fpdf.enums.CellBordersLayout">CellBordersLayout</a> | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/table.py#L818-L848" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@dataclass(frozen=True)
class Cell:
    &#34;Internal representation of a table cell&#34;

    __slots__ = (  # RAM usage optimization
        &#34;text&#34;,
        &#34;align&#34;,
        &#34;v_align&#34;,
        &#34;style&#34;,
        &#34;img&#34;,
        &#34;img_fill_width&#34;,
        &#34;colspan&#34;,
        &#34;rowspan&#34;,
        &#34;padding&#34;,
        &#34;link&#34;,
        &#34;border&#34;,
    )
    text: str
    align: Optional[Union[str, Align]]
    v_align: Optional[Union[str, VAlign]]
    style: Optional[FontFace]
    img: Optional[str]
    img_fill_width: bool
    colspan: int
    rowspan: int
    padding: Optional[Union[int, tuple, type(None)]]
    link: Optional[Union[str, int]]
    border: Optional[CellBordersLayout]

    def write(self, text, align=None):
        raise NotImplementedError(&#34;Not implemented yet&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.table.Cell.colspan"><code class="name">var <span class="ident">colspan</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/table.py#L818-L848" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@dataclass(frozen=True)
class Cell:
    &#34;Internal representation of a table cell&#34;

    __slots__ = (  # RAM usage optimization
        &#34;text&#34;,
        &#34;align&#34;,
        &#34;v_align&#34;,
        &#34;style&#34;,
        &#34;img&#34;,
        &#34;img_fill_width&#34;,
        &#34;colspan&#34;,
        &#34;rowspan&#34;,
        &#34;padding&#34;,
        &#34;link&#34;,
        &#34;border&#34;,
    )
    text: str
    align: Optional[Union[str, Align]]
    v_align: Optional[Union[str, VAlign]]
    style: Optional[FontFace]
    img: Optional[str]
    img_fill_width: bool
    colspan: int
    rowspan: int
    padding: Optional[Union[int, tuple, type(None)]]
    link: Optional[Union[str, int]]
    border: Optional[CellBordersLayout]

    def write(self, text, align=None):
        raise NotImplementedError(&#34;Not implemented yet&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.table.Cell.img"><code class="name">var <span class="ident">img</span> : str | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/table.py#L818-L848" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@dataclass(frozen=True)
class Cell:
    &#34;Internal representation of a table cell&#34;

    __slots__ = (  # RAM usage optimization
        &#34;text&#34;,
        &#34;align&#34;,
        &#34;v_align&#34;,
        &#34;style&#34;,
        &#34;img&#34;,
        &#34;img_fill_width&#34;,
        &#34;colspan&#34;,
        &#34;rowspan&#34;,
        &#34;padding&#34;,
        &#34;link&#34;,
        &#34;border&#34;,
    )
    text: str
    align: Optional[Union[str, Align]]
    v_align: Optional[Union[str, VAlign]]
    style: Optional[FontFace]
    img: Optional[str]
    img_fill_width: bool
    colspan: int
    rowspan: int
    padding: Optional[Union[int, tuple, type(None)]]
    link: Optional[Union[str, int]]
    border: Optional[CellBordersLayout]

    def write(self, text, align=None):
        raise NotImplementedError(&#34;Not implemented yet&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.table.Cell.img_fill_width"><code class="name">var <span class="ident">img_fill_width</span> : bool</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/table.py#L818-L848" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@dataclass(frozen=True)
class Cell:
    &#34;Internal representation of a table cell&#34;

    __slots__ = (  # RAM usage optimization
        &#34;text&#34;,
        &#34;align&#34;,
        &#34;v_align&#34;,
        &#34;style&#34;,
        &#34;img&#34;,
        &#34;img_fill_width&#34;,
        &#34;colspan&#34;,
        &#34;rowspan&#34;,
        &#34;padding&#34;,
        &#34;link&#34;,
        &#34;border&#34;,
    )
    text: str
    align: Optional[Union[str, Align]]
    v_align: Optional[Union[str, VAlign]]
    style: Optional[FontFace]
    img: Optional[str]
    img_fill_width: bool
    colspan: int
    rowspan: int
    padding: Optional[Union[int, tuple, type(None)]]
    link: Optional[Union[str, int]]
    border: Optional[CellBordersLayout]

    def write(self, text, align=None):
        raise NotImplementedError(&#34;Not implemented yet&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.table.Cell.link"><code class="name">var <span class="ident">link</span> : str | int | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/table.py#L818-L848" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@dataclass(frozen=True)
class Cell:
    &#34;Internal representation of a table cell&#34;

    __slots__ = (  # RAM usage optimization
        &#34;text&#34;,
        &#34;align&#34;,
        &#34;v_align&#34;,
        &#34;style&#34;,
        &#34;img&#34;,
        &#34;img_fill_width&#34;,
        &#34;colspan&#34;,
        &#34;rowspan&#34;,
        &#34;padding&#34;,
        &#34;link&#34;,
        &#34;border&#34;,
    )
    text: str
    align: Optional[Union[str, Align]]
    v_align: Optional[Union[str, VAlign]]
    style: Optional[FontFace]
    img: Optional[str]
    img_fill_width: bool
    colspan: int
    rowspan: int
    padding: Optional[Union[int, tuple, type(None)]]
    link: Optional[Union[str, int]]
    border: Optional[CellBordersLayout]

    def write(self, text, align=None):
        raise NotImplementedError(&#34;Not implemented yet&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.table.Cell.padding"><code class="name">var <span class="ident">padding</span> : int | tuple | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/table.py#L818-L848" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@dataclass(frozen=True)
class Cell:
    &#34;Internal representation of a table cell&#34;

    __slots__ = (  # RAM usage optimization
        &#34;text&#34;,
        &#34;align&#34;,
        &#34;v_align&#34;,
        &#34;style&#34;,
        &#34;img&#34;,
        &#34;img_fill_width&#34;,
        &#34;colspan&#34;,
        &#34;rowspan&#34;,
        &#34;padding&#34;,
        &#34;link&#34;,
        &#34;border&#34;,
    )
    text: str
    align: Optional[Union[str, Align]]
    v_align: Optional[Union[str, VAlign]]
    style: Optional[FontFace]
    img: Optional[str]
    img_fill_width: bool
    colspan: int
    rowspan: int
    padding: Optional[Union[int, tuple, type(None)]]
    link: Optional[Union[str, int]]
    border: Optional[CellBordersLayout]

    def write(self, text, align=None):
        raise NotImplementedError(&#34;Not implemented yet&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.table.Cell.rowspan"><code class="name">var <span class="ident">rowspan</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/table.py#L818-L848" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@dataclass(frozen=True)
class Cell:
    &#34;Internal representation of a table cell&#34;

    __slots__ = (  # RAM usage optimization
        &#34;text&#34;,
        &#34;align&#34;,
        &#34;v_align&#34;,
        &#34;style&#34;,
        &#34;img&#34;,
        &#34;img_fill_width&#34;,
        &#34;colspan&#34;,
        &#34;rowspan&#34;,
        &#34;padding&#34;,
        &#34;link&#34;,
        &#34;border&#34;,
    )
    text: str
    align: Optional[Union[str, Align]]
    v_align: Optional[Union[str, VAlign]]
    style: Optional[FontFace]
    img: Optional[str]
    img_fill_width: bool
    colspan: int
    rowspan: int
    padding: Optional[Union[int, tuple, type(None)]]
    link: Optional[Union[str, int]]
    border: Optional[CellBordersLayout]

    def write(self, text, align=None):
        raise NotImplementedError(&#34;Not implemented yet&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.table.Cell.style"><code class="name">var <span class="ident">style</span> : <a title="fpdf.fonts.FontFace" href="fonts.html#fpdf.fonts.FontFace">FontFace</a> | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/table.py#L818-L848" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@dataclass(frozen=True)
class Cell:
    &#34;Internal representation of a table cell&#34;

    __slots__ = (  # RAM usage optimization
        &#34;text&#34;,
        &#34;align&#34;,
        &#34;v_align&#34;,
        &#34;style&#34;,
        &#34;img&#34;,
        &#34;img_fill_width&#34;,
        &#34;colspan&#34;,
        &#34;rowspan&#34;,
        &#34;padding&#34;,
        &#34;link&#34;,
        &#34;border&#34;,
    )
    text: str
    align: Optional[Union[str, Align]]
    v_align: Optional[Union[str, VAlign]]
    style: Optional[FontFace]
    img: Optional[str]
    img_fill_width: bool
    colspan: int
    rowspan: int
    padding: Optional[Union[int, tuple, type(None)]]
    link: Optional[Union[str, int]]
    border: Optional[CellBordersLayout]

    def write(self, text, align=None):
        raise NotImplementedError(&#34;Not implemented yet&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.table.Cell.text"><code class="name">var <span class="ident">text</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/table.py#L818-L848" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@dataclass(frozen=True)
class Cell:
    &#34;Internal representation of a table cell&#34;

    __slots__ = (  # RAM usage optimization
        &#34;text&#34;,
        &#34;align&#34;,
        &#34;v_align&#34;,
        &#34;style&#34;,
        &#34;img&#34;,
        &#34;img_fill_width&#34;,
        &#34;colspan&#34;,
        &#34;rowspan&#34;,
        &#34;padding&#34;,
        &#34;link&#34;,
        &#34;border&#34;,
    )
    text: str
    align: Optional[Union[str, Align]]
    v_align: Optional[Union[str, VAlign]]
    style: Optional[FontFace]
    img: Optional[str]
    img_fill_width: bool
    colspan: int
    rowspan: int
    padding: Optional[Union[int, tuple, type(None)]]
    link: Optional[Union[str, int]]
    border: Optional[CellBordersLayout]

    def write(self, text, align=None):
        raise NotImplementedError(&#34;Not implemented yet&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.table.Cell.v_align"><code class="name">var <span class="ident">v_align</span> : str | <a title="fpdf.enums.VAlign" href="enums.html#fpdf.enums.VAlign">VAlign</a> | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/table.py#L818-L848" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@dataclass(frozen=True)
class Cell:
    &#34;Internal representation of a table cell&#34;

    __slots__ = (  # RAM usage optimization
        &#34;text&#34;,
        &#34;align&#34;,
        &#34;v_align&#34;,
        &#34;style&#34;,
        &#34;img&#34;,
        &#34;img_fill_width&#34;,
        &#34;colspan&#34;,
        &#34;rowspan&#34;,
        &#34;padding&#34;,
        &#34;link&#34;,
        &#34;border&#34;,
    )
    text: str
    align: Optional[Union[str, Align]]
    v_align: Optional[Union[str, VAlign]]
    style: Optional[FontFace]
    img: Optional[str]
    img_fill_width: bool
    colspan: int
    rowspan: int
    padding: Optional[Union[int, tuple, type(None)]]
    link: Optional[Union[str, int]]
    border: Optional[CellBordersLayout]

    def write(self, text, align=None):
        raise NotImplementedError(&#34;Not implemented yet&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.table.Cell.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, text, align=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/table.py#L847-L848" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def write(self, text, align=None):
    raise NotImplementedError(&#34;Not implemented yet&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fpdf.table.Row"><code class="flex name class">
<span>class <span class="ident">Row</span></span>
<span>(</span><span>table, style=None, v_align=None, min_height=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/table.py#L692-L815" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class Row:
    &#34;Object that `Table.row()` yields, used to build a row in a table&#34;

    def __init__(self, table, style=None, v_align=None, min_height=None):
        self._table = table
        self.cells = []
        self.style = style
        self.v_align = VAlign.coerce(v_align) if v_align else v_align
        self.min_height = min_height

    @property
    def cols_count(self):
        return sum(getattr(cell, &#34;colspan&#34;, cell is not None) for cell in self.cells)

    @property
    def max_rowspan(self):
        spans = {cell.rowspan for cell in self.cells if cell is not None}
        return max(spans) if len(spans) else 1

    def convert_spans(self, active_rowspans):
        # convert colspans
        prev_col = 0
        cells = []
        for i, cell in enumerate(self.cells):
            if cell is None:
                continue
            if cell == TableSpan.COL:
                prev_cell = cells[prev_col]
                if not isinstance(prev_cell, Cell):
                    raise FPDFException(
                        &#34;Invalid location for TableSpan.COL placeholder entry&#34;
                    )
                cells[prev_col] = replace(prev_cell, colspan=prev_cell.colspan + 1)
                cells.append(None)  # processed
            else:
                cells.append(cell)
                prev_col = i
                if isinstance(cell, Cell) and cell.colspan &gt; 1:  # expand any colspans
                    cells.extend([None] * (cell.colspan - 1))
        # now we can correctly interpret active_rowspans
        remaining_rowspans = {}
        for k, v in active_rowspans.items():
            cells.insert(k, None)
            if v &gt; 1:
                remaining_rowspans[k] = v - 1
        # accumulate any rowspans
        reverse_rowspans = []
        for i, cell in enumerate(cells):
            if isinstance(cell, Cell) and cell.rowspan &gt; 1:
                for k in range(i, i + cell.colspan):
                    remaining_rowspans[k] = cell.rowspan - 1
            elif cell == TableSpan.ROW:
                reverse_rowspans.append(i)
                cells[i] = None  # processed
        self.cells = cells
        return remaining_rowspans, reverse_rowspans

    def cell(
        self,
        text=&#34;&#34;,
        align=None,
        v_align=None,
        style=None,
        img=None,
        img_fill_width=False,
        colspan=1,
        rowspan=1,
        padding=None,
        link=None,
        border=CellBordersLayout.INHERIT,
    ):
        &#34;&#34;&#34;
        Adds a cell to the row.

        Args:
            text (str): string content, can contain several lines.
                In that case, the row height will grow proportionally.
            align (str, fpdf.enums.Align): optional text alignment.
            v_align (str, fpdf.enums.VAlign): optional vertical text alignment.
            style (fpdf.fonts.FontFace): optional text style.
            img: optional. Either a string representing a file path to an image,
                an URL to an image, an io.BytesIO, or a instance of `PIL.Image.Image`.
            img_fill_width (bool): optional, defaults to False. Indicates to render the image
                using the full width of the current table column.
            colspan (int): optional number of columns this cell should span.
            rowspan (int): optional number of rows this cell should span.
            padding (tuple): optional padding (left, top, right, bottom) for the cell.
            link (str, int): optional link, either an URL or an integer returned by `FPDF.add_link`, defining an internal link to a page
            border (fpdf.enums.CellBordersLayout): optional cell borders, defaults to `CellBordersLayout.INHERIT`

        &#34;&#34;&#34;
        if text and img:
            raise NotImplementedError(
                &#34;fpdf2 currently does not support inserting text with an image in the same table cell.&#34;
                &#34; Pull Requests are welcome to implement this 😊&#34;
            )

        if isinstance(text, TableSpan):
            # Special placeholder object, converted to colspan/rowspan during processing
            self.cells.append(text)
            return text

        if not style:
            # pylint: disable=protected-access
            # We capture the current font settings:
            font_face = self._table._fpdf.font_face()
            if font_face not in (self.style, self._table._initial_style):
                style = font_face

        cell = Cell(
            text,
            align,
            VAlign.coerce(v_align) if v_align else v_align,
            style,
            img,
            img_fill_width,
            colspan,
            rowspan,
            padding,
            link,
            CellBordersLayout.coerce(border),
        )
        self.cells.append(cell)
        return cell</code></pre>
</details>
<div class="desc"><p>Object that <code><a title="fpdf.table.Table.row" href="#fpdf.table.Table.row">Table.row()</a></code> yields, used to build a row in a table</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.table.Row.cols_count"><code class="name">prop <span class="ident">cols_count</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/table.py#L702-L704" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def cols_count(self):
    return sum(getattr(cell, &#34;colspan&#34;, cell is not None) for cell in self.cells)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.table.Row.max_rowspan"><code class="name">prop <span class="ident">max_rowspan</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/table.py#L706-L709" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def max_rowspan(self):
    spans = {cell.rowspan for cell in self.cells if cell is not None}
    return max(spans) if len(spans) else 1</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.table.Row.cell"><code class="name flex">
<span>def <span class="ident">cell</span></span>(<span>self,<br>text='',<br>align=None,<br>v_align=None,<br>style=None,<br>img=None,<br>img_fill_width=False,<br>colspan=1,<br>rowspan=1,<br>padding=None,<br>link=None,<br>border=NONE)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/table.py#L749-L815" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def cell(
    self,
    text=&#34;&#34;,
    align=None,
    v_align=None,
    style=None,
    img=None,
    img_fill_width=False,
    colspan=1,
    rowspan=1,
    padding=None,
    link=None,
    border=CellBordersLayout.INHERIT,
):
    &#34;&#34;&#34;
    Adds a cell to the row.

    Args:
        text (str): string content, can contain several lines.
            In that case, the row height will grow proportionally.
        align (str, fpdf.enums.Align): optional text alignment.
        v_align (str, fpdf.enums.VAlign): optional vertical text alignment.
        style (fpdf.fonts.FontFace): optional text style.
        img: optional. Either a string representing a file path to an image,
            an URL to an image, an io.BytesIO, or a instance of `PIL.Image.Image`.
        img_fill_width (bool): optional, defaults to False. Indicates to render the image
            using the full width of the current table column.
        colspan (int): optional number of columns this cell should span.
        rowspan (int): optional number of rows this cell should span.
        padding (tuple): optional padding (left, top, right, bottom) for the cell.
        link (str, int): optional link, either an URL or an integer returned by `FPDF.add_link`, defining an internal link to a page
        border (fpdf.enums.CellBordersLayout): optional cell borders, defaults to `CellBordersLayout.INHERIT`

    &#34;&#34;&#34;
    if text and img:
        raise NotImplementedError(
            &#34;fpdf2 currently does not support inserting text with an image in the same table cell.&#34;
            &#34; Pull Requests are welcome to implement this 😊&#34;
        )

    if isinstance(text, TableSpan):
        # Special placeholder object, converted to colspan/rowspan during processing
        self.cells.append(text)
        return text

    if not style:
        # pylint: disable=protected-access
        # We capture the current font settings:
        font_face = self._table._fpdf.font_face()
        if font_face not in (self.style, self._table._initial_style):
            style = font_face

    cell = Cell(
        text,
        align,
        VAlign.coerce(v_align) if v_align else v_align,
        style,
        img,
        img_fill_width,
        colspan,
        rowspan,
        padding,
        link,
        CellBordersLayout.coerce(border),
    )
    self.cells.append(cell)
    return cell</code></pre>
</details>
<div class="desc"><p>Adds a cell to the row.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>string content, can contain several lines.
In that case, the row height will grow proportionally.</dd>
<dt><strong><code>align</code></strong> :&ensp;<code>str, <a title="fpdf.enums.Align" href="enums.html#fpdf.enums.Align">Align</a></code></dt>
<dd>optional text alignment.</dd>
<dt><strong><code>v_align</code></strong> :&ensp;<code>str, <a title="fpdf.enums.VAlign" href="enums.html#fpdf.enums.VAlign">VAlign</a></code></dt>
<dd>optional vertical text alignment.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.fonts.FontFace" href="fonts.html#fpdf.fonts.FontFace">FontFace</a></code></dt>
<dd>optional text style.</dd>
<dt><strong><code>img</code></strong></dt>
<dd>optional. Either a string representing a file path to an image,
an URL to an image, an io.BytesIO, or a instance of <code>PIL.Image.Image</code>.</dd>
<dt><strong><code>img_fill_width</code></strong> :&ensp;<code>bool</code></dt>
<dd>optional, defaults to False. Indicates to render the image
using the full width of the current table column.</dd>
<dt><strong><code>colspan</code></strong> :&ensp;<code>int</code></dt>
<dd>optional number of columns this cell should span.</dd>
<dt><strong><code>rowspan</code></strong> :&ensp;<code>int</code></dt>
<dd>optional number of rows this cell should span.</dd>
<dt><strong><code>padding</code></strong> :&ensp;<code>tuple</code></dt>
<dd>optional padding (left, top, right, bottom) for the cell.</dd>
<dt><strong><code>link</code></strong> :&ensp;<code>str, int</code></dt>
<dd>optional link, either an URL or an integer returned by <code>FPDF.add_link</code>, defining an internal link to a page</dd>
<dt><strong><code>border</code></strong> :&ensp;<code><a title="fpdf.enums.CellBordersLayout" href="enums.html#fpdf.enums.CellBordersLayout">CellBordersLayout</a></code></dt>
<dd>optional cell borders, defaults to <code>CellBordersLayout.INHERIT</code></dd>
</dl></div>
</dd>
<dt id="fpdf.table.Row.convert_spans"><code class="name flex">
<span>def <span class="ident">convert_spans</span></span>(<span>self, active_rowspans)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/table.py#L711-L747" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def convert_spans(self, active_rowspans):
    # convert colspans
    prev_col = 0
    cells = []
    for i, cell in enumerate(self.cells):
        if cell is None:
            continue
        if cell == TableSpan.COL:
            prev_cell = cells[prev_col]
            if not isinstance(prev_cell, Cell):
                raise FPDFException(
                    &#34;Invalid location for TableSpan.COL placeholder entry&#34;
                )
            cells[prev_col] = replace(prev_cell, colspan=prev_cell.colspan + 1)
            cells.append(None)  # processed
        else:
            cells.append(cell)
            prev_col = i
            if isinstance(cell, Cell) and cell.colspan &gt; 1:  # expand any colspans
                cells.extend([None] * (cell.colspan - 1))
    # now we can correctly interpret active_rowspans
    remaining_rowspans = {}
    for k, v in active_rowspans.items():
        cells.insert(k, None)
        if v &gt; 1:
            remaining_rowspans[k] = v - 1
    # accumulate any rowspans
    reverse_rowspans = []
    for i, cell in enumerate(cells):
        if isinstance(cell, Cell) and cell.rowspan &gt; 1:
            for k in range(i, i + cell.colspan):
                remaining_rowspans[k] = cell.rowspan - 1
        elif cell == TableSpan.ROW:
            reverse_rowspans.append(i)
            cells[i] = None  # processed
    self.cells = cells
    return remaining_rowspans, reverse_rowspans</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fpdf.table.RowLayoutInfo"><code class="flex name class">
<span>class <span class="ident">RowLayoutInfo</span></span>
<span>(</span><span>height: float,<br>pagebreak_height: float,<br>rendered_heights: dict,<br>merged_heights: list)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/table.py#L851-L858" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@dataclass(frozen=True)
class RowLayoutInfo:
    height: float
    # accumulated rowspans to take in account when considering page breaks:
    pagebreak_height: float
    # heights of every cell in the row:
    rendered_heights: dict
    merged_heights: list</code></pre>
</details>
<div class="desc"><p>RowLayoutInfo(height: float, pagebreak_height: float, rendered_heights: dict, merged_heights: list)</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.table.RowLayoutInfo.height"><code class="name">var <span class="ident">height</span> : float</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="fpdf.table.RowLayoutInfo.merged_heights"><code class="name">var <span class="ident">merged_heights</span> : list</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="fpdf.table.RowLayoutInfo.pagebreak_height"><code class="name">var <span class="ident">pagebreak_height</span> : float</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="fpdf.table.RowLayoutInfo.rendered_heights"><code class="name">var <span class="ident">rendered_heights</span> : dict</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.table.RowSpanLayoutInfo"><code class="flex name class">
<span>class <span class="ident">RowSpanLayoutInfo</span></span>
<span>(</span><span>column: int, start: int, length: int, contents_height: float)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/table.py#L861-L869" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@dataclass(frozen=True)
class RowSpanLayoutInfo:
    column: int
    start: int
    length: int
    contents_height: float

    def row_range(self):
        return range(self.start, self.start + self.length)</code></pre>
</details>
<div class="desc"><p>RowSpanLayoutInfo(column: int, start: int, length: int, contents_height: float)</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.table.RowSpanLayoutInfo.column"><code class="name">var <span class="ident">column</span> : int</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="fpdf.table.RowSpanLayoutInfo.contents_height"><code class="name">var <span class="ident">contents_height</span> : float</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="fpdf.table.RowSpanLayoutInfo.length"><code class="name">var <span class="ident">length</span> : int</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="fpdf.table.RowSpanLayoutInfo.start"><code class="name">var <span class="ident">start</span> : int</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.table.RowSpanLayoutInfo.row_range"><code class="name flex">
<span>def <span class="ident">row_range</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/table.py#L868-L869" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def row_range(self):
    return range(self.start, self.start + self.length)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fpdf.table.Table"><code class="flex name class">
<span>class <span class="ident">Table</span></span>
<span>(</span><span>fpdf,<br>rows=(),<br>*,<br>align='CENTER',<br>v_align='MIDDLE',<br>borders_layout=&lt;fpdf.enums.TableBordersLayoutAll object&gt;,<br>cell_fill_color=None,<br>cell_fill_mode=TableCellFillMode.NONE,<br>col_widths=None,<br>first_row_as_headings=True,<br>gutter_height=0,<br>gutter_width=0,<br>headings_style=FontFace(family=None, emphasis=&lt;TextEmphasis.B: 1&gt;, size_pt=None, color=None, fill_color=None),<br>line_height=None,<br>markdown=False,<br>text_align='JUSTIFY',<br>width=None,<br>wrapmode=WrapMode.WORD,<br>padding=None,<br>outer_border_width=None,<br>num_heading_rows=1,<br>repeat_headings=1,<br>min_row_height=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/table.py#L23-L689" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class Table:
    &#34;&#34;&#34;
    Object that `fpdf.FPDF.table()` yields, used to build a table in the document.
    Detailed usage documentation: https://py-pdf.github.io/fpdf2/Tables.html
    &#34;&#34;&#34;

    def __init__(
        self,
        fpdf,
        rows=(),
        *,
        align=&#34;CENTER&#34;,
        v_align=&#34;MIDDLE&#34;,
        borders_layout=TableBordersLayout.ALL,
        cell_fill_color=None,
        cell_fill_mode=TableCellFillMode.NONE,
        col_widths=None,
        first_row_as_headings=True,
        gutter_height=0,
        gutter_width=0,
        headings_style=DEFAULT_HEADINGS_STYLE,
        line_height=None,
        markdown=False,
        text_align=&#34;JUSTIFY&#34;,
        width=None,
        wrapmode=WrapMode.WORD,
        padding=None,
        outer_border_width=None,
        num_heading_rows=1,
        repeat_headings=1,
        min_row_height=None,
    ):
        &#34;&#34;&#34;
        Args:
            fpdf (fpdf.FPDF): FPDF current instance
            rows: optional. Sequence of rows (iterable) of str to initiate the table cells with text content
            align (str, fpdf.enums.Align): optional, default to CENTER. Sets the table horizontal position relative to the page,
                when it&#39;s not using the full page width
            borders_layout (str, fpdf.enums.TableBordersLayout): optional, default to ALL. Control what cell borders are drawn
            cell_fill_color (float, tuple, fpdf.drawing.DeviceGray, fpdf.drawing.DeviceRGB): optional.
                Defines the cells background color
            cell_fill_mode (str, fpdf.enums.TableCellFillMode): optional. Defines which cells are filled with color in the background
            col_widths (float, tuple): optional. Sets column width. Can be a single number or a sequence of numbers.
                 When `col_widths` is a single number, it is interpreted as a fixed column width in document units.
                 When `col_widths` is provided as an array, the values are considered to be fractions of the full effective page width,
                 meaning that `col_widths=(1, 1, 2)` is strictly equivalent to `col_widths=(25, 25, 50)`.
            first_row_as_headings (bool): optional, default to True. If False, the first row of the table
                is not styled differently from the others
            gutter_height (float): optional vertical space between rows
            gutter_width (float): optional horizontal space between columns
            headings_style (fpdf.fonts.FontFace): optional, default to bold.
                Defines the visual style of the top headings row: size, color, emphasis...
            line_height (number): optional. Defines how much vertical space a line of text will occupy
            markdown (bool): optional, default to False. Enable markdown interpretation of cells textual content
            text_align (str, fpdf.enums.Align, tuple): optional, default to JUSTIFY. Control text alignment inside cells.
            v_align (str, fpdf.enums.VAlign): optional, default to CENTER. Control vertical alignment of cells content
            width (number): optional. Sets the table width
            wrapmode (fpdf.enums.WrapMode): &#34;WORD&#34; for word based line wrapping (default),
                &#34;CHAR&#34; for character based line wrapping.
            padding (number, tuple, Padding): optional. Sets the cell padding. Can be a single number or a sequence of numbers, default:0
                If padding for left and right ends up being non-zero then c_margin is ignored.
            outer_border_width (number): optional. Sets the width of the outer borders of the table.
                Only relevant when borders_layout is ALL or NO_HORIZONTAL_LINES. Otherwise, the border widths are controlled by FPDF.set_line_width()
            num_heading_rows (number): optional. Sets the number of heading rows, default value is 1. If this value is not 1,
                first_row_as_headings needs to be True if num_heading_rows&gt;1 and False if num_heading_rows=0. For backwards compatibility,
                first_row_as_headings is used in case num_heading_rows is 1.
            repeat_headings (fpdf.enums.TableHeadingsDisplay): optional, indicates whether to print table headings on every page, default to 1.
        &#34;&#34;&#34;
        self._fpdf = fpdf
        self._table_align = Align.coerce(align)
        self._v_align = VAlign.coerce(v_align)
        self._borders_layout = TableBordersLayout.coerce(borders_layout)
        self._outer_border_width = outer_border_width
        self._cell_fill_color = cell_fill_color
        self._cell_fill_mode = TableCellFillMode.coerce(cell_fill_mode)
        self._col_widths = col_widths
        self._first_row_as_headings = first_row_as_headings
        self._gutter_height = gutter_height
        self._gutter_width = gutter_width
        self._headings_style = headings_style
        self._line_height = 2 * fpdf.font_size if line_height is None else line_height
        self._markdown = markdown
        self._text_align = text_align
        self._width = width
        self._wrapmode = wrapmode
        self._num_heading_rows = num_heading_rows
        self._repeat_headings = TableHeadingsDisplay.coerce(repeat_headings)
        self._min_row_height = min_row_height
        self._initial_style = None
        self.rows = []

        if padding is None:
            self._padding = Padding.new(0)
        else:
            self._padding = Padding.new(padding)

        # check table_border_layout and outer_border_width
        if self._borders_layout not in (
            TableBordersLayout.ALL,
            TableBordersLayout.NO_HORIZONTAL_LINES,
        ):
            if outer_border_width is not None:
                raise ValueError(
                    &#34;outer_border_width is only allowed when borders_layout is ALL or NO_HORIZONTAL_LINES&#34;
                )
            self._outer_border_width = 0
        # _outer_border_margin : vertical spacing around table
        if self._outer_border_width:
            self._outer_border_margin = (
                (gutter_width + outer_border_width / 2),
                (gutter_height + outer_border_width / 2),
            )
        else:
            self._outer_border_margin = (0, 0)

        # check first_row_as_headings for non-default case num_heading_rows != 1
        if self._num_heading_rows != 1:
            if self._num_heading_rows == 0 and self._first_row_as_headings:
                raise ValueError(
                    &#34;first_row_as_headings needs to be False if num_heading_rows == 0&#34;
                )
            if self._num_heading_rows &gt; 1 and not self._first_row_as_headings:
                raise ValueError(
                    &#34;first_row_as_headings needs to be True if num_heading_rows &gt; 0&#34;
                )
        # for backwards compatibility, we respect the value of first_row_as_headings when num_heading_rows==1
        else:
            if not self._first_row_as_headings:
                self._num_heading_rows = 0

        for row in rows:
            self.row(row)

    def row(self, cells=(), style=None, v_align=None, min_height=None):
        &#34;Adds a row to the table. Returns a `Row` object.&#34;
        if self._initial_style is None:
            self._initial_style = self._fpdf.font_face()
        row = Row(self, style=style, v_align=v_align, min_height=min_height)
        self.rows.append(row)
        for cell in cells:
            if isinstance(cell, dict):
                row.cell(**cell)
            else:
                row.cell(cell)
        return row

    def render(self):
        &#34;This is an internal method called by `fpdf.FPDF.table()` once the table is finished&#34;
        # Starting with some sanity checks:
        self._cols_count = max(row.cols_count for row in self.rows) if self.rows else 0
        if self._width is None:
            if self._col_widths and isinstance(self._col_widths, Number):
                self._width = self._cols_count * self._col_widths
            else:
                self._width = self._fpdf.epw
        elif self._col_widths and isinstance(self._col_widths, Number):
            if self._cols_count * self._col_widths != self._width:
                raise ValueError(
                    f&#34;Invalid value provided width={self._width} should be a multiple of col_widths={self._col_widths}&#34;
                )
        if self._width &gt; self._fpdf.epw:
            raise ValueError(
                f&#34;Invalid value provided width={self._width}: effective page width is {self._fpdf.epw}&#34;
            )
        if self._table_align == Align.J:
            raise ValueError(
                &#34;JUSTIFY is an invalid value for FPDF.table() &#39;align&#39; parameter&#34;
            )
        if self._num_heading_rows &gt; 0:
            if not self._headings_style:
                raise ValueError(
                    &#34;headings_style must be provided to FPDF.table() if num_heading_rows&gt;1 or first_row_as_headings=True&#34;
                )
            emphasis = self._headings_style.emphasis
            if emphasis is not None:
                family = self._headings_style.family or self._fpdf.font_family
                font_key = family.lower() + emphasis.style.replace(&#34;U&#34;, &#34;&#34;)
                if font_key not in CORE_FONTS and font_key not in self._fpdf.fonts:
                    # Raising a more explicit error than the one from set_font():
                    raise FPDFException(
                        f&#34;Using font &#39;{family}&#39; with emphasis &#39;{emphasis.style}&#39;&#34;
                        &#34; in table headings require the corresponding font style&#34;
                        &#34; to be added using add_font()&#34;
                    )

        # Defining table global horizontal position:
        prev_x, prev_y, prev_l_margin = self._fpdf.x, self._fpdf.y, self._fpdf.l_margin
        if self._table_align == Align.C:
            self._fpdf.l_margin = (self._fpdf.w - self._width) / 2
            self._fpdf.x = self._fpdf.l_margin
        elif self._table_align == Align.R:
            self._fpdf.l_margin = self._fpdf.w - self._fpdf.r_margin - self._width
            self._fpdf.x = self._fpdf.l_margin
        elif self._fpdf.x != self._fpdf.l_margin:
            self._fpdf.l_margin = self._fpdf.x

        # Pre-Compute the relative x-positions of the individual columns:
        xx = self._fpdf.l_margin + self._outer_border_margin[0]
        cell_x_positions = [xx]
        if self.rows:
            for i in range(self._cols_count):
                xx += self._get_col_width(0, i)
                xx += self._gutter_width
                cell_x_positions.append(xx)

        # Process any rowspans
        rows_info = list(self._compute_rows_info())

        # actually render the cells
        repeat_headings = (
            self._repeat_headings is TableHeadingsDisplay.ON_TOP_OF_EVERY_PAGE
        )
        self._fpdf.y += self._outer_border_margin[1]
        if len(self.rows) &gt; self._num_heading_rows &gt; 0:
            # We avoid having the heading rows alone on a page - issue #1391
            # pylint: disable=protected-access
            self._fpdf._perform_page_break_if_need_be(
                sum(
                    rows_info[i].pagebreak_height
                    for i in range(self._num_heading_rows + 1)
                )
            )
        for i in range(len(self.rows)):
            pagebreak_height = rows_info[i].pagebreak_height
            # pylint: disable=protected-access
            page_break = self._fpdf._perform_page_break_if_need_be(pagebreak_height)
            if (
                page_break
                and self._fpdf.y + pagebreak_height &gt; self._fpdf.page_break_trigger
            ):
                # Restoring original position on page:
                self._fpdf.x = prev_x
                self._fpdf.y = prev_y
                self._fpdf.l_margin = prev_l_margin
                raise ValueError(
                    f&#34;The row with index {i} is too high and cannot be rendered on a single page&#34;
                )
            if page_break and repeat_headings and i &gt;= self._num_heading_rows:
                # repeat headings on top:
                self._fpdf.y += self._outer_border_margin[1]
                for row_idx in range(self._num_heading_rows):
                    self._render_table_row(
                        row_idx,
                        rows_info[row_idx],
                        cell_x_positions=cell_x_positions,
                    )
            if i &gt; 0:
                self._fpdf.y += self._gutter_height
            self._render_table_row(i, rows_info[i], cell_x_positions)

        # Restoring altered FPDF settings:
        self._fpdf.l_margin = prev_l_margin
        self._fpdf.x = self._fpdf.l_margin

    def _render_table_row(self, i, row_layout_info, cell_x_positions, **kwargs):
        row = self.rows[i]
        y = self._fpdf.y  # remember current y position, reset after each cell

        for j, cell in enumerate(row.cells):
            if cell is None:
                continue
            self._render_table_cell(
                i,
                j,
                cell,
                row_height=self._line_height,
                cell_height_info=row_layout_info,
                cell_x_positions=cell_x_positions,
                **kwargs,
            )
            self._fpdf.set_y(y)  # restore y position after each cell

        self._fpdf.ln(row_layout_info.height)

    def _render_table_cell(
        self,
        i,
        j,
        cell,
        row_height,  # height of a row of text including line spacing
        cell_height_info=None,  # full height of a cell, including padding, used to render borders and images
        cell_x_positions=None,  # x-positions of the individual columns, pre-calculated for speed. Only relevant when rendering
        **kwargs,
    ):
        # If cell_height_info is provided then we are rendering a cell
        # If cell_height_info is not provided then we are only here to figure out the height of the cell
        #
        # So this function is first called without cell_height_info to figure out the heights of all cells in a row
        # and then called again with cell_height to actually render the cells

        if cell_height_info is None:
            cell_height = None
            height_query_only = True
        elif cell.rowspan &gt; 1:
            cell_height = cell_height_info.merged_heights[cell.rowspan]
            height_query_only = False
        else:
            cell_height = cell_height_info.height
            height_query_only = False

        page_break_text = False
        page_break_image = False

        # Get style and cell content:

        row = self.rows[i]
        col_width = self._get_col_width(i, j, cell.colspan)
        img_height = 0

        text_align = cell.align or self._text_align
        if not isinstance(text_align, (Align, str)):
            text_align = text_align[j]

        style = self._initial_style
        cell_mode_fill = self._cell_fill_mode.should_fill_cell(i, j)
        if cell_mode_fill and self._cell_fill_color:
            style = style.replace(fill_color=self._cell_fill_color)
        if i &lt; self._num_heading_rows:
            style = FontFace.combine(style, self._headings_style)
        style = FontFace.combine(style, row.style)
        style = FontFace.combine(style, cell.style)

        padding = Padding.new(cell.padding) if cell.padding else self._padding

        v_align = cell.v_align
        if not v_align:
            v_align = row.v_align
        if not v_align:
            v_align = self._v_align

        # We can not rely on the actual x position of the cell. Notably in case of
        # empty cells or cells with an image only the actual x position is incorrect.
        # Instead, we calculate the x position based on the column widths of the previous columns

        # place cursor (required for images after images)

        # not rendering, cell_x_positions is not relevant (and probably not provided):
        if height_query_only:
            cell_x = 0
        else:
            cell_x = cell_x_positions[j]
        self._fpdf.set_x(cell_x)

        # render cell border and background
        # if cell_height is defined, that means that we already know the size at which the cell will be rendered
        # so we can draw the borders now
        #
        # If cell_height is None then we&#39;re still in the phase of calculating the height of the cell meaning that
        # we do not need to set fonts &amp; draw borders yet.
        if not height_query_only:
            x1 = self._fpdf.x
            y1 = self._fpdf.y
            x2 = (
                x1 + col_width
            )  # already includes gutter for cells spanning multiple columns
            y2 = y1 + cell_height

            cell_idx = row.cells.index(cell)
            (
                self._borders_layout.cell_style_getter(
                    row_idx=i,
                    col_idx=sum(1 for cell in row.cells[:cell_idx] if cell is not None),
                    col_pos=j,
                    num_heading_rows=self._num_heading_rows,
                    num_rows=len(self.rows),
                    num_col_idx=sum(1 for cell in row.cells if cell is not None),
                    num_col_pos=row.cols_count,
                )
                .override_cell_border(cell.border)
                .draw_cell_border(
                    self._fpdf,
                    x1,
                    y1,
                    x2,
                    y2,
                    fill_color=style.fill_color if style else None,
                )
            )

            # draw outer box if needed:
            if self._outer_border_width:
                _remember_linewidth = self._fpdf.line_width
                self._fpdf.set_line_width(self._outer_border_width)

                # draw the outer box separated by the gutter dimensions
                # the top and bottom borders are one continuous line
                # whereas the left and right borders are segments because of possible pagebreaks
                x1 = self._fpdf.l_margin
                x2 = x1 + self._width
                y1 = y1 - self._outer_border_margin[1]
                y2 = y2 + self._outer_border_margin[1]

                if j == 0:
                    # lhs border
                    self._fpdf.line(x1, y1, x1, y2)
                if j + cell.colspan == self._cols_count:
                    # rhs border
                    self._fpdf.line(x2, y1, x2, y2)
                    # continuous top line border
                    if i == 0:
                        self._fpdf.line(x1, y1, x2, y1)
                    # continuous bottom line border
                    if i + cell.rowspan == len(self.rows):
                        self._fpdf.line(x1, y2, x2, y2)

                self._fpdf.set_line_width(_remember_linewidth)

        if cell.img:
            x, y = self._fpdf.x, self._fpdf.y

            # if cell_height is None or width is given then call image with h=0
            # calling with h=0 means that the image will be rendered with an auto determined height
            auto_height = cell.img_fill_width or cell_height is None
            cell_border_line_width = self._fpdf.line_width

            # apply padding
            self._fpdf.x += padding.left + cell_border_line_width / 2
            self._fpdf.y += padding.top + cell_border_line_width / 2

            image = self._fpdf.image(
                cell.img,
                w=col_width - padding.left - padding.right - cell_border_line_width,
                h=(
                    0
                    if auto_height
                    else cell_height
                    - padding.top
                    - padding.bottom
                    - cell_border_line_width
                ),
                keep_aspect_ratio=True,
                link=cell.link,
            )

            img_height = (
                image.rendered_height
                + padding.top
                + padding.bottom
                + cell_border_line_width
            )

            if img_height + y &gt; self._fpdf.page_break_trigger:
                page_break_image = True

            self._fpdf.set_xy(x, y)

        # render text

        if cell.text:
            dy = 0

            if cell_height is not None:
                actual_text_height = cell_height_info.rendered_heights[j]

                if v_align == VAlign.M:
                    dy = (cell_height - actual_text_height) / 2
                elif v_align == VAlign.B:
                    dy = cell_height - actual_text_height

            self._fpdf.y += dy

            with self._fpdf.use_font_face(style):
                page_break_text, cell_height = self._fpdf.multi_cell(
                    w=col_width,
                    h=row_height,
                    text=cell.text,
                    max_line_height=self._line_height,
                    border=0,
                    align=text_align,
                    new_x=&#34;RIGHT&#34;,
                    new_y=&#34;TOP&#34;,
                    fill=False,  # fill is already done above
                    markdown=self._markdown,
                    output=MethodReturnValue.PAGE_BREAK | MethodReturnValue.HEIGHT,
                    wrapmode=self._wrapmode,
                    padding=padding,
                    link=cell.link,
                    **kwargs,
                )

            self._fpdf.y -= dy
        else:
            cell_height = 0

        do_pagebreak = page_break_text or page_break_image

        return do_pagebreak, img_height, cell_height

    def _get_col_width(self, i, j, colspan=1):
        &#34;&#34;&#34;Gets width of a column in a table, this excludes the outer gutter (outside the table) but includes the inner gutter
        between columns if the cell spans multiple columns.&#34;&#34;&#34;

        cols_count = self._cols_count
        width = (
            self._width
            - (cols_count - 1) * self._gutter_width
            - 2 * self._outer_border_margin[0]
        )
        gutter_within_cell = max((colspan - 1) * self._gutter_width, 0)

        if not self._col_widths:
            return colspan * (width / cols_count) + gutter_within_cell
        if isinstance(self._col_widths, Number):
            return colspan * self._col_widths + gutter_within_cell
        if j &gt;= len(self._col_widths):
            raise ValueError(
                f&#34;Invalid .col_widths specified: missing width for table() column {j + 1} on row {i + 1}&#34;
            )
        col_width = 0
        for k in range(j, j + colspan):
            col_ratio = self._col_widths[k] / sum(self._col_widths)
            col_width += col_ratio * width
            if k != j:
                col_width += self._gutter_width
        return col_width

    def _compute_rows_info(self):
        # First pass: Regularise the table by processing the rowspan and colspan entries
        active_rowspans = {}
        prev_row_in_col = {}
        for i, row in enumerate(self.rows):
            # Link up rowspans
            active_rowspans, prior_rowspans = row.convert_spans(active_rowspans)
            for col_idx in prior_rowspans:
                # This cell is TableSpan.ROW, so accumulate to the previous row
                prev_row = prev_row_in_col[col_idx]
                if prev_row is not None:
                    # Since Cell objects are frozen, we need to recreate them to update the rowspan
                    cell = prev_row.cells[col_idx]
                    prev_row.cells[col_idx] = replace(cell, rowspan=cell.rowspan + 1)
            for j, cell in enumerate(row.cells):
                if isinstance(cell, Cell):
                    # Keep track of the non-span cells
                    prev_row_in_col[j] = row
                    for k in range(j + 1, j + cell.colspan):
                        prev_row_in_col[k] = None
        if len(active_rowspans) != 0:
            raise FPDFException(&#34;Rowspan extends beyond end of table&#34;)

        # Second pass: Estimate the cell sizes
        rowspan_list = []
        row_min_heights = []
        row_span_max = []
        rendered_heights = []
        # pylint: disable=protected-access
        with self._fpdf._disable_writing():
            for i, row in enumerate(self.rows):
                dictated_heights = []
                img_heights = []
                rendered_heights.append({})

                for j, cell in enumerate(row.cells):
                    if cell is None:  # placeholder cell
                        continue

                    # NB: ignore page_break since we might need to assign rowspan padding
                    _, img_height, text_height = self._render_table_cell(
                        i,
                        j,
                        cell,
                        row_height=self._line_height,
                    )
                    if cell.img_fill_width:
                        dictated_height = img_height
                    else:
                        dictated_height = text_height

                    # Store the dictated heights in a dict (not list) because of span elements
                    rendered_heights[i][j] = dictated_height

                    if cell.rowspan &gt; 1:
                        # For spanned rows, use img_height if dictated_height is zero
                        rowspan_list.append(
                            RowSpanLayoutInfo(
                                j, i, cell.rowspan, dictated_height or img_height
                            )
                        )
                        # Often we want rowspans in headings, but issues arise if the span crosses outside the heading
                        is_heading = i &lt; self._num_heading_rows
                        span_outside_heading = i + cell.rowspan &gt; self._num_heading_rows
                        if is_heading and span_outside_heading:
                            raise FPDFException(
                                &#34;Heading includes rowspan beyond the number of heading rows&#34;
                            )
                    else:
                        dictated_heights.append(dictated_height)
                        img_heights.append(img_height)

                # The height of the rows is chosen as follows:
                # The &#34;dictated height&#34; is the space required for text/image, so pick the largest in the row
                # If this is zero, we will fill the space with images, so pick the largest image height
                # If this is still zero (e.g. empty/fully spanned row), use a sensible default
                min_height = 0
                if dictated_heights:
                    min_height = max(dictated_heights)
                    if min_height == 0:
                        min_height = max(img_heights)
                if min_height == 0:
                    min_height = self._line_height
                if row.min_height:
                    if min_height &lt; row.min_height:
                        min_height = row.min_height
                elif self._min_row_height:
                    if min_height &lt; self._min_row_height:
                        min_height = self._min_row_height

                row_min_heights.append(min_height)
                row_span_max.append(row.max_rowspan)

        # Sort the spans so we allocate padding to the smallest spans first
        rowspan_list = sorted(rowspan_list, key=lambda span: span.length)

        # Third pass: allocate space required for the rowspans
        row_span_padding = [0 for row in self.rows]
        for span in rowspan_list:
            # accumulate already assigned properties
            max_padding = 0
            assigned_height = self._gutter_height * (span.length - 1)
            assigned_padding = 0
            for i in span.row_range():
                max_padding = max(max_padding, row_span_padding[i])
                assigned_height += row_min_heights[i]
                assigned_padding += row_span_padding[i]

            # does additional padding need to be distributed?
            if assigned_height + assigned_padding &lt; span.contents_height:
                # when there are overlapping rowspans, can we stretch the cells to be evenly padded?
                if span.contents_height &gt; assigned_height + span.length * max_padding:
                    # stretch all cells to have the same padding, for aesthetic reasons
                    padding = (span.contents_height - assigned_height) / span.length
                    for i in span.row_range():
                        row_span_padding[i] = padding
                else:
                    # add proportional padding to the rows
                    extra = span.contents_height - assigned_height - assigned_padding
                    for i in span.row_range():
                        row_span_padding[i] += extra / span.length

        # Fourth pass: compute the final element sizes
        for i, row in enumerate(self.rows):
            row_height = row_min_heights[i] + row_span_padding[i]
            # Compute the size of merged cells
            merged_sizes = [0, row_height]
            for j in range(i + 1, i + row_span_max[i]):
                merged_sizes.append(
                    merged_sizes[-1]
                    + self._gutter_height
                    + row_min_heights[j]
                    + row_span_padding[j]
                )
            # Pagebreak should not occur within ANY rowspan, so validate ACCUMULATED rowspans
            # This gets complicated because of overlapping rowspans (see `test_table_with_rowspan_and_pgbreak()`)
            # Eventually, this should be refactored to rearrange cells to permit breaks within spans
            pagebreak_height = row_height
            pagebreak_row = i + row_span_max[i]
            j = i + 1
            while j &lt; pagebreak_row:
                # NB: this can&#39;t be a for loop because the upper limit might keep changing
                pagebreak_row = max(pagebreak_row, j + row_span_max[j])
                pagebreak_height += (
                    self._gutter_height + row_min_heights[j] + row_span_padding[j]
                )
                j += 1

            yield RowLayoutInfo(
                merged_sizes[1], pagebreak_height, rendered_heights[i], merged_sizes
            )</code></pre>
</details>
<div class="desc"><p>Object that <code>fpdf.FPDF.table()</code> yields, used to build a table in the document.
Detailed usage documentation: <a href="https://py-pdf.github.io/fpdf2/Tables.html">https://py-pdf.github.io/fpdf2/Tables.html</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fpdf</code></strong> :&ensp;<code>fpdf.FPDF</code></dt>
<dd>FPDF current instance</dd>
<dt><strong><code>rows</code></strong></dt>
<dd>optional. Sequence of rows (iterable) of str to initiate the table cells with text content</dd>
<dt><strong><code>align</code></strong> :&ensp;<code>str, <a title="fpdf.enums.Align" href="enums.html#fpdf.enums.Align">Align</a></code></dt>
<dd>optional, default to CENTER. Sets the table horizontal position relative to the page,
when it's not using the full page width</dd>
<dt><strong><code>borders_layout</code></strong> :&ensp;<code>str, <a title="fpdf.enums.TableBordersLayout" href="enums.html#fpdf.enums.TableBordersLayout">TableBordersLayout</a></code></dt>
<dd>optional, default to ALL. Control what cell borders are drawn</dd>
<dt><strong><code>cell_fill_color</code></strong> :&ensp;<code>float, tuple, <a title="fpdf.drawing.DeviceGray" href="drawing.html#fpdf.drawing.DeviceGray">DeviceGray</a>, <a title="fpdf.drawing.DeviceRGB" href="drawing.html#fpdf.drawing.DeviceRGB">DeviceRGB</a></code></dt>
<dd>optional.
Defines the cells background color</dd>
<dt><strong><code>cell_fill_mode</code></strong> :&ensp;<code>str, <a title="fpdf.enums.TableCellFillMode" href="enums.html#fpdf.enums.TableCellFillMode">TableCellFillMode</a></code></dt>
<dd>optional. Defines which cells are filled with color in the background</dd>
<dt><strong><code>col_widths</code></strong> :&ensp;<code>float, tuple</code></dt>
<dd>optional. Sets column width. Can be a single number or a sequence of numbers.
When <code>col_widths</code> is a single number, it is interpreted as a fixed column width in document units.
When <code>col_widths</code> is provided as an array, the values are considered to be fractions of the full effective page width,
meaning that <code>col_widths=(1, 1, 2)</code> is strictly equivalent to <code>col_widths=(25, 25, 50)</code>.</dd>
<dt><strong><code>first_row_as_headings</code></strong> :&ensp;<code>bool</code></dt>
<dd>optional, default to True. If False, the first row of the table
is not styled differently from the others</dd>
<dt><strong><code>gutter_height</code></strong> :&ensp;<code>float</code></dt>
<dd>optional vertical space between rows</dd>
<dt><strong><code>gutter_width</code></strong> :&ensp;<code>float</code></dt>
<dd>optional horizontal space between columns</dd>
<dt><strong><code>headings_style</code></strong> :&ensp;<code><a title="fpdf.fonts.FontFace" href="fonts.html#fpdf.fonts.FontFace">FontFace</a></code></dt>
<dd>optional, default to bold.
Defines the visual style of the top headings row: size, color, emphasis&hellip;</dd>
<dt><strong><code>line_height</code></strong> :&ensp;<code>number</code></dt>
<dd>optional. Defines how much vertical space a line of text will occupy</dd>
<dt><strong><code>markdown</code></strong> :&ensp;<code>bool</code></dt>
<dd>optional, default to False. Enable markdown interpretation of cells textual content</dd>
<dt><strong><code>text_align</code></strong> :&ensp;<code>str, <a title="fpdf.enums.Align" href="enums.html#fpdf.enums.Align">Align</a>, tuple</code></dt>
<dd>optional, default to JUSTIFY. Control text alignment inside cells.</dd>
<dt><strong><code>v_align</code></strong> :&ensp;<code>str, <a title="fpdf.enums.VAlign" href="enums.html#fpdf.enums.VAlign">VAlign</a></code></dt>
<dd>optional, default to CENTER. Control vertical alignment of cells content</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>number</code></dt>
<dd>optional. Sets the table width</dd>
<dt><strong><code>wrapmode</code></strong> :&ensp;<code><a title="fpdf.enums.WrapMode" href="enums.html#fpdf.enums.WrapMode">WrapMode</a></code></dt>
<dd>"WORD" for word based line wrapping (default),
"CHAR" for character based line wrapping.</dd>
<dt><strong><code>padding</code></strong> :&ensp;<code>number, tuple, Padding</code></dt>
<dd>optional. Sets the cell padding. Can be a single number or a sequence of numbers, default:0
If padding for left and right ends up being non-zero then c_margin is ignored.</dd>
<dt><strong><code>outer_border_width</code></strong> :&ensp;<code>number</code></dt>
<dd>optional. Sets the width of the outer borders of the table.
Only relevant when borders_layout is ALL or NO_HORIZONTAL_LINES. Otherwise, the border widths are controlled by FPDF.set_line_width()</dd>
<dt><strong><code>num_heading_rows</code></strong> :&ensp;<code>number</code></dt>
<dd>optional. Sets the number of heading rows, default value is 1. If this value is not 1,
first_row_as_headings needs to be True if num_heading_rows&gt;1 and False if num_heading_rows=0. For backwards compatibility,
first_row_as_headings is used in case num_heading_rows is 1.</dd>
<dt><strong><code>repeat_headings</code></strong> :&ensp;<code><a title="fpdf.enums.TableHeadingsDisplay" href="enums.html#fpdf.enums.TableHeadingsDisplay">TableHeadingsDisplay</a></code></dt>
<dd>optional, indicates whether to print table headings on every page, default to 1.</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="fpdf.table.Table.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/table.py#L169-L275" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def render(self):
    &#34;This is an internal method called by `fpdf.FPDF.table()` once the table is finished&#34;
    # Starting with some sanity checks:
    self._cols_count = max(row.cols_count for row in self.rows) if self.rows else 0
    if self._width is None:
        if self._col_widths and isinstance(self._col_widths, Number):
            self._width = self._cols_count * self._col_widths
        else:
            self._width = self._fpdf.epw
    elif self._col_widths and isinstance(self._col_widths, Number):
        if self._cols_count * self._col_widths != self._width:
            raise ValueError(
                f&#34;Invalid value provided width={self._width} should be a multiple of col_widths={self._col_widths}&#34;
            )
    if self._width &gt; self._fpdf.epw:
        raise ValueError(
            f&#34;Invalid value provided width={self._width}: effective page width is {self._fpdf.epw}&#34;
        )
    if self._table_align == Align.J:
        raise ValueError(
            &#34;JUSTIFY is an invalid value for FPDF.table() &#39;align&#39; parameter&#34;
        )
    if self._num_heading_rows &gt; 0:
        if not self._headings_style:
            raise ValueError(
                &#34;headings_style must be provided to FPDF.table() if num_heading_rows&gt;1 or first_row_as_headings=True&#34;
            )
        emphasis = self._headings_style.emphasis
        if emphasis is not None:
            family = self._headings_style.family or self._fpdf.font_family
            font_key = family.lower() + emphasis.style.replace(&#34;U&#34;, &#34;&#34;)
            if font_key not in CORE_FONTS and font_key not in self._fpdf.fonts:
                # Raising a more explicit error than the one from set_font():
                raise FPDFException(
                    f&#34;Using font &#39;{family}&#39; with emphasis &#39;{emphasis.style}&#39;&#34;
                    &#34; in table headings require the corresponding font style&#34;
                    &#34; to be added using add_font()&#34;
                )

    # Defining table global horizontal position:
    prev_x, prev_y, prev_l_margin = self._fpdf.x, self._fpdf.y, self._fpdf.l_margin
    if self._table_align == Align.C:
        self._fpdf.l_margin = (self._fpdf.w - self._width) / 2
        self._fpdf.x = self._fpdf.l_margin
    elif self._table_align == Align.R:
        self._fpdf.l_margin = self._fpdf.w - self._fpdf.r_margin - self._width
        self._fpdf.x = self._fpdf.l_margin
    elif self._fpdf.x != self._fpdf.l_margin:
        self._fpdf.l_margin = self._fpdf.x

    # Pre-Compute the relative x-positions of the individual columns:
    xx = self._fpdf.l_margin + self._outer_border_margin[0]
    cell_x_positions = [xx]
    if self.rows:
        for i in range(self._cols_count):
            xx += self._get_col_width(0, i)
            xx += self._gutter_width
            cell_x_positions.append(xx)

    # Process any rowspans
    rows_info = list(self._compute_rows_info())

    # actually render the cells
    repeat_headings = (
        self._repeat_headings is TableHeadingsDisplay.ON_TOP_OF_EVERY_PAGE
    )
    self._fpdf.y += self._outer_border_margin[1]
    if len(self.rows) &gt; self._num_heading_rows &gt; 0:
        # We avoid having the heading rows alone on a page - issue #1391
        # pylint: disable=protected-access
        self._fpdf._perform_page_break_if_need_be(
            sum(
                rows_info[i].pagebreak_height
                for i in range(self._num_heading_rows + 1)
            )
        )
    for i in range(len(self.rows)):
        pagebreak_height = rows_info[i].pagebreak_height
        # pylint: disable=protected-access
        page_break = self._fpdf._perform_page_break_if_need_be(pagebreak_height)
        if (
            page_break
            and self._fpdf.y + pagebreak_height &gt; self._fpdf.page_break_trigger
        ):
            # Restoring original position on page:
            self._fpdf.x = prev_x
            self._fpdf.y = prev_y
            self._fpdf.l_margin = prev_l_margin
            raise ValueError(
                f&#34;The row with index {i} is too high and cannot be rendered on a single page&#34;
            )
        if page_break and repeat_headings and i &gt;= self._num_heading_rows:
            # repeat headings on top:
            self._fpdf.y += self._outer_border_margin[1]
            for row_idx in range(self._num_heading_rows):
                self._render_table_row(
                    row_idx,
                    rows_info[row_idx],
                    cell_x_positions=cell_x_positions,
                )
        if i &gt; 0:
            self._fpdf.y += self._gutter_height
        self._render_table_row(i, rows_info[i], cell_x_positions)

    # Restoring altered FPDF settings:
    self._fpdf.l_margin = prev_l_margin
    self._fpdf.x = self._fpdf.l_margin</code></pre>
</details>
<div class="desc"><p>This is an internal method called by <code>fpdf.FPDF.table()</code> once the table is finished</p></div>
</dd>
<dt id="fpdf.table.Table.row"><code class="name flex">
<span>def <span class="ident">row</span></span>(<span>self, cells=(), style=None, v_align=None, min_height=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/table.py#L156-L167" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def row(self, cells=(), style=None, v_align=None, min_height=None):
    &#34;Adds a row to the table. Returns a `Row` object.&#34;
    if self._initial_style is None:
        self._initial_style = self._fpdf.font_face()
    row = Row(self, style=style, v_align=v_align, min_height=min_height)
    self.rows.append(row)
    for cell in cells:
        if isinstance(cell, dict):
            row.cell(**cell)
        else:
            row.cell(cell)
    return row</code></pre>
</details>
<div class="desc"><p>Adds a row to the table. Returns a <code><a title="fpdf.table.Row" href="#fpdf.table.Row">Row</a></code> object.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fpdf" href="index.html">fpdf</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="fpdf.table.draw_box_borders" href="#fpdf.table.draw_box_borders">draw_box_borders</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fpdf.table.Cell" href="#fpdf.table.Cell">Cell</a></code></h4>
<ul class="two-column">
<li><code><a title="fpdf.table.Cell.align" href="#fpdf.table.Cell.align">align</a></code></li>
<li><code><a title="fpdf.table.Cell.border" href="#fpdf.table.Cell.border">border</a></code></li>
<li><code><a title="fpdf.table.Cell.colspan" href="#fpdf.table.Cell.colspan">colspan</a></code></li>
<li><code><a title="fpdf.table.Cell.img" href="#fpdf.table.Cell.img">img</a></code></li>
<li><code><a title="fpdf.table.Cell.img_fill_width" href="#fpdf.table.Cell.img_fill_width">img_fill_width</a></code></li>
<li><code><a title="fpdf.table.Cell.link" href="#fpdf.table.Cell.link">link</a></code></li>
<li><code><a title="fpdf.table.Cell.padding" href="#fpdf.table.Cell.padding">padding</a></code></li>
<li><code><a title="fpdf.table.Cell.rowspan" href="#fpdf.table.Cell.rowspan">rowspan</a></code></li>
<li><code><a title="fpdf.table.Cell.style" href="#fpdf.table.Cell.style">style</a></code></li>
<li><code><a title="fpdf.table.Cell.text" href="#fpdf.table.Cell.text">text</a></code></li>
<li><code><a title="fpdf.table.Cell.v_align" href="#fpdf.table.Cell.v_align">v_align</a></code></li>
<li><code><a title="fpdf.table.Cell.write" href="#fpdf.table.Cell.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.table.Row" href="#fpdf.table.Row">Row</a></code></h4>
<ul class="">
<li><code><a title="fpdf.table.Row.cell" href="#fpdf.table.Row.cell">cell</a></code></li>
<li><code><a title="fpdf.table.Row.cols_count" href="#fpdf.table.Row.cols_count">cols_count</a></code></li>
<li><code><a title="fpdf.table.Row.convert_spans" href="#fpdf.table.Row.convert_spans">convert_spans</a></code></li>
<li><code><a title="fpdf.table.Row.max_rowspan" href="#fpdf.table.Row.max_rowspan">max_rowspan</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.table.RowLayoutInfo" href="#fpdf.table.RowLayoutInfo">RowLayoutInfo</a></code></h4>
<ul class="">
<li><code><a title="fpdf.table.RowLayoutInfo.height" href="#fpdf.table.RowLayoutInfo.height">height</a></code></li>
<li><code><a title="fpdf.table.RowLayoutInfo.merged_heights" href="#fpdf.table.RowLayoutInfo.merged_heights">merged_heights</a></code></li>
<li><code><a title="fpdf.table.RowLayoutInfo.pagebreak_height" href="#fpdf.table.RowLayoutInfo.pagebreak_height">pagebreak_height</a></code></li>
<li><code><a title="fpdf.table.RowLayoutInfo.rendered_heights" href="#fpdf.table.RowLayoutInfo.rendered_heights">rendered_heights</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.table.RowSpanLayoutInfo" href="#fpdf.table.RowSpanLayoutInfo">RowSpanLayoutInfo</a></code></h4>
<ul class="">
<li><code><a title="fpdf.table.RowSpanLayoutInfo.column" href="#fpdf.table.RowSpanLayoutInfo.column">column</a></code></li>
<li><code><a title="fpdf.table.RowSpanLayoutInfo.contents_height" href="#fpdf.table.RowSpanLayoutInfo.contents_height">contents_height</a></code></li>
<li><code><a title="fpdf.table.RowSpanLayoutInfo.length" href="#fpdf.table.RowSpanLayoutInfo.length">length</a></code></li>
<li><code><a title="fpdf.table.RowSpanLayoutInfo.row_range" href="#fpdf.table.RowSpanLayoutInfo.row_range">row_range</a></code></li>
<li><code><a title="fpdf.table.RowSpanLayoutInfo.start" href="#fpdf.table.RowSpanLayoutInfo.start">start</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.table.Table" href="#fpdf.table.Table">Table</a></code></h4>
<ul class="">
<li><code><a title="fpdf.table.Table.render" href="#fpdf.table.Table.render">render</a></code></li>
<li><code><a title="fpdf.table.Table.row" href="#fpdf.table.Table.row">row</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
