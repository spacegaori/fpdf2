<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>fpdf.fpdf API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fpdf.fpdf</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="fpdf.fpdf.PAGE_FORMATS"><code class="name">var <span class="ident">PAGE_FORMATS</span></code></dt>
<dd>
<div class="desc"><p>Supported page format names &amp; dimensions</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="fpdf.fpdf.get_page_format"><code class="name flex">
<span>def <span class="ident">get_page_format</span></span>(<span>format, k=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L178-L211" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def get_page_format(format, k=None):
    &#34;&#34;&#34;Return page width and height size in points.

    Throws FPDFPageFormatException

    `format` can be either a 2-tuple or one of &#39;a3&#39;, &#39;a4&#39;, &#39;a5&#39;, &#39;letter&#39;, or
    &#39;legal&#39;.

    If format is a tuple, then the return value is the tuple&#39;s values
    given in the units specified on this document in the constructor,
    multiplied by the corresponding scale factor `k`, taken from instance
    variable `self.k`.

    If format is a string, the (width, height) tuple returned is in points.
    For a width and height of 8.5 * 11, 72 dpi is assumed, so the value
    returned is (8.5 * 72, 11 * 72), or (612, 792). Additional formats can be
    added by adding fields to the `PAGE_FORMATS` dictionary with a
    case insensitive key (the name of the new format) and 2-tuple value of
    (width, height) in dots per inch with a 72 dpi resolution.
    &#34;&#34;&#34;
    if isinstance(format, str):
        format = format.lower()
        if format in PAGE_FORMATS:
            return PAGE_FORMATS[format]
        raise FPDFPageFormatException(format, unknown=True)

    if k is None:
        raise FPDFPageFormatException(format, one=True)

    try:
        return format[0] * k, format[1] * k
    except Exception as e:
        args = f&#34;{format}, {k}&#34;
        raise FPDFPageFormatException(f&#34;Arguments must be numbers: {args}&#34;) from e</code></pre>
</details>
<div class="desc"><p>Return page width and height size in points.</p>
<p>Throws FPDFPageFormatException</p>
<p><code>format</code> can be either a 2-tuple or one of 'a3', 'a4', 'a5', 'letter', or
'legal'.</p>
<p>If format is a tuple, then the return value is the tuple's values
given in the units specified on this document in the constructor,
multiplied by the corresponding scale factor <code>k</code>, taken from instance
variable <code>self.k</code>.</p>
<p>If format is a string, the (width, height) tuple returned is in points.
For a width and height of 8.5 * 11, 72 dpi is assumed, so the value
returned is (8.5 * 72, 11 * 72), or (612, 792). Additional formats can be
added by adding fields to the <code><a title="fpdf.fpdf.PAGE_FORMATS" href="#fpdf.fpdf.PAGE_FORMATS">PAGE_FORMATS</a></code> dictionary with a
case insensitive key (the name of the new format) and 2-tuple value of
(width, height) in dots per inch with a 72 dpi resolution.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fpdf.fpdf.FPDF"><code class="flex name class">
<span>class <span class="ident">FPDF</span></span>
<span>(</span><span>orientation='portrait', unit='mm', format='A4', font_cache_dir='DEPRECATED')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L226-L5682" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class FPDF(GraphicsStateMixin, TextRegionMixin):
    &#34;PDF Generation class&#34;

    MARKDOWN_BOLD_MARKER = &#34;**&#34;
    MARKDOWN_ITALICS_MARKER = &#34;__&#34;
    MARKDOWN_STRIKETHROUGH_MARKER = &#34;~~&#34;
    MARKDOWN_UNDERLINE_MARKER = &#34;--&#34;
    MARKDOWN_ESCAPE_CHARACTER = &#34;\\&#34;
    MARKDOWN_LINK_REGEX = re.compile(r&#34;^\[([^][]+)\]\(([^()]+)\)(.*)$&#34;, re.DOTALL)
    MARKDOWN_LINK_COLOR = None
    MARKDOWN_LINK_UNDERLINE = True
    _GS_REGEX = re.compile(r&#34;/(GS\d+) gs&#34;)
    _IMG_REGEX = re.compile(r&#34;/I(\d+) Do&#34;)

    HTML2FPDF_CLASS = HTML2FPDF

    def __init__(
        self,
        orientation=&#34;portrait&#34;,
        unit=&#34;mm&#34;,
        format=&#34;A4&#34;,
        font_cache_dir=&#34;DEPRECATED&#34;,
    ):
        &#34;&#34;&#34;
        Args:
            orientation (str): possible values are &#34;portrait&#34; (can be abbreviated &#34;P&#34;)
                or &#34;landscape&#34; (can be abbreviated &#34;L&#34;). Default to &#34;portrait&#34;.
            unit (str, int, float): possible values are &#34;pt&#34;, &#34;mm&#34;, &#34;cm&#34;, &#34;in&#34;, or a number.
                A point equals 1/72 of an inch, that is to say about 0.35 mm (an inch being 2.54 cm).
                This is a very common unit in typography; font sizes are expressed in this unit.
                If given a number, then it will be treated as the number of points per unit.  (eg. 72 = 1 in)
                Default to &#34;mm&#34;.
            format (str): possible values are &#34;a3&#34;, &#34;a4&#34;, &#34;a5&#34;, &#34;letter&#34;, &#34;legal&#34; or a tuple
                (width, height) expressed in the given unit. Default to &#34;a4&#34;.
            font_cache_dir (Path or str): [**DEPRECATED since v2.5.1**] unused
        &#34;&#34;&#34;
        if font_cache_dir != &#34;DEPRECATED&#34;:
            warnings.warn(
                (
                    &#39;&#34;font_cache_dir&#34; parameter is deprecated since v2.5.1, &#39;
                    &#34;unused and will soon be removed&#34;
                ),
                DeprecationWarning,
                stacklevel=get_stack_level(),
            )
        super().__init__()
        self.single_resources_object = False
        &#34;&#34;&#34;
        Setting this to True restore the old behaviour before 2.7.9.
        Using a single /Resources object makes the resulting PDF document smaller,
        but is less compatible with the PDF spec.
        &#34;&#34;&#34;
        self.page = 0  # current page number
        &#34;&#34;&#34;
        Note: Setting the page manually may result in unexpected behavior.
        `pdf.add_page()` takes special care to ensure the page&#39;s content stream
        matches FPDF&#39;s instance attributes. Manually setting the page does not.
        &#34;&#34;&#34;
        # array of PDFPage objects starting at index 1:
        self.pages: Dict[int, PDFPage] = {}
        self.fonts = {}  # map font string keys to an instance of CoreFont or TTFFont
        # map page numbers to a set of font indices:
        self.links = {}  # array of Destination objects starting at index 1
        self.embedded_files = []  # array of PDFEmbeddedFile
        self.image_cache = ImageCache()
        self.in_footer = False  # flag set while rendering footer
        # indicates that we are inside an .unbreakable() code block:
        self._in_unbreakable = False
        self._lasth = 0  # height of last cell printed
        self.alias_nb_pages()  # enable alias by default

        self._angle = 0  # used by deprecated method: rotate()
        self.xmp_metadata = None
        # Define the compression algorithm used when embedding images:
        self.page_duration = 0  # optional pages display duration, cf. add_page()
        self.page_transition = None  # optional pages transition, cf. add_page()
        self.allow_images_transparency = True
        # Do nothing by default. Allowed values: &#39;WARN&#39;, &#39;DOWNSCALE&#39;:
        self.oversized_images = None
        self.oversized_images_ratio = 2  # number of pixels per UserSpace point
        self.struct_builder = StructureTreeBuilder()

        self.toc_placeholder = None  # optional ToCPlaceholder instance
        self._outline: list[OutlineSection] = []  # list of OutlineSection
        # flag set true while rendering the table of contents
        self.in_toc_rendering = False
        # allow page insertion when writing the table of contents
        self._toc_allow_page_insertion = False
        self._toc_inserted_pages = 0  # number of pages inserted
        # dict of Output Intents, with keys beings their subtypes:
        self._output_intents = {}

        self._sign_key = None
        self.title = None
        self.section_title_styles = {}  # level -&gt; TextStyle

        self.core_fonts_encoding = &#34;latin-1&#34;
        &#34;Font encoding, Latin-1 by default&#34;
        # Replace these fonts with these core fonts
        self.font_aliases = {
            &#34;arial&#34;: &#34;helvetica&#34;,
            &#34;couriernew&#34;: &#34;courier&#34;,
            &#34;timesnewroman&#34;: &#34;times&#34;,
        }
        # Scale factor
        self.k = get_scale_factor(unit)

        # Graphics state variables defined as properties by GraphicsStateMixin.
        # We set their default values here.
        self.font_family = &#34;&#34;  # current font family
        # current font style (BOLD/ITALICS - does not handle UNDERLINE nor STRIKETHROUGH):
        self.font_style = &#34;&#34;
        self.underline = False
        self.strikethrough = False
        self.font_size_pt = 12  # current font size in points
        self.font_stretching = 100  # current font stretching
        self.char_spacing = 0  # current character spacing
        self.current_font = None  # None or an instance of CoreFont or TTFFont
        self.current_font_is_set_on_page = False  # current font and size are already added to current page contents with _out
        self.draw_color = self.DEFAULT_DRAW_COLOR
        self.fill_color = self.DEFAULT_FILL_COLOR
        self.text_color = self.DEFAULT_TEXT_COLOR
        self.page_background = None
        self.dash_pattern = dict(dash=0, gap=0, phase=0)
        self.line_width = 0.567 / self.k  # line width (0.2 mm)
        self.text_mode = TextMode.FILL
        # end of graphics state variables

        self.dw_pt, self.dh_pt = get_page_format(format, self.k)
        self._set_orientation(orientation, self.dw_pt, self.dh_pt)
        self.def_orientation = self.cur_orientation
        # Page spacing
        # Page margins (1 cm)
        margin = (7200 / 254) / self.k
        self.x, self.y, self.l_margin, self.t_margin = 0, 0, 0, 0
        self.set_margins(margin, margin)
        self.x, self.y = self.l_margin, self.t_margin
        self.c_margin = margin / 10.0  # Interior cell margin (1 mm)
        # sets self.auto_page_break, self.b_margin &amp; self.page_break_trigger:
        self.set_auto_page_break(True, 2 * margin)
        self.set_display_mode(&#34;fullwidth&#34;)  # Full width display mode
        self._page_mode = None
        self.viewer_preferences = None  # optional instance of ViewerPreferences
        self.compress = True  # switch enabling pages content compression
        self.pdf_version = &#34;1.3&#34;  # Set default PDF version No.
        self.creation_date = datetime.now(timezone.utc)
        self._security_handler = None
        self._fallback_font_ids = []
        self._fallback_font_exact_match = False

        self._current_draw_context = None
        self._drawing_graphics_state_registry = GraphicsStateDictRegistry()
        # map page numbers to a set of GraphicsState names:
        self._record_text_quad_points = False
        self._resource_catalog = ResourceCatalog()

        # page number -&gt; array of 8 × n numbers:
        self._text_quad_points = defaultdict(list)

        # final buffer holding the PDF document in-memory - defined only after calling output():
        self.buffer = None

    def set_encryption(
        self,
        owner_password,
        user_password=None,
        encryption_method=EncryptionMethod.RC4,
        permissions=AccessPermission.all(),
        encrypt_metadata=False,
    ):
        &#34;&#34;&#34;
        Activate encryption of the document content.

        Args:
            owner_password (str): mandatory. The owner password allows to perform any change on the document,
                including removing all encryption and access permissions.
            user_password (str): optional. If a user password is set, the content of the document will be encrypted
                and a password prompt displayed when a user opens the document.
                The document will only be displayed after either the user or owner password is entered.
            encryption_method (fpdf.enums.EncryptionMethod, str): algorithm to be used to encrypt the document.
                Defaults to RC4.
            permissions (fpdf.enums.AccessPermission): specify access permissions granted
                when the document is opened with user access. Defaults to ALL.
            encrypt_metadata (bool): whether to also encrypt document metadata (author, creation date, etc.).
                Defaults to False.
        &#34;&#34;&#34;
        self._security_handler = StandardSecurityHandler(
            self,
            owner_password=owner_password,
            user_password=user_password,
            permission=permissions,
            encryption_method=encryption_method,
            encrypt_metadata=encrypt_metadata,
        )

    def write_html(self, text, *args, **kwargs):
        &#34;&#34;&#34;
        Parse HTML and convert it to PDF.
        cf. https://py-pdf.github.io/fpdf2/HTML.html

        Args:
            text (str): HTML content to render
            image_map (function): an optional one-argument function that map `&lt;img&gt;` &#34;src&#34; to new image URLs
            li_tag_indent (int): [**DEPRECATED since v2.7.9**]
                numeric indentation of `&lt;li&gt;` elements - Set `tag_styles` instead
            dd_tag_indent (int): [**DEPRECATED since v2.7.9**]
                numeric indentation of `&lt;dd&gt;` elements - Set `tag_styles` instead
            table_line_separators (bool): enable horizontal line separators in `&lt;table&gt;`. Defaults to `False`.
            ul_bullet_char (str): bullet character preceding `&lt;li&gt;` items in `&lt;ul&gt;` lists.
                Can also be configured using the HTML `type` attribute of `&lt;ul&gt;` tags.
            li_prefix_color (tuple, str, fpdf.drawing.DeviceCMYK, fpdf.drawing.DeviceGray, fpdf.drawing.DeviceRGB): color for bullets
                or numbers preceding `&lt;li&gt;` tags. This applies to both `&lt;ul&gt;` &amp; `&lt;ol&gt;` lists.
            heading_sizes (dict): [**DEPRECATED since v2.7.9**]
                font size per heading level names (&#34;h1&#34;, &#34;h2&#34;...) - Set `tag_styles` instead
            pre_code_font (str): [**DEPRECATED since v2.7.9**]
                font to use for `&lt;pre&gt;` &amp; `&lt;code&gt;` blocks - Set `tag_styles` instead
            warn_on_tags_not_matching (bool): control warnings production for unmatched HTML tags. Defaults to `True`.
            tag_indents (dict): [**DEPRECATED since v2.8.0**]
                mapping of HTML tag names to numeric values representing their horizontal left indentation. - Set `tag_styles` instead
            tag_styles (dict[str, fpdf.fonts.TextStyle]): mapping of HTML tag names to `fpdf.TextStyle` or `fpdf.FontFace` instances
        &#34;&#34;&#34;
        html2pdf = self.HTML2FPDF_CLASS(self, *args, **kwargs)
        with self.local_context():
            html2pdf.feed(text)

    def _set_min_pdf_version(self, version):
        self.pdf_version = max(self.pdf_version, version)

    @property
    def emphasis(self) -&gt; TextEmphasis:
        &#34;The current text emphasis: bold, italics, underline and/or strikethrough.&#34;
        font_style = self.font_style
        if self.strikethrough:
            font_style += &#34;S&#34;
        if self.underline:
            font_style += &#34;U&#34;
        return TextEmphasis.coerce(font_style)

    @property
    def is_ttf_font(self) -&gt; bool:
        return self.current_font and self.current_font.type == &#34;TTF&#34;

    @property
    def page_mode(self) -&gt; PageMode:
        return self._page_mode

    @page_mode.setter
    def page_mode(self, page_mode):
        self._page_mode = PageMode.coerce(page_mode)
        if self._page_mode == PageMode.USE_ATTACHMENTS:
            self._set_min_pdf_version(&#34;1.6&#34;)
        elif self._page_mode == PageMode.USE_OC:
            self._set_min_pdf_version(&#34;1.5&#34;)

    @property
    def output_intents(self):
        return self._output_intents.values()

    # @output_intents.setter
    def add_output_intent(
        self,
        subtype: OutputIntentSubType,
        output_condition_identifier: str = None,
        output_condition: str = None,
        registry_name: str = None,
        dest_output_profile: PDFICCProfile = None,
        info: str = None,
    ):
        &#34;&#34;&#34;
        Adds desired Output Intent to the Output Intents array:

        Args:
            subtype (OutputIntentSubType, required): PDFA, PDFX or ISOPDF
            output_condition_identifier (str, required): see the Name in
                https://www.color.org/registry.xalter
            output_condition (str, optional): see the Definition in
                https://www.color.org/registry.xalter
            registry_name (str, optional): &#34;https://www.color.org&#34;
            dest_output_profile (PDFICCProfile, required/optional):
                PDFICCProfile | None # (required  if
                output_condition_identifier does not specify a standard
                production condition; optional otherwise)
            info (str, required/optional see dest_output_profile): human
                readable description of profile
        &#34;&#34;&#34;
        if subtype.value in self._output_intents:
            raise ValueError(
                &#34;add_output_intent: subtype &#39;&#34; + subtype.value + &#34;&#39; already exists.&#34;
            )
        self._output_intents[subtype.value] = OutputIntentDictionary(
            subtype,
            output_condition_identifier,
            output_condition,
            registry_name,
            dest_output_profile,
            info,
        )
        self._set_min_pdf_version(&#34;1.4&#34;)

    @property
    def epw(self):
        &#34;&#34;&#34;
        Effective page width: the page width minus its horizontal margins.
        &#34;&#34;&#34;
        return self.w - self.l_margin - self.r_margin

    @property
    def eph(self):
        &#34;&#34;&#34;
        Effective page height: the page height minus its vertical margins.
        &#34;&#34;&#34;
        return self.h - self.t_margin - self.b_margin

    @property
    def pages_count(self):
        &#34;&#34;&#34;
        Returns the total pages of the document.
        &#34;&#34;&#34;
        return len(self.pages)

    def set_margin(self, margin):
        &#34;&#34;&#34;
        Sets the document right, left, top &amp; bottom margins to the same value.

        Args:
            margin (float): margin in the unit specified to FPDF constructor
        &#34;&#34;&#34;
        self.set_margins(margin, margin)
        self.set_auto_page_break(self.auto_page_break, margin)

    def set_margins(self, left, top, right=-1):
        &#34;&#34;&#34;
        Sets the document left, top &amp; optionally right margins to the same value.
        By default, they equal 1 cm.
        Also sets the current FPDF.y on the page to this minimum vertical position.

        Args:
            left (float): left margin in the unit specified to FPDF constructor
            top (float): top margin in the unit specified to FPDF constructor
            right (float): optional right margin in the unit specified to FPDF constructor
        &#34;&#34;&#34;
        self.set_left_margin(left)
        if self.y &lt; top or self.y == self.t_margin:
            self.y = top
        self.t_margin = top
        if right == -1:
            right = left
        self.r_margin = right

    def set_left_margin(self, margin):
        &#34;&#34;&#34;
        Sets the document left margin.
        Also sets the current FPDF.x on the page to this minimum horizontal position.

        Args:
            margin (float): margin in the unit specified to FPDF constructor
        &#34;&#34;&#34;
        if self.x &lt; margin or self.x == self.l_margin:
            self.x = margin
        self.l_margin = margin

    def set_top_margin(self, margin):
        &#34;&#34;&#34;
        Sets the document top margin.

        Args:
            margin (float): margin in the unit specified to FPDF constructor
        &#34;&#34;&#34;
        self.t_margin = margin

    def set_right_margin(self, margin):
        &#34;&#34;&#34;
        Sets the document right margin.

        Args:
            margin (float): margin in the unit specified to FPDF constructor
        &#34;&#34;&#34;
        self.r_margin = margin

    def set_auto_page_break(self, auto, margin=0):
        &#34;&#34;&#34;
        Set auto page break mode and triggering bottom margin.
        By default, the mode is on and the bottom margin is 2 cm.

        Args:
            auto (bool): enable or disable this mode
            margin (float): optional bottom margin (distance from the bottom of the page)
                in the unit specified to FPDF constructor
        &#34;&#34;&#34;
        self.auto_page_break = auto
        self.b_margin = margin
        self.page_break_trigger = self.h - self.b_margin

    @property
    def default_page_dimensions(self):
        &#34;Return a pair (width, height) in the unit specified to FPDF constructor&#34;
        return (
            (self.dw_pt, self.dh_pt)
            if self.def_orientation == PageOrientation.PORTRAIT
            else (self.dh_pt, self.dw_pt)
        )

    def _set_orientation(self, orientation, page_width_pt, page_height_pt):
        self.cur_orientation = PageOrientation.coerce(orientation)
        if self.cur_orientation is PageOrientation.PORTRAIT:
            self.w_pt = page_width_pt
            self.h_pt = page_height_pt
        else:
            self.w_pt = page_height_pt
            self.h_pt = page_width_pt
        self.w = self.w_pt / self.k
        self.h = self.h_pt / self.k
        if hasattr(self, &#34;auto_page_break&#34;):  # not set when called from constructor
            # When self.h is modified, the .page_break_trigger must be re-computed:
            self.set_auto_page_break(self.auto_page_break, self.b_margin)

    def set_display_mode(self, zoom, layout=&#34;continuous&#34;):
        &#34;&#34;&#34;
        Defines the way the document is to be displayed by the viewer.

        It allows to set the zoom level: pages can be displayed entirely on screen,
        occupy the full width of the window, use the real size,
        be scaled by a specific zooming factor or use the viewer default (configured in its Preferences menu).

        The page layout can also be specified: single page at a time, continuous display, two columns or viewer default.

        Args:
            zoom: either &#34;fullpage&#34;, &#34;fullwidth&#34;, &#34;real&#34;, &#34;default&#34;,
                or a number indicating the zooming factor to use, interpreted as a percentage.
                The zoom level set by default is &#34;default&#34;.
            layout (fpdf.enums.PageLayout, str): allowed layout aliases are &#34;single&#34;, &#34;continuous&#34;, &#34;two&#34; or &#34;default&#34;,
                meaning to use the viewer default mode.
                The layout set by default is &#34;continuous&#34;.
        &#34;&#34;&#34;
        if zoom in ZOOM_CONFIGS or not isinstance(zoom, str):
            self.zoom_mode = zoom
        elif zoom != &#34;default&#34;:
            raise FPDFException(f&#34;Incorrect zoom display mode: {zoom}&#34;)
        self.page_layout = LAYOUT_ALIASES.get(layout, layout)

    def set_text_shaping(
        self,
        use_shaping_engine: bool = True,
        features: dict = None,
        direction: Union[str, TextDirection] = None,
        script: str = None,
        language: str = None,
    ):
        &#34;&#34;&#34;
        Enable or disable text shaping engine when rendering text.
        If features, direction, script or language are not specified the shaping engine will try
        to guess the values based on the input text.

        Args:
            use_shaping_engine: enable or disable the use of the shaping engine to process the text
            features: a dictionary containing 4 digit OpenType features and whether each feature
                should be enabled or disabled
                example: features={&#34;kern&#34;: False, &#34;liga&#34;: False}
            direction: the direction the text should be rendered, either &#34;ltr&#34; (left to right)
                or &#34;rtl&#34; (right to left).
            script: a valid OpenType script tag like &#34;arab&#34; or &#34;latn&#34;
            language: a valid OpenType language tag like &#34;eng&#34; or &#34;fra&#34;
        &#34;&#34;&#34;
        if not use_shaping_engine:
            self.text_shaping = None
            return

        try:
            # pylint: disable=import-outside-toplevel, unused-import
            import uharfbuzz
        except ImportError as exc:
            raise FPDFException(
                &#34;The uharfbuzz package could not be imported, but is required for text shaping. Try: pip install uharfbuzz&#34;
            ) from exc

        #
        # Features must be a dictionary containing opentype features and a boolean flag
        # stating whether the feature should be enabled or disabled.
        #
        # e.g. features={&#34;liga&#34;: True, &#34;kern&#34;: False}
        #
        # https://harfbuzz.github.io/shaping-opentype-features.html
        #

        if features and not isinstance(features, dict):
            raise FPDFException(
                &#34;Features must be a dictionary. See text shaping documentation&#34;
            )
        if not features:
            features = {}

        # Buffer properties (direction, script and language)
        # if the properties are not provided, Harfbuzz &#34;guessing&#34; logic is used.
        # https://harfbuzz.github.io/setting-buffer-properties.html
        # Valid harfbuzz directions are ltr (left to right), rtl (right to left),
        # ttb (top to bottom) or btt (bottom to top)

        text_direction = None
        if direction:
            text_direction = (
                direction
                if isinstance(direction, TextDirection)
                else TextDirection.coerce(direction)
            )
            if text_direction not in [TextDirection.LTR, TextDirection.RTL]:
                raise FPDFException(
                    &#34;FPDF2 only accept ltr (left to right) or rtl (right to left) directions for now.&#34;
                )

        self.text_shaping = {
            &#34;use_shaping_engine&#34;: True,
            &#34;features&#34;: features,
            &#34;direction&#34;: text_direction,
            &#34;script&#34;: script,
            &#34;language&#34;: language,
            &#34;fragment_direction&#34;: None,
            &#34;paragraph_direction&#34;: None,
        }

    @property
    def page_layout(self):
        return self._page_layout

    @page_layout.setter
    def page_layout(self, page_layout):
        self._page_layout = PageLayout.coerce(page_layout) if page_layout else None
        if self._page_layout in (PageLayout.TWO_PAGE_LEFT, PageLayout.TWO_PAGE_RIGHT):
            self._set_min_pdf_version(&#34;1.5&#34;)

    def set_compression(self, compress):
        &#34;&#34;&#34;
        Activates or deactivates page compression.

        When activated, the internal representation of each page is compressed
        using the zlib/deflate method (FlateDecode), which leads to a compression ratio
        of about 2 for the resulting document.

        Page compression is enabled by default.

        Args:
            compress (bool): indicates if compression should be enabled
        &#34;&#34;&#34;
        self.compress = compress

    def set_title(self, title):
        &#34;&#34;&#34;
        Defines the title of the document.

        Most PDF readers will display it when viewing the document.
        There is also a related `fpdf.prefs.ViewerPreferences` entry:

            pdf.viewer_preferences = ViewerPreferences(display_doc_title=True)

        Args:
            title (str): the title
        &#34;&#34;&#34;
        self.title = title

    def set_lang(self, lang):
        &#34;&#34;&#34;
        A language identifier specifying the natural language for all text in the document
        except where overridden by language specifications for structure elements or marked content.
        A language identifier can either be the empty text string, to indicate that the language is unknown,
        or a Language-Tag as defined in RFC 3066, &#34;Tags for the Identification of Languages&#34;.

        Args:
            lang (str): the document main language
        &#34;&#34;&#34;
        self.lang = lang
        if lang:
            self._set_min_pdf_version(&#34;1.4&#34;)

    def set_subject(self, subject):
        &#34;&#34;&#34;
        Defines the subject of the document.

        Args:
            subject (str): the document main subject
        &#34;&#34;&#34;
        self.subject = subject

    def set_author(self, author):
        &#34;&#34;&#34;
        Defines the author of the document.

        Args:
            author(str): the name of the author
        &#34;&#34;&#34;
        self.author = author

    def set_keywords(self, keywords):
        &#34;&#34;&#34;
        Associate keywords with the document

        Args:
            keywords (str): a space-separated list of words
        &#34;&#34;&#34;
        self.keywords = keywords

    def set_creator(self, creator):
        &#34;&#34;&#34;
        Defines the creator of the document.
        This is typically the name of the application that generates the PDF.

        Args:
            creator (str): name of the PDF creator
        &#34;&#34;&#34;
        self.creator = creator

    def set_producer(self, producer):
        &#34;&#34;&#34;Producer of document&#34;&#34;&#34;
        self.producer = producer

    def set_creation_date(self, date=None):
        &#34;&#34;&#34;Sets Creation of Date time, or current time if None given.&#34;&#34;&#34;
        if self._sign_key:
            raise FPDFException(
                &#34;.set_creation_date() must always be called before .sign*() methods&#34;
            )
        if not isinstance(date, datetime):
            raise TypeError(f&#34;date should be a datetime but is a {type(date)}&#34;)
        if not date.tzinfo:
            date = date.astimezone()
        self.creation_date = date

    def set_xmp_metadata(self, xmp_metadata):
        if &#34;&lt;?xpacket&#34; in xmp_metadata[:50]:
            raise ValueError(
                &#34;fpdf2 already performs XMP metadata wrapping in a &lt;?xpacket&gt; tag&#34;
            )
        self.xmp_metadata = xmp_metadata
        if xmp_metadata:
            self._set_min_pdf_version(&#34;1.4&#34;)

    def set_doc_option(self, opt, value):
        &#34;&#34;&#34;
        Defines a document option.

        Args:
            opt (str): name of the option to set
            value (str) option value

        .. deprecated:: 2.4.0
            Simply set the `FPDF.core_fonts_encoding` property as a replacement.
        &#34;&#34;&#34;
        warnings.warn(
            (
                &#34;set_doc_option() is deprecated since v2.4.0 &#34;
                &#34;and will be removed in a future release. &#34;
                &#34;Simply set the `.core_fonts_encoding` property as a replacement.&#34;
            ),
            DeprecationWarning,
            stacklevel=get_stack_level(),
        )
        if opt != &#34;core_fonts_encoding&#34;:
            raise FPDFException(f&#39;Unknown document option &#34;{opt}&#34;&#39;)
        self.core_fonts_encoding = value

    def set_image_filter(self, image_filter):
        &#34;&#34;&#34;
        Args:
            image_filter (str): name of a the image filter to use
                when embedding images in the document, or &#34;AUTO&#34;,
                meaning to use the best image filter given the images provided.
                Allowed values: `FlateDecode` (lossless zlib/deflate compression),
                `DCTDecode` (lossy compression with JPEG)
                and `JPXDecode` (lossy compression with JPEG2000).
        &#34;&#34;&#34;
        if image_filter not in SUPPORTED_IMAGE_FILTERS:
            raise ValueError(
                f&#34;&#39;{image_filter}&#39; is not a supported image filter&#34;
                f&#34; - Allowed values: {&#39;&#39;.join(SUPPORTED_IMAGE_FILTERS)}&#34;
            )
        self.image_cache.image_filter = image_filter
        if image_filter == &#34;JPXDecode&#34;:
            self._set_min_pdf_version(&#34;1.5&#34;)

    def alias_nb_pages(self, alias=&#34;{nb}&#34;):
        &#34;&#34;&#34;
        Defines an alias for the total number of pages.
        It will be substituted as the document is closed.

        This is useful to insert the number of pages of the document
        at a time when this number is not known by the program.

        This substitution can be disabled for performances reasons, by calling `alias_nb_pages(None)`.

        Args:
            alias (str): the alias. Defaults to &#34;{nb}&#34;.

        Notes
        -----

        When using this feature with the `FPDF.cell` / `FPDF.multi_cell` methods,
        or the `.underline` / `.strikethrough` attributes of `FPDF` class,
        the width of the text rendered will take into account the alias length,
        not the length of the &#34;actual number of pages&#34; string,
        which can causes slight positioning differences.
        &#34;&#34;&#34;
        self.str_alias_nb_pages = alias

    @check_page
    def set_page_label(
        self,
        label_style: Union[str, PageLabelStyle] = None,
        label_prefix: str = None,
        label_start: int = None,
    ):
        &#34;&#34;&#34;
        Enable `fpdf.output.PDFPageLabel` to be inserted on every page.
        This will be displayed by some PDF readers to identify pages.
        &#34;&#34;&#34;
        current_page_label = None
        if self.page in self.pages:
            current_page_label = self.pages[self.page].get_page_label()
        elif self.page &gt; 1:
            current_page_label = self.pages[self.page - 1].get_page_label()
        new_page_label = None
        if label_style or label_prefix or label_start:
            if current_page_label:
                if label_style is None:
                    label_style = current_page_label.get_style()
                if label_prefix is None:
                    label_prefix = current_page_label.get_prefix()
                if label_start is None and not (
                    self.toc_placeholder and self.toc_placeholder.reset_page_indices
                ):
                    label_start = current_page_label.get_start()
            label_style = (
                PageLabelStyle.coerce(label_style, case_sensitive=True)
                if label_style
                else None
            )
            new_page_label = PDFPageLabel(label_style, label_prefix, label_start)
        self.pages[self.page].set_page_label(current_page_label, new_page_label)

    def add_page(
        self,
        orientation: str = &#34;&#34;,
        format: str = &#34;&#34;,
        same: bool = False,
        duration: float = 0,
        transition: Transition = None,
        label_style: Union[str, PageLabelStyle] = None,
        label_prefix: str = None,
        label_start: int = None,
    ):
        &#34;&#34;&#34;
        Adds a new page to the document.
        If a page is already present, the `FPDF.footer()` method is called first.
        Then the page  is added, the current position is set to the top-left corner,
        with respect to the left and top margins, and the `FPDF.header()` method is called.

        Args:
            orientation (str): &#34;portrait&#34; (can be abbreviated &#34;P&#34;)
                or &#34;landscape&#34; (can be abbreviated &#34;L&#34;). Default to &#34;portrait&#34;.
            format (str): &#34;a3&#34;, &#34;a4&#34;, &#34;a5&#34;, &#34;letter&#34;, &#34;legal&#34; or a tuple
                (width, height). Default to &#34;a4&#34;.
            same (bool): indicates to use the same page format as the previous page.
                Default to False.
            duration (float): optional page’s display duration, i.e. the maximum length of time,
                in seconds, that the page is displayed in presentation mode,
                before the viewer application automatically advances to the next page.
                Can be configured globally through the `.page_duration` FPDF property.
                As of june 2021, onored by Adobe Acrobat reader, but ignored by Sumatra PDF reader.
            transition (Transition child class): optional visual transition to use when moving
                from another page to the given page during a presentation.
                Can be configured globally through the `.page_transition` FPDF property.
                As of june 2021, onored by Adobe Acrobat reader, but ignored by Sumatra PDF reader.
            label_style (str or PageLabelStyle): Defines the numbering style for the numeric portion of each
                page label. Possible values are:
                - &#34;D&#34;: Decimal Arabic numerals.
                - &#34;R&#34;: Uppercase Roman numerals.
                - &#34;r&#34;: Lowercase Roman numerals.
                - &#34;A&#34;: Uppercase letters (A to Z for the first 26 pages, followed by AA to ZZ, etc.).
                - &#34;a&#34;: Lowercase letters (a to z for the first 26 pages, followed by aa to zz, etc.).
            label_prefix (str): Prefix string applied to the page label, preceding the numeric portion.
            label_start (int): Starting number for the first page of a page label range.
        &#34;&#34;&#34;
        if self.buffer:
            raise FPDFException(
                &#34;A page cannot be added on a closed document, after calling output()&#34;
            )

        self.current_font_is_set_on_page = False

        family = self.font_family
        emphasis = self.emphasis
        size = self.font_size_pt
        lw = self.line_width
        dc = self.draw_color
        fc = self.fill_color
        tc = self.text_color
        stretching = self.font_stretching
        char_spacing = self.char_spacing
        dash_pattern = self.dash_pattern

        in_toc_extra_page = (
            self.in_toc_rendering
            and self._toc_allow_page_insertion
            and self.page &gt; self.toc_placeholder.start_page
        )
        if self.page &gt; 0 and (not self.in_toc_rendering or in_toc_extra_page):
            # Page footer
            self._render_footer()

        current_page_label = (
            None if self.page == 0 else self.pages[self.page].get_page_label()
        )
        new_page_label = None
        if label_style or label_prefix or label_start:
            label_style = (
                PageLabelStyle.coerce(label_style, case_sensitive=True)
                if label_style
                else None
            )
            new_page_label = PDFPageLabel(label_style, label_prefix, label_start)

        # Start new page
        self._beginpage(
            orientation,
            format,
            same,
            duration or self.page_duration,
            transition or self.page_transition,
            new_page=not self._has_next_page(),
        )

        self.pages[self.page].set_page_label(current_page_label, new_page_label)

        if self.page_background:
            if isinstance(self.page_background, tuple):
                self.set_fill_color(*self.page_background)
                self.rect(0, 0, self.w, self.h, style=&#34;F&#34;)
                self.set_fill_color(*fc.colors255)
            else:
                self.image(self.page_background, 0, 0, self.w, self.h)

        self._out(&#34;2 J&#34;)  # Set line cap style to square
        self.line_width = lw  # Set line width
        self._out(f&#34;{lw * self.k:.2f} w&#34;)

        # Set font
        if family:
            self.set_font(family, emphasis, size)

        # Set colors
        self.draw_color = dc
        if dc != self.DEFAULT_DRAW_COLOR:
            self._out(dc.serialize().upper())
        self.fill_color = fc
        if fc != self.DEFAULT_FILL_COLOR:
            self._out(fc.serialize().lower())
        self.text_color = tc

        # BEGIN Page header
        if (not self.in_toc_rendering) or self._toc_allow_page_insertion:
            self.header()

        if self.line_width != lw:  # Restore line width
            self.line_width = lw
            self._out(f&#34;{lw * self.k:.2f} w&#34;)

        if family:
            self.set_font(family, emphasis, size)  # Restore font

        if self.draw_color != dc:  # Restore colors
            self.draw_color = dc
            self._out(dc.serialize().upper())
        if self.fill_color != fc:
            self.fill_color = fc
            self._out(fc.serialize().lower())
        self.text_color = tc

        if stretching != 100:  # Restore stretching
            self.set_stretching(stretching)
        if char_spacing != 0:
            self.set_char_spacing(char_spacing)
        if dash_pattern != dict(dash=0, gap=0, phase=0):
            self._write_dash_pattern(
                dash_pattern[&#34;dash&#34;], dash_pattern[&#34;gap&#34;], dash_pattern[&#34;phase&#34;]
            )
        # END Page header

    def _render_footer(self):
        self.in_footer = True
        if self.toc_placeholder:
            # The ToC is rendered AFTER the footer,
            # so we must ensure there is no &#34;style leak&#34;:
            self._push_local_stack()
            self._start_local_context()
        self.footer()
        if self.toc_placeholder:
            self._end_local_context()
            self._pop_local_stack()
        self.in_footer = False

    def _beginpage(
        self, orientation, format, same, duration, transition, new_page=True
    ):
        self.page += 1
        if self.in_toc_rendering and self._toc_allow_page_insertion:
            self._toc_inserted_pages += 1
            self.page = len(self.pages) + 1
            new_page = True
        if new_page:
            page = PDFPage(
                contents=bytearray(),
                duration=duration,
                transition=transition,
                index=self.page,
            )
            self.pages[self.page] = page
            if transition:
                self._set_min_pdf_version(&#34;1.5&#34;)
        else:
            page = self.pages[self.page]
        self.x = self.l_margin
        self.y = self.t_margin
        self.font_family = &#34;&#34;
        self.font_stretching = 100
        self.char_spacing = 0
        if same:
            if orientation or format:
                raise ValueError(
                    f&#34;Inconsistent parameters: same={same} but orientation={orientation} format={format}&#34;
                )
        else:
            # Set page format if provided, else use default value:
            page_width_pt, page_height_pt = (
                get_page_format(format, self.k) if format else (self.dw_pt, self.dh_pt)
            )
            self._set_orientation(
                orientation or self.def_orientation, page_width_pt, page_height_pt
            )
        page.set_dimensions(self.w_pt, self.h_pt)

    def header(self):
        &#34;&#34;&#34;
        Header to be implemented in your own inherited class

        This is automatically called by `FPDF.add_page()`
        and should not be called directly by the user application.
        The default implementation performs nothing: you have to override this method
        in a subclass to implement your own rendering logic.

        Note that header rendering can have an impact on the initial
        (x,y) position when starting to render the page content.
        &#34;&#34;&#34;

    def footer(self):
        &#34;&#34;&#34;
        Footer to be implemented in your own inherited class.

        This is automatically called by `FPDF.add_page()` and `FPDF.output()`
        and should not be called directly by the user application.
        The default implementation performs nothing: you have to override this method
        in a subclass to implement your own rendering logic.
        &#34;&#34;&#34;

    def page_no(self):
        &#34;&#34;&#34;Get the current page number&#34;&#34;&#34;
        return self.page

    def get_page_label(self):
        &#34;&#34;&#34;
        Return the current page `fpdf.output.PDFPageLabel`.
        This will be displayed by some PDF readers to identify pages.
        `FPDF.set_page_label()` needs to be called first for those to be inserted.
        &#34;&#34;&#34;
        return self.pages[self.page].get_label()

    def set_draw_color(self, r, g=-1, b=-1):
        &#34;&#34;&#34;
        Defines the color used for all stroking operations (lines, rectangles and cell borders).
        Accepts either a single greyscale value, 3 values as RGB components, a single `#abc` or `#abcdef` hexadecimal color string,
        or an instance of `fpdf.drawing.DeviceCMYK`, `fpdf.drawing.DeviceRGB` or `fpdf.drawing.DeviceGray`.
        The method can be called before the first page is created and the value is retained from page to page.

        Args:
            r (int, tuple, fpdf.drawing.DeviceGray, fpdf.drawing.DeviceRGB): if `g` and `b` are given, this indicates the red component.
                Else, this indicates the grey level. The value must be between 0 and 255.
            g (int): green component (between 0 and 255)
            b (int): blue component (between 0 and 255)
        &#34;&#34;&#34;
        draw_color = convert_to_device_color(r, g, b)
        if draw_color != self.draw_color:
            self.draw_color = draw_color
            if self.page &gt; 0:
                self._out(self.draw_color.serialize().upper())

    def set_fill_color(self, r, g=-1, b=-1):
        &#34;&#34;&#34;
        Defines the color used for all filling operations (filled rectangles and cell backgrounds).
        Accepts either a single greyscale value, 3 values as RGB components, a single `#abc` or `#abcdef` hexadecimal color string,
        or an instance of `fpdf.drawing.DeviceCMYK`, `fpdf.drawing.DeviceRGB` or `fpdf.drawing.DeviceGray`.
        The method can be called before the first page is created and the value is retained from page to page.

        Args:
            r (int, tuple, fpdf.drawing.DeviceGray, fpdf.drawing.DeviceRGB): if `g` and `b` are given, this indicates the red component.
                Else, this indicates the grey level. The value must be between 0 and 255.
            g (int): green component (between 0 and 255)
            b (int): blue component (between 0 and 255)
        &#34;&#34;&#34;
        fill_color = convert_to_device_color(r, g, b)
        if fill_color != self.fill_color:
            self.fill_color = fill_color
            if self.page &gt; 0:
                self._out(self.fill_color.serialize().lower())

    def set_text_color(self, r, g=-1, b=-1):
        &#34;&#34;&#34;
        Defines the color used for text.
        Accepts either a single greyscale value, 3 values as RGB components, a single `#abc` or `#abcdef` hexadecimal color string,
        or an instance of `fpdf.drawing.DeviceCMYK`, `fpdf.drawing.DeviceRGB` or `fpdf.drawing.DeviceGray`.
        The method can be called before the first page is created and the value is retained from page to page.

        Args:
            r (int, tuple, fpdf.drawing.DeviceGray, fpdf.drawing.DeviceRGB): if `g` and `b` are given, this indicates the red component.
                Else, this indicates the grey level. The value must be between 0 and 255.
            g (int): green component (between 0 and 255)
            b (int): blue component (between 0 and 255)
        &#34;&#34;&#34;
        self.text_color = convert_to_device_color(r, g, b)

    def get_string_width(self, s, normalized=False, markdown=False):
        &#34;&#34;&#34;
        Returns the length of a string in user unit. A font must be selected.
        The value is calculated with stretching and spacing.

        Note that the width of a cell has some extra padding added to this width,
        on the left &amp; right sides, equal to the .c_margin property.

        Args:
            s (str): the string whose length is to be computed.
            normalized (bool): whether normalization needs to be performed on the input string.
            markdown (bool): indicates if basic markdown support is enabled
        &#34;&#34;&#34;
        # normalized is parameter for internal use
        s = s if normalized else self.normalize_text(s)
        w = 0
        for frag in self._preload_bidirectional_text(s, markdown):
            w += frag.get_width()
        return w

    def set_line_width(self, width):
        &#34;&#34;&#34;
        Defines the line width of all stroking operations (lines, rectangles and cell borders).
        By default, the value equals 0.2 mm.
        The method can be called before the first page is created and the value is retained from page to page.

        Args:
            width (float): the width in user unit
        &#34;&#34;&#34;
        if width != self.line_width:
            self.line_width = width
            if self.page &gt; 0:
                self._out(f&#34;{width * self.k:.2f} w&#34;)

    def set_page_background(self, background):
        &#34;&#34;&#34;
        Sets a background color or image to be drawn every time `FPDF.add_page()` is called, or removes a previously set background.
        The method can be called before the first page is created and the value is retained from page to page.

        Args:
            background: either a string representing a file path or URL to an image,
                an io.BytesIO containing an image as bytes, an instance of `PIL.Image.Image`, drawing.DeviceRGB
                or a RGB tuple representing a color to fill the background with or `None` to remove the background
        &#34;&#34;&#34;

        if isinstance(
            background, (str, io.BytesIO, Image, DeviceRGB, tuple, type(None))
        ):
            if isinstance(background, DeviceRGB):
                self.page_background = background.colors255
            else:
                self.page_background = background
        else:
            raise TypeError(
                f&#34;&#34;&#34;background must be of type str, io.BytesIO, PIL.Image.Image, drawing.DeviceRGB, tuple or None
        got: {type(background)}&#34;&#34;&#34;
            )

    @contextmanager
    @check_page
    def drawing_context(self, debug_stream=None):
        &#34;&#34;&#34;
        Create a context for drawing paths on the current page.

        If this context manager is called again inside of an active context, it will
        raise an exception, as base drawing contexts cannot be nested.

        Args:
            debug_stream (TextIO): print a pretty tree of all items to be rendered
                to the provided stream. To store the output in a string, use
                `io.StringIO`.
        &#34;&#34;&#34;

        if self._current_draw_context is not None:
            raise FPDFException(
                &#34;cannot create a drawing context while one is already open&#34;
            )

        context = DrawingContext()
        self._current_draw_context = context
        try:
            yield context
        finally:
            self._current_draw_context = None

        starting_style = self._current_graphic_style()
        render_args = (
            self._drawing_graphics_state_registry,
            Point(self.x, self.y),
            self.k,
            self.h,
            starting_style,
        )

        if debug_stream:
            rendered = context.render_debug(*render_args, debug_stream)
        else:
            rendered = context.render(*render_args)

        for match in self._GS_REGEX.finditer(rendered):
            self._resource_catalog.add(
                PDFResourceType.EXT_G_STATE, match.group(1), self.page
            )
        # Registering raster images embedded in the vector graphics:
        for match in self._IMG_REGEX.finditer(rendered):
            self._resource_catalog.add(
                PDFResourceType.X_OBJECT, int(match.group(1)), self.page
            )
        # Once we handle text-rendering SVG tags (cf. PR #1029),
        # we should also detect fonts used and add them to the resource catalog

        self._out(rendered)
        # The drawing API makes use of features (notably transparency and blending modes) that were introduced in PDF 1.4:
        self._set_min_pdf_version(&#34;1.4&#34;)

    @contextmanager
    @check_page
    def use_pattern(self, shading):
        &#34;&#34;&#34;
        Create a context for using a shading pattern on the current page.
        &#34;&#34;&#34;
        self._resource_catalog.add(PDFResourceType.SHADDING, shading, self.page)
        pattern = shading.get_pattern()
        pattern_name = self._resource_catalog.add(
            PDFResourceType.PATTERN, pattern, self.page
        )
        self._out(f&#34;/Pattern cs /{pattern_name} scn&#34;)
        try:
            yield
        finally:
            self._out(self.draw_color.serialize().lower())

    def _current_graphic_style(self):
        gs = GraphicsStyle()
        gs.allow_transparency = self.allow_images_transparency

        # This initial stroke_width is ignored when embedding SVGs,
        # as the value in SVGObject.convert_graphics() takes precedence,
        # so this probably creates an unnecessary PDF dict entry:
        gs.stroke_width = self.line_width

        if self.draw_color != self.DEFAULT_DRAW_COLOR:
            gs.stroke_color = self.draw_color
        if self.fill_color != self.DEFAULT_FILL_COLOR:
            gs.fill_color = self.fill_color

        dash_info = self.dash_pattern
        dash_pattern = (dash_info[&#34;dash&#34;], dash_info[&#34;gap&#34;])
        if (dash_pattern[0] == 0) or (dash_pattern[1] == 0):
            dash_pattern = None

        gs.stroke_dash_pattern = dash_pattern
        gs.stroke_dash_phase = dash_info[&#34;phase&#34;]

        return gs

    @contextmanager
    def new_path(self, x=0, y=0, paint_rule=PathPaintRule.AUTO, debug_stream=None):
        &#34;&#34;&#34;
        Create a path for appending lines and curves to.

        Args:
            x (float): Abscissa of the path starting point
            y (float): Ordinate of the path starting point
            paint_rule (PathPaintRule): Optional choice of how the path should
                be painted. The default (AUTO) automatically selects stroke/fill based
                on the path style settings.
            debug_stream (TextIO): print a pretty tree of all items to be rendered
                to the provided stream. To store the output in a string, use
                `io.StringIO`.

        &#34;&#34;&#34;
        with self.drawing_context(debug_stream=debug_stream) as ctxt:
            path = PaintedPath(x=x, y=y)
            path.style.paint_rule = paint_rule
            yield path
            ctxt.add_item(path)

    def draw_path(self, path, debug_stream=None):
        &#34;&#34;&#34;
        Add a pre-constructed path to the document.

        Args:
            path (drawing.PaintedPath): the path to be drawn.
            debug_stream (TextIO): print a pretty tree of all items to be rendered
                to the provided stream. To store the output in a string, use
                `io.StringIO`.
        &#34;&#34;&#34;
        with self.drawing_context(debug_stream=debug_stream) as ctxt:
            ctxt.add_item(path)

    def set_dash_pattern(self, dash=0, gap=0, phase=0):
        &#34;&#34;&#34;
        Set the current dash pattern for lines and curves.

        Args:
            dash (float): The length of the dashes in current units.

            gap (float): The length of the gaps between dashes in current units.
                If omitted, the dash length will be used.

            phase (float): Where in the sequence to start drawing.

        Omitting &#39;dash&#39; (= 0) resets the pattern to a solid line.
        &#34;&#34;&#34;
        if not (isinstance(dash, (int, float)) and dash &gt;= 0):
            raise ValueError(&#34;Dash length must be zero or a positive number.&#34;)
        if not (isinstance(gap, (int, float)) and gap &gt;= 0):
            raise ValueError(&#34;gap length must be zero or a positive number.&#34;)
        if not (isinstance(phase, (int, float)) and phase &gt;= 0):
            raise ValueError(&#34;Phase must be zero or a positive number.&#34;)

        pattern = dict(dash=dash, gap=gap, phase=phase)

        if pattern != self.dash_pattern:
            self.dash_pattern = pattern
            self._write_dash_pattern(dash, gap, phase)

    def _write_dash_pattern(self, dash, gap, phase):
        if dash:
            if gap:
                dstr = f&#34;[{dash * self.k:.3f} {gap * self.k:.3f}] {phase *self.k:.3f} d&#34;
            else:
                dstr = f&#34;[{dash * self.k:.3f}] {phase *self.k:.3f} d&#34;
        else:
            dstr = &#34;[] 0 d&#34;
        self._out(dstr)

    @check_page
    def line(self, x1, y1, x2, y2):
        &#34;&#34;&#34;
        Draw a line between two points.

        Args:
            x1 (float): Abscissa of first point
            y1 (float): Ordinate of first point
            x2 (float): Abscissa of second point
            y2 (float): Ordinate of second point
        &#34;&#34;&#34;
        self._out(
            f&#34;{x1 * self.k:.2f} {(self.h - y1) * self.k:.2f} m {x2 * self.k:.2f} &#34;
            f&#34;{(self.h - y2) * self.k:.2f} l S&#34;
        )

    @check_page
    def polyline(self, point_list, fill=False, polygon=False, style=None):
        &#34;&#34;&#34;
        Draws lines between two or more points.

        Args:
            point_list (list of tuples): List of Abscissa and Ordinate of
                                        segments that should be drawn
            fill (bool): [**DEPRECATED since v2.5.4**] Use `style=&#34;F&#34;` or `style=&#34;DF&#34;` instead
            polygon (bool): If true, close path before stroking, to fill the inside of the polyline
            style (fpdf.enums.RenderStyle, str): Optional style of rendering. Possible values are:

            * `D` or None: draw border. This is the default value.
            * `F`: fill
            * `DF` or `FD`: draw and fill
        &#34;&#34;&#34;
        if fill:
            warnings.warn(
                (
                    &#39;&#34;fill&#34; parameter is deprecated since v2.5.4, &#39;
                    &#39;use style=&#34;F&#34; or style=&#34;DF&#34; instead&#39;
                ),
                DeprecationWarning,
                stacklevel=get_stack_level(),
            )
        if fill and style is None:
            style = RenderStyle.DF
        else:
            style = RenderStyle.coerce(style)
            if fill and style == RenderStyle.D:
                raise ValueError(
                    f&#34;Conflicting values provided: fill={fill} &amp; style={style}&#34;
                )
        operator = &#34;m&#34;
        for point in point_list:
            self._out(
                f&#34;{point[0] * self.k:.2f} {(self.h - point[1]) * self.k:.2f} {operator}&#34;
            )
            operator = &#34;l&#34;
        if polygon:
            self._out(&#34; h&#34;)
        self._out(f&#34; {style.operator}&#34;)

    @check_page
    def polygon(self, point_list, fill=False, style=None):
        &#34;&#34;&#34;
        Outputs a polygon defined by three or more points.

        Args:
            point_list (list of tuples): List of coordinates defining the polygon to draw
            fill (bool): [**DEPRECATED since v2.5.4**] Use `style=&#34;F&#34;` or `style=&#34;DF&#34;` instead
            style (fpdf.enums.RenderStyle, str): Optional style of rendering. Possible values are:

            * `D` or None: draw border. This is the default value.
            * `F`: fill
            * `DF` or `FD`: draw and fill
        &#34;&#34;&#34;
        self.polyline(point_list, fill=fill, polygon=True, style=style)

    @check_page
    def dashed_line(self, x1, y1, x2, y2, dash_length=1, space_length=1):
        &#34;&#34;&#34;
        Draw a dashed line between two points.

        Args:
            x1 (float): Abscissa of first point
            y1 (float): Ordinate of first point
            x2 (float): Abscissa of second point
            y2 (float): Ordinate of second point
            dash_length (float): Length of the dash
            space_length (float): Length of the space between 2 dashes

        .. deprecated:: 2.4.6
            Use `FPDF.set_dash_pattern()` and the normal drawing operations instead.
        &#34;&#34;&#34;
        warnings.warn(
            (
                &#34;dashed_line() is deprecated since v2.4.6, &#34;
                &#34;and will be removed in a future release. &#34;
                &#34;Use set_dash_pattern() and the normal drawing operations instead.&#34;
            ),
            DeprecationWarning,
            stacklevel=get_stack_level(),
        )
        self.set_dash_pattern(dash_length, space_length)
        self.line(x1, y1, x2, y2)
        self.set_dash_pattern()

    @check_page
    def rect(self, x, y, w, h, style=None, round_corners=False, corner_radius=0):
        &#34;&#34;&#34;
        Outputs a rectangle.
        It can be drawn (border only), filled (with no border) or both.

        Args:
            x (float): Abscissa of upper-left bounding box.
            y (float): Ordinate of upper-left bounding box.
            w (float): Width.
            h (float): Height.
            style (fpdf.enums.RenderStyle, str): Optional style of rendering. Possible values are:

            * `D` or empty string: draw border. This is the default value.
            * `F`: fill
            * `DF` or `FD`: draw and fill

            round_corners (tuple of str, tuple of fpdf.enums.Corner, bool): Optional draw a rectangle with round corners.
            Possible values are:

            *`TOP_LEFT`: a rectangle with round top left corner
            *`TOP_RIGHT`: a rectangle with round top right corner
            *`BOTTOM_LEFT`: a rectangle with round bottom left corner
            *`BOTTOM_RIGHT`: a rectangle with round bottom right corner
            *`True`: a rectangle with all round corners
            *`False`: a rectangle with no round corners

            corner_radius: Optional radius of the corners
        &#34;&#34;&#34;

        style = RenderStyle.coerce(style)
        if round_corners is not False:
            self._draw_rounded_rect(x, y, w, h, style, round_corners, corner_radius)
        else:
            self._out(
                f&#34;{x * self.k:.2f} {(self.h - y) * self.k:.2f} {w * self.k:.2f} &#34;
                f&#34;{-h * self.k:.2f} re {style.operator}&#34;
            )

    def _draw_rounded_rect(self, x, y, w, h, style, round_corners, r):
        min = h
        if w &lt; h:
            min = w

        if r == 0:
            r = min / 5

        if r &gt;= min / 2:
            r /= min

        point_1 = point_8 = (x, y)
        point_2 = point_3 = (x + w, y)
        point_4 = point_5 = (x + w, y + h)
        point_6 = point_7 = (x, y + h)
        coor_x = [x, x + w, x, x + w]
        coor_y = [y, y, y + h, y + h]

        if round_corners is True:
            round_corners = (
                Corner.TOP_RIGHT.value,
                Corner.TOP_LEFT.value,
                Corner.BOTTOM_RIGHT.value,
                Corner.BOTTOM_LEFT.value,
            )
        round_corners = tuple(Corner.coerce(rc) for rc in round_corners)

        if Corner.TOP_RIGHT in round_corners:
            self.arc(coor_x[0], coor_y[0], 2 * r, 180, 270, style=style)
            point_1 = (x + r, y)
            point_8 = (x, y + r)

        if Corner.TOP_LEFT in round_corners:
            self.arc(coor_x[1] - 2 * r, coor_y[1], 2 * r, 270, 0, style=style)
            point_2 = (x + w - r, y)
            point_3 = (x + w, y + r)

        if Corner.BOTTOM_LEFT in round_corners:
            self.arc(coor_x[3] - 2 * r, coor_y[3] - 2 * r, 2 * r, 0, 90, style=style)
            point_4 = (x + w, y + h - r)
            point_5 = (x + w - r, y + h)

        if Corner.BOTTOM_RIGHT in round_corners:
            self.arc(coor_x[2], coor_y[2] - 2 * r, 2 * r, 90, 180, style=style)
            point_6 = (x + r, y + h)
            point_7 = (x, y + h - r)

        if style.is_fill:
            self.polyline(
                [
                    point_1,
                    point_2,
                    point_3,
                    point_4,
                    point_5,
                    point_6,
                    point_7,
                    point_8,
                    point_1,
                ],
                style=&#34;F&#34;,
            )

        if style.is_draw:
            self.line(point_1[0], point_1[1], point_2[0], point_2[1])
            self.line(point_3[0], point_3[1], point_4[0], point_4[1])
            self.line(point_5[0], point_5[1], point_6[0], point_6[1])
            self.line(point_7[0], point_7[1], point_8[0], point_8[1])

    @check_page
    def ellipse(self, x, y, w, h, style=None):
        &#34;&#34;&#34;
        Outputs an ellipse.
        It can be drawn (border only), filled (with no border) or both.

        Args:
            x (float): Abscissa of upper-left bounding box.
            y (float): Ordinate of upper-left bounding box.
            w (float): Width
            h (float): Height
            style (fpdf.enums.RenderStyle, str): Optional style of rendering. Possible values are:

            * `D` or empty string: draw border. This is the default value.
            * `F`: fill
            * `DF` or `FD`: draw and fill
        &#34;&#34;&#34;
        style = RenderStyle.coerce(style)
        self._draw_ellipse(x, y, w, h, style.operator)

    def _draw_ellipse(self, x, y, w, h, operator):
        cx = x + w / 2
        cy = y + h / 2
        rx = w / 2
        ry = h / 2

        lx = 4 / 3 * (math.sqrt(2) - 1) * rx
        ly = 4 / 3 * (math.sqrt(2) - 1) * ry

        self._out(
            (
                f&#34;{(cx + rx) * self.k:.2f} {(self.h - cy) * self.k:.2f} m &#34;
                f&#34;{(cx + rx) * self.k:.2f} {(self.h - cy + ly) * self.k:.2f} &#34;
                f&#34;{(cx + lx) * self.k:.2f} {(self.h - cy + ry) * self.k:.2f} &#34;
                f&#34;{cx * self.k:.2f} {(self.h - cy + ry) * self.k:.2f} c&#34;
            )
        )
        self._out(
            (
                f&#34;{(cx - lx) * self.k:.2f} {(self.h - cy + ry) * self.k:.2f} &#34;
                f&#34;{(cx - rx) * self.k:.2f} {(self.h - cy + ly) * self.k:.2f} &#34;
                f&#34;{(cx - rx) * self.k:.2f} {(self.h - cy) * self.k:.2f} c&#34;
            )
        )
        self._out(
            (
                f&#34;{(cx - rx) * self.k:.2f} {(self.h - cy - ly) * self.k:.2f} &#34;
                f&#34;{(cx - lx) * self.k:.2f} {(self.h - cy - ry) * self.k:.2f} &#34;
                f&#34;{cx * self.k:.2f} {(self.h - cy - ry) * self.k:.2f} c&#34;
            )
        )
        self._out(
            (
                f&#34;{(cx + lx) * self.k:.2f} {(self.h - cy - ry) * self.k:.2f} &#34;
                f&#34;{(cx + rx) * self.k:.2f} {(self.h - cy - ly) * self.k:.2f} &#34;
                f&#34;{(cx + rx) * self.k:.2f} {(self.h - cy) * self.k:.2f} c {operator}&#34;
            )
        )

    @check_page
    def circle(self, x, y, radius, style=None):
        &#34;&#34;&#34;
        Outputs a circle.
        It can be drawn (border only), filled (with no border) or both.

        WARNING: This method changed parameters in [release 2.8.0](https://github.com/py-pdf/fpdf2/releases/tag/2.8.0)

        Args:
            x (float): Abscissa of upper-left bounding box.
            y (float): Ordinate of upper-left bounding box.
            radius (float): Radius of the circle.
            style (str): Style of rendering. Possible values are:

            * `D` or None: draw border. This is the default value.
            * `F`: fill
            * `DF` or `FD`: draw and fill
        &#34;&#34;&#34;
        self.ellipse(x - radius, y - radius, 2 * radius, 2 * radius, style)

    @check_page
    def regular_polygon(self, x, y, numSides, polyWidth, rotateDegrees=0, style=None):
        &#34;&#34;&#34;
        Outputs a regular polygon with n sides
        It can be rotated
        Style can also be applied (fill, border...)

        Args:
            x (float): Abscissa of upper-left bounding box.
            y (float): Ordinate of upper-left bounding box.
            numSides (int): Number of sides for polygon.
            polyWidth (float): Width of the polygon.
            rotateDegrees (float): Optional degree amount to rotate polygon.
            style (fpdf.enums.RenderStyle, str): Optional style of rendering. Possible values are:

            * `D` or None: draw border. This is the default value.
            * `F`: fill
            * `DF` or `FD`: draw and fill
        &#34;&#34;&#34;
        radius = polyWidth / 2
        centerX = x + radius
        centerY = y - radius
        # center point is (centerX, centerY)
        points = []
        for i in range(1, numSides + 1):
            point = centerX + radius * math.cos(
                math.radians((360 / numSides) * i) + math.radians(rotateDegrees)
            ), centerY + radius * math.sin(
                math.radians((360 / numSides) * i) + math.radians(rotateDegrees)
            )
            points.append(point)
        # creates list of touples containing cordinate points of vertices

        self.polygon(points, style=style)
        # passes points through polygon function

    @check_page
    def star(self, x, y, r_in, r_out, corners, rotate_degrees=0, style=None):
        &#34;&#34;&#34;
        Outputs a regular star with n corners.
        It can be rotated.
        It can be drawn (border only), filled (with no border) or both.

        Args:
            x (float): Abscissa of star&#39;s centre.
            y (float): Ordinate of star&#39;s centre.
            r_in (float): radius of internal circle.
            r_out (float): radius of external circle.
            corners (int): number of star&#39;s corners.
            rotate_degrees (float): Optional degree amount to rotate star clockwise.

            style (fpdf.enums.RenderStyle, str): Optional style of rendering. Possible values are:
            * `D`: draw border. This is the default value.
            * `F`: fill.
            * `DF` or `FD`: draw and fill.
        &#34;&#34;&#34;
        th = math.radians(rotate_degrees)
        point_list = []
        for i in range(0, (corners * 2) + 1):
            corner_x = x + (r_out if i % 2 == 0 else r_in) * math.sin(th)
            corner_y = y + (r_out if i % 2 == 0 else r_in) * math.cos(th)
            point_list.append((corner_x, corner_y))

            th += math.radians(180 / corners)

        self.polyline(point_list, polygon=True, style=style)

    @check_page
    def arc(
        self,
        x,
        y,
        a,
        start_angle,
        end_angle,
        b=None,
        inclination=0,
        clockwise=False,
        start_from_center=False,
        end_at_center=False,
        style=None,
    ):
        &#34;&#34;&#34;
        Outputs an arc.
        It can be drawn (border only), filled (with no border) or both.

        Args:
            x (float): Abscissa of upper-left corner of the bounding box of the full ellipse.
            y (float): Ordinate of upper-left corner of the bounding box of the full ellipse.
            a (float): Major axis diameter (width of bounding box).
            b (float): Minor axis diameter (height of bounding box), if None, equals to a (default: None).
            start_angle (float): Start angle of the arc (in degrees).
            end_angle (float): End angle of the arc (in degrees).
            inclination (float): Inclination of the arc in respect of the x-axis (default: 0).
            clockwise (bool): Way of drawing the arc (True: clockwise, False: counterclockwise) (default: False).
            start_from_center (bool): Start drawing from the center of the ellipse (default: False).
            end_at_center (bool): End drawing at the center of the ellipse (default: False).
            style (fpdf.enums.RenderStyle, str): Optional style of rendering. Allowed values are:

            * `D` or None: draw border. This is the default value.
            * `F`: fill
            * `DF` or `FD`: draw and fill
        &#34;&#34;&#34;
        style = RenderStyle.coerce(style)

        if b is None:
            b = a

        a /= 2
        b /= 2

        cx = x + a
        cy = y + b

        # Functions used only to construct other points of the bezier curve
        def deg_to_rad(deg):
            return deg * math.pi / 180

        def angle_to_param(angle):
            angle = deg_to_rad(angle % 360)
            eta = math.atan2(math.sin(angle) / b, math.cos(angle) / a)

            if eta &lt; 0:
                eta += 2 * math.pi
            return eta

        theta = deg_to_rad(inclination)
        cos_theta = math.cos(theta)
        sin_theta = math.sin(theta)

        def evaluate(eta):
            a_cos_eta = a * math.cos(eta)
            b_sin_eta = b * math.sin(eta)

            return [
                cx + a_cos_eta * cos_theta - b_sin_eta * sin_theta,
                cy + a_cos_eta * sin_theta + b_sin_eta * cos_theta,
            ]

        def derivative_evaluate(eta):
            a_sin_eta = a * math.sin(eta)
            b_cos_eta = b * math.cos(eta)

            return [
                -a_sin_eta * cos_theta - b_cos_eta * sin_theta,
                -a_sin_eta * sin_theta + b_cos_eta * cos_theta,
            ]

        # Calculating start_eta and end_eta so that
        #   start_eta &lt; end_eta   &lt;= start_eta + 2*PI if counterclockwise
        #   end_eta   &lt; start_eta &lt;= end_eta + 2*PI   if clockwise
        start_eta = angle_to_param(start_angle)
        end_eta = angle_to_param(end_angle)

        if not clockwise and end_eta &lt;= start_eta:
            end_eta += 2 * math.pi
        elif clockwise and end_eta &gt;= start_eta:
            start_eta += 2 * math.pi

        start_point = evaluate(start_eta)

        # Move to the start point
        if start_from_center:
            self._out(f&#34;{cx * self.k:.2f} {(self.h - cy) * self.k:.2f} m&#34;)
            self._out(
                f&#34;{start_point[0] * self.k:.2f} {(self.h - start_point[1]) * self.k:.2f} l&#34;
            )
        else:
            self._out(
                f&#34;{start_point[0] * self.k:.2f} {(self.h - start_point[1]) * self.k:.2f} m&#34;
            )

        # Number of curves to use, maximal segment angle is 2*PI/max_curves
        max_curves = 4
        n = min(
            max_curves, math.ceil(abs(end_eta - start_eta) / (2 * math.pi / max_curves))
        )
        d_eta = (end_eta - start_eta) / n

        alpha = math.sin(d_eta) * (math.sqrt(4 + 3 * math.tan(d_eta / 2) ** 2) - 1) / 3

        eta2 = start_eta
        p2 = evaluate(eta2)
        p2_prime = derivative_evaluate(eta2)

        for i in range(n):
            p1 = p2
            p1_prime = p2_prime

            eta2 += d_eta
            p2 = evaluate(eta2)
            p2_prime = derivative_evaluate(eta2)

            control_point_1 = [p1[0] + alpha * p1_prime[0], p1[1] + alpha * p1_prime[1]]
            control_point_2 = [p2[0] - alpha * p2_prime[0], p2[1] - alpha * p2_prime[1]]

            end = &#34;&#34;
            if i == n - 1 and not end_at_center:
                end = f&#34; {style.operator}&#34;

            self._out(
                (
                    f&#34;{control_point_1[0] * self.k:.2f} {(self.h - control_point_1[1]) * self.k:.2f} &#34;
                    f&#34;{control_point_2[0] * self.k:.2f} {(self.h - control_point_2[1]) * self.k:.2f} &#34;
                    f&#34;{p2[0] * self.k:.2f} {(self.h - p2[1]) * self.k:.2f} c&#34; + end
                )
            )

        if end_at_center:
            if start_from_center:
                self._out(f&#34;h {style.operator}&#34;)
            else:
                self._out(
                    f&#34;{cx * self.k:.2f} {(self.h - cy) * self.k:.2f} l {style.operator}&#34;
                )

    def solid_arc(
        self,
        x,
        y,
        a,
        start_angle,
        end_angle,
        b=None,
        inclination=0,
        clockwise=False,
        style=None,
    ):
        &#34;&#34;&#34;
        Outputs a solid arc. A solid arc combines an arc and a triangle to form a pie slice
        It can be drawn (border only), filled (with no border) or both.

        Args:
            x (float): Abscissa of upper-left bounding box.
            y (float): Ordinate of upper-left bounding box.
            a (float): Semi-major axis.
            b (float): Semi-minor axis, if None, equals to a (default: None).
            start_angle (float): Start angle of the arc (in degrees).
            end_angle (float): End angle of the arc (in degrees).
            inclination (float): Inclination of the arc in respect of the x-axis (default: 0).
            clockwise (bool): Way of drawing the arc (True: clockwise, False: counterclockwise) (default: False).
            style (str): Style of rendering. Possible values are:

            * `D` or None: draw border. This is the default value.
            * `F`: fill
            * `DF` or `FD`: draw and fill
        &#34;&#34;&#34;
        self.arc(
            x,
            y,
            a,
            start_angle,
            end_angle,
            b,
            inclination,
            clockwise,
            True,
            True,
            style,
        )

    def bezier(self, point_list, closed=False, style=None):
        &#34;&#34;&#34;
        Outputs a quadratic or cubic Bézier curve, defined by three or four coordinates.

        Args:
            point_list (list of tuples): List of Abscissa and Ordinate of
                                        segments that should be drawn. Should be
                                        three or four tuples. The first and last
                                        points are the start and end point. The
                                        middle point(s) are the control point(s).
            closed (bool): True to draw the curve as a closed path, False (default)
                                        for it to be drawn as an open path.
            style (fpdf.enums.RenderStyle, str): Optional style of rendering. Allowed values are:
            * `D` or None: draw border. This is the default value.
            * `F`: fill
            * `DF` or `FD`: draw and fill
        &#34;&#34;&#34;
        points = len(point_list)
        if points not in (3, 4):
            raise ValueError(
                &#34;point_list should contain 3 tuples for a quadratic curve&#34;
                &#34; or 4 tuples for a cubic curve.&#34;
            )
        style = RenderStyle.coerce(style)

        # QuadraticBezierCurve and BezierCurve make use of `initial_point` when instantiated.
        # If we want to define all 3 (quad.) or 4 (cubic) points, we can set `initial_point`
        # to be the first point given in `point_list` by creating a separate dummy path at that pos.
        with self.drawing_context() as ctxt:
            p1 = point_list[0]
            x1, y1 = p1[0], p1[1]

            dummy_path = PaintedPath(x1, y1)
            ctxt.add_item(dummy_path)

            p2 = point_list[1]
            x2, y2 = p2[0], p2[1]

            p3 = point_list[2]
            x3, y3 = p3[0], p3[1]

            if points == 4:
                p4 = point_list[3]
                x4, y4 = p4[0], p4[1]

            path = PaintedPath(x1, y1)

            # Translate enum style (RenderStyle) into rule (PathPaintRule)
            rule = PathPaintRule.STROKE_FILL_NONZERO
            if style.is_draw and not style.is_fill:
                rule = PathPaintRule.STROKE
            elif style.is_fill and not style.is_draw:
                rule = PathPaintRule.FILL_NONZERO

            path.style.paint_rule = rule
            path.style.auto_close = closed

            if points == 4:
                path.curve_to(x2, y2, x3, y3, x4, y4)
            elif points == 3:
                path.curve_to(x2, y2, x2, y2, x3, y3)

            ctxt.add_item(path)

    def add_font(self, family=None, style=&#34;&#34;, fname=None, uni=&#34;DEPRECATED&#34;):
        &#34;&#34;&#34;
        Imports a TrueType or OpenType font and makes it available
        for later calls to the `FPDF.set_font()` method.

        You will find more information on the &#34;Unicode&#34; documentation page.

        Args:
            family (str): optional name of the font family. Used as a reference for `FPDF.set_font()`.
                If not provided, use the base name of the `fname` font path, without extension.
            style (str): font style. &#34;&#34; for regular, include &#39;B&#39; for bold, and/or &#39;I&#39; for italic.
            fname (str): font file name. You can specify a relative or full path.
                If the file is not found, it will be searched in `FPDF_FONT_DIR`.
            uni (bool): [**DEPRECATED since 2.5.1**] unused
        &#34;&#34;&#34;
        if not fname:
            raise ValueError(&#39;&#34;fname&#34; parameter is required&#39;)

        ext = splitext(str(fname))[1].lower()
        if ext not in (&#34;.otf&#34;, &#34;.otc&#34;, &#34;.ttf&#34;, &#34;.ttc&#34;):
            raise ValueError(
                f&#34;Unsupported font file extension: {ext}.&#34;
                &#34; add_font() used to accept .pkl file as input, but for security reasons&#34;
                &#34; this feature is deprecated since v2.5.1 and has been removed in v2.5.3.&#34;
            )

        if uni != &#34;DEPRECATED&#34;:
            warnings.warn(
                (
                    &#39;&#34;uni&#34; parameter is deprecated since v2.5.1, &#39;
                    &#34;unused and will soon be removed&#34;
                ),
                DeprecationWarning,
                stacklevel=get_stack_level(),
            )

        style = &#34;&#34;.join(sorted(style.upper()))
        if any(letter not in &#34;BI&#34; for letter in style):
            raise ValueError(
                f&#34;Unknown style provided (only B &amp; I letters are allowed): {style}&#34;
            )

        for parent in (&#34;.&#34;, FPDF_FONT_DIR):
            if not parent:
                continue

            if (Path(parent) / fname).exists():
                font_file_path = Path(parent) / fname
                break
        else:
            raise FileNotFoundError(f&#34;TTF Font file not found: {fname}&#34;)

        if family is None:
            family = font_file_path.stem

        fontkey = f&#34;{family.lower()}{style}&#34;
        # Check if font already added or one of the core fonts
        if fontkey in self.fonts or fontkey in CORE_FONTS:
            warnings.warn(
                f&#34;Core font or font already added &#39;{fontkey}&#39;: doing nothing&#34;,
                stacklevel=get_stack_level(),
            )
            return

        self.fonts[fontkey] = TTFFont(self, font_file_path, fontkey, style)

    def set_font(self, family=None, style: Union[str, TextEmphasis] = &#34;&#34;, size=0):
        &#34;&#34;&#34;
        Sets the font used to print character strings.
        It is mandatory to call this method at least once before printing text.

        Default encoding is not specified, but all text writing methods accept only
        unicode for external fonts and one byte encoding for standard.

        Standard fonts use `Latin-1` encoding by default, but Windows
        encoding `cp1252` (Western Europe) can be used with
        `self.core_fonts_encoding = encoding`.

        The font specified is retained from page to page.
        The method can be called before the first page is created.

        Args:
            family (str): name of a font added with `FPDF.add_font`,
                or name of one of the 14 standard &#34;PostScript&#34; fonts:
                Courier (fixed-width), Helvetica (sans serif), Times (serif),
                Symbol (symbolic) or ZapfDingbats (symbolic)
                If an empty string is provided, the current family is retained.
            style (str, fpdf.enums.TextEmphasis): empty string (by default) or a combination
                of one or several letters among B (bold), I (italic), S (strikethrough) and U (underline).
                Bold and italic styles do not apply to Symbol and ZapfDingbats fonts.
            size (float): in points. The default value is the current size.
        &#34;&#34;&#34;
        if not family:
            family = self.font_family

        family = family.lower()
        if isinstance(style, TextEmphasis):
            style = style.style
        style = &#34;&#34;.join(sorted(style.upper()))
        if any(letter not in &#34;BISU&#34; for letter in style):
            raise ValueError(
                f&#34;Unknown style provided (only B/I/S/U letters are allowed): {style}&#34;
            )
        if &#34;U&#34; in style:
            self.underline = True
            style = style.replace(&#34;U&#34;, &#34;&#34;)
        else:
            self.underline = False
        if &#34;S&#34; in style:
            self.strikethrough = True
            style = style.replace(&#34;S&#34;, &#34;&#34;)
        else:
            self.strikethrough = False

        if family in self.font_aliases and family + style not in self.fonts:
            warnings.warn(
                f&#34;Substituting font {family} by core font {self.font_aliases[family]}&#34;
                &#34; - This is deprecated since v2.7.8, and will soon be removed&#34;,
                DeprecationWarning,
                stacklevel=get_stack_level(),
            )
            family = self.font_aliases[family]
        elif family in (&#34;symbol&#34;, &#34;zapfdingbats&#34;) and style:
            warnings.warn(
                f&#34;Built-in font {family} only has a single &#39;style&#39; &#34;
                &#34;and can&#39;t be bold or italic&#34;,
                stacklevel=get_stack_level(),
            )
            style = &#34;&#34;

        if not size:
            size = self.font_size_pt

        # Test if font is already selected
        if (
            self.font_family == family
            and self.font_style == style
            and isclose(self.font_size_pt, size)
        ):
            return

        # Test if used for the first time
        fontkey = family + style
        if fontkey not in self.fonts:
            if fontkey not in CORE_FONTS:
                raise FPDFException(
                    f&#34;Undefined font: {fontkey} - &#34;
                    f&#34;Use built-in fonts or FPDF.add_font() beforehand&#34;
                )
            # If it&#39;s one of the core fonts, add it to self.fonts
            self.fonts[fontkey] = CoreFont(self, fontkey, style)

        # Select it
        self.font_family = family
        self.font_style = style
        self.font_size_pt = size
        self.current_font = self.fonts[fontkey]
        self.current_font_is_set_on_page = False

    def set_font_size(self, size):
        &#34;&#34;&#34;
        Configure the font size in points

        Args:
            size (float): font size in points
        &#34;&#34;&#34;
        if isclose(self.font_size_pt, size):
            return
        self.font_size_pt = size
        self.current_font_is_set_on_page = False

    def _set_font_for_page(self, font, font_size_pt, wrap_in_text_object=True):
        &#34;&#34;&#34;
        Set font and size for current page.
        This step is needed before adding text into page and not needed in set_font and set_font_size.
        &#34;&#34;&#34;
        sl = f&#34;/F{font.i} {font_size_pt:.2f} Tf&#34;
        if wrap_in_text_object:
            sl = f&#34;BT {sl} ET&#34;
        self._resource_catalog.add(PDFResourceType.FONT, font.i, self.page)
        self.current_font_is_set_on_page = True
        return sl

    def set_char_spacing(self, spacing):
        &#34;&#34;&#34;
        Sets horizontal character spacing.
        A positive value increases the space between characters, a negative value
        reduces it (which may result in glyph overlap).
        By default, no spacing is set (which is equivalent to a value of 0).

        Args:
            spacing (float): horizontal spacing in document units
        &#34;&#34;&#34;
        if self.char_spacing == spacing:
            return
        self.char_spacing = spacing
        if self.page &gt; 0:
            self._out(f&#34;BT {spacing:.2f} Tc ET&#34;)

    def set_stretching(self, stretching):
        &#34;&#34;&#34;
        Sets horizontal font stretching.
        By default, no stretching is set (which is equivalent to a value of 100).

        Args:
            stretching (float): horizontal stretching (scaling) in percents.
        &#34;&#34;&#34;
        if self.font_stretching == stretching:
            return
        self.font_stretching = stretching
        if self.page &gt; 0:
            self._out(f&#34;BT {stretching:.2f} Tz ET&#34;)

    def set_fallback_fonts(self, fallback_fonts, exact_match=True):
        &#34;&#34;&#34;
        Allows you to specify a list of fonts to be used if any character is not available on the font currently set.
        Detailed documentation: https://py-pdf.github.io/fpdf2/Unicode.html#fallback-fonts

        Args:
            fallback_fonts: sequence of fallback font IDs
            exact_match (bool): when a glyph cannot be rendered uing the current font,
                fpdf2 will look for a fallback font matching the current character emphasis (bold/italics).
                If it does not find such matching font, and `exact_match` is True, no fallback font will be used.
                If it does not find such matching font, and `exact_match` is False, a fallback font will still be used.
                To get even more control over this logic, you can also override `FPDF.get_fallback_font()`
        &#34;&#34;&#34;
        fallback_font_ids = []
        for fallback_font in fallback_fonts:
            found = False
            for fontkey in self.fonts:
                # will add all font styles on the same family
                if fontkey.replace(&#34;B&#34;, &#34;&#34;).replace(&#34;I&#34;, &#34;&#34;) == fallback_font.lower():
                    fallback_font_ids.append(fontkey)
                    found = True
            if not found:
                raise FPDFException(
                    f&#34;Undefined fallback font: {fallback_font} - Use FPDF.add_font() beforehand&#34;
                )
        self._fallback_font_ids = tuple(fallback_font_ids)
        self._fallback_font_exact_match = exact_match

    def add_link(self, y=0, x=0, page=-1, zoom=&#34;null&#34;):
        &#34;&#34;&#34;
        Creates a new internal link and returns its identifier.
        An internal link is a clickable area which directs to another place within the document.

        The identifier can then be passed to the `FPDF.cell()`, `FPDF.write()`, `FPDF.image()`
        or `FPDF.link()` methods.

        Args:
            y (float): optional ordinate of target position.
                The default value is 0 (top of page).
            x (float): optional abscissa of target position.
                The default value is 0 (top of page).
            page (int): optional number of target page.
                -1 indicates the current page, which is the default value.
            zoom (float): optional new zoom level after following the link.
                Currently ignored by Sumatra PDF Reader, but observed by Adobe Acrobat reader.
        &#34;&#34;&#34;
        link = DestinationXYZ(
            self.page if page == -1 else page,
            top=self.h_pt - y * self.k,
            left=x * self.k,
            zoom=zoom,
        )
        link_index = len(self.links) + 1
        self.links[link_index] = link
        return link_index

    def set_link(self, link, y=0, x=0, page=-1, zoom=&#34;null&#34;):
        &#34;&#34;&#34;
        Defines the page and position a link points to.

        Args:
            link (int): a link identifier returned by `FPDF.add_link()`.
            y (float): optional ordinate of target position.
                The default value is 0 (top of page).
            x (float): optional abscissa of target position.
                The default value is 0 (top of page).
            page (int): optional number of target page.
                -1 indicates the current page, which is the default value.
            zoom (float): optional new zoom level after following the link.
                Currently ignored by Sumatra PDF Reader, but observed by Adobe Acrobat reader.
        &#34;&#34;&#34;
        # We must take care to update the existing DestinationXYZ,
        # and NOT re-assign self.links[link] to a new instance,
        # as a reference to self.links[link] is kept in self.pages[].annots:
        link = self.links[link]
        link.page_number = self.page if page == -1 else page
        link.top = self.h_pt - y * self.k
        link.left = x * self.k
        link.zoom = zoom

    @check_page
    def link(self, x, y, w, h, link, alt_text=None, **kwargs):
        &#34;&#34;&#34;
        Puts a link annotation on a rectangular area of the page.
        Text or image links are generally put via `FPDF.cell`,
        `FPDF.write` or `FPDF.image`,
        but this method can be useful for instance to define a clickable area inside an image.

        Args:
            x (float): horizontal position (from the left) to the left side of the link rectangle
            y (float): vertical position (from the top) to the bottom side of the link rectangle
            w (float): width of the link rectangle
            h (float): height of the link rectangle
            link: either an URL or an integer returned by `FPDF.add_link`, defining an internal link to a page
            alt_text (str): optional textual description of the link, for accessibility purposes
            border_width (int): thickness of an optional black border surrounding the link.
                Not all PDF readers honor this: Acrobat renders it but not Sumatra.
        &#34;&#34;&#34;
        action, dest = None, None
        if link:
            if isinstance(link, str):
                action = URIAction(link)
            else:  # Dest type ending of annotation entry
                assert (
                    link in self.links
                ), f&#34;Link with an invalid index: {link} (doc #links={len(self.links)})&#34;
                dest = self.links[link]
                if not dest.page_number:
                    raise ValueError(
                        f&#34;Cannot insert link {link} with no page number assigned&#34;
                    )
        link_annot = AnnotationDict(
            &#34;Link&#34;,
            x=x * self.k,
            y=self.h_pt - y * self.k,
            width=w * self.k,
            height=h * self.k,
            action=action,
            dest=dest,
            **kwargs,
        )
        self.pages[self.page].annots.append(link_annot)
        if alt_text is not None:
            # Note: the spec indicates that a /StructParent could be added **inside* this /Annot,
            # but tests with Adobe Acrobat Reader reveal that the page /StructParents inserted below
            # is enough to link the marked content in the hierarchy tree with this annotation link.
            self._add_marked_content(struct_type=&#34;/Link&#34;, alt_text=alt_text)
        return link_annot

    def embed_file(
        self,
        file_path=None,
        bytes=None,
        basename=None,
        modification_date=None,
        **kwargs,
    ):
        &#34;&#34;&#34;
        Embed a file into the PDF document

        Args:
            file_path (str or Path): filesystem path to the existing file to embed
            bytes (bytes): optional, as an alternative to file_path, bytes content of the file to embed
            basename (str): optional, required if bytes is provided, file base name
            creation_date (datetime): date and time when the file was created
            modification_date (datetime): date and time when the file was last modified
            desc (str): optional description of the file
            compress (bool): enabled zlib compression of the file - False by default
            checksum (bool): insert a MD5 checksum of the file content - False by default

        Returns: a PDFEmbeddedFile instance, with a .basename string attribute representing the internal file name
        &#34;&#34;&#34;
        if file_path:
            if bytes:
                raise ValueError(&#34;&#39;bytes&#39; cannot be provided with &#39;file_path&#39;&#34;)
            if basename:
                raise ValueError(&#34;&#39;basename&#39; cannot be provided with &#39;file_path&#39;&#34;)
            file_path = Path(file_path)
            with file_path.open(&#34;rb&#34;) as input_file:
                bytes = input_file.read()
            basename = file_path.name
            stats = file_path.stat()
            if modification_date is None:
                modification_date = datetime.fromtimestamp(stats.st_mtime).astimezone()
        else:
            if not bytes:
                raise ValueError(&#34;&#39;bytes&#39; is required if &#39;file_path&#39; is not provided&#34;)
            if not basename:
                raise ValueError(
                    &#34;&#39;basename&#39; is required if &#39;file_path&#39; is not provided&#34;
                )
        already_embedded_basenames = set(
            file.basename() for file in self.embedded_files
        )
        if basename in already_embedded_basenames:
            raise ValueError(f&#34;{basename} has already been embedded in this file&#34;)
        embedded_file = PDFEmbeddedFile(
            basename=basename,
            contents=bytes,
            modification_date=modification_date,
            **kwargs,
        )
        self.embedded_files.append(embedded_file)
        self._set_min_pdf_version(&#34;1.4&#34;)
        return embedded_file

    @check_page
    def file_attachment_annotation(
        self, file_path, x, y, w=1, h=1, name=None, flags=DEFAULT_ANNOT_FLAGS, **kwargs
    ):
        &#34;&#34;&#34;
        Puts a file attachment annotation on a rectangular area of the page.

        Args:
            file_path (str or Path): filesystem path to the existing file to embed
            x (float): horizontal position (from the left) to the left side of the link rectangle
            y (float): vertical position (from the top) to the bottom side of the link rectangle
            w (float): optional width of the link rectangle
            h (float): optional height of the link rectangle
            name (fpdf.enums.FileAttachmentAnnotationName, str): optional icon that shall be used in displaying the annotation
            flags (Tuple[fpdf.enums.AnnotationFlag], Tuple[str]): optional list of flags defining annotation properties
            bytes (bytes): optional, as an alternative to file_path, bytes content of the file to embed
            basename (str): optional, required if bytes is provided, file base name
            creation_date (datetime): date and time when the file was created
            modification_date (datetime): date and time when the file was last modified
            desc (str): optional description of the file
            compress (bool): enabled zlib compression of the file - False by default
            checksum (bool): insert a MD5 checksum of the file content - False by default
        &#34;&#34;&#34;
        embedded_file = self.embed_file(file_path, **kwargs)
        embedded_file.set_globally_enclosed(False)
        annotation = AnnotationDict(
            &#34;FileAttachment&#34;,
            x * self.k,
            self.h_pt - y * self.k,
            w * self.k,
            h * self.k,
            file_spec=embedded_file.file_spec(),
            name=FileAttachmentAnnotationName.coerce(name) if name else None,
            flags=flags,
        )
        self.pages[self.page].annots.append(annotation)
        return annotation

    @check_page
    def text_annotation(self, x, y, text, w=1, h=1, name=None, **kwargs):
        &#34;&#34;&#34;
        Puts a text annotation on a rectangular area of the page.

        Args:
            x (float): horizontal position (from the left) to the left side of the link rectangle
            y (float): vertical position (from the top) to the bottom side of the link rectangle
            text (str): text to display
            w (float): optional width of the link rectangle
            h (float): optional height of the link rectangle
            name (fpdf.enums.AnnotationName, str): optional icon that shall be used in displaying the annotation
            flags (Tuple[fpdf.enums.AnnotationFlag], Tuple[str]): optional list of flags defining annotation properties
            title (str): the text label that shall be displayed in the title bar of the annotation’s
                pop-up window when open and active. This entry shall identify the user who added the annotation.
        &#34;&#34;&#34;
        annotation = AnnotationDict(
            &#34;Text&#34;,
            x * self.k,
            self.h_pt - y * self.k,
            w * self.k,
            h * self.k,
            contents=text,
            name=AnnotationName.coerce(name) if name else None,
            **kwargs,
        )
        self.pages[self.page].annots.append(annotation)
        return annotation

    @check_page
    def free_text_annotation(
        self,
        text,
        x=None,
        y=None,
        w=None,
        h=None,
        **kwargs,
    ):
        &#34;&#34;&#34;
        Puts a free text annotation on a rectangular area of the page.

        Args:
            text (str): text to display
            x (float): optional horizontal position (from the left) to the left side of the link rectangle.
                Default value: None, meaning the current abscissa is used
            y (float): vertical position (from the top) to the bottom side of the link rectangle.
                Default value: None, meaning the current ordinate is used
            w (float): optional width of the link rectangle. Default value: None, meaning the length of text in user unit
            h (float): optional height of the link rectangle. Default value: None, meaning an height equal
                to the current font size
            flags (Tuple[fpdf.enums.AnnotationFlag], Tuple[str]): optional list of flags defining annotation properties
            color (tuple): a tuple of numbers in the range 0.0 to 1.0, representing a colour used for the annotation background
            border_width (float): width of the annotation border
        &#34;&#34;&#34;
        if not self.font_family:
            raise FPDFException(&#34;No font set, you need to call set_font() beforehand&#34;)
        if not self.current_font_is_set_on_page:
            self._out(self._set_font_for_page(self.current_font, self.font_size_pt))
        if x is None:
            x = self.x
        if y is None:
            y = self.y
        if h is None:
            h = self.font_size
        if w is None:
            w = self.get_string_width(text, normalized=True, markdown=False)

        annotation = AnnotationDict(
            &#34;FreeText&#34;,
            x * self.k,
            self.h_pt - y * self.k,
            w * self.k,
            h * self.k,
            contents=text,
            default_appearance=f&#34;({self.draw_color.serialize()} /F{self.current_font.i} {self.font_size_pt:.2f} Tf)&#34;,
            **kwargs,
        )
        self.pages[self.page].annots.append(annotation)
        return annotation

    @check_page
    def add_action(self, action, x, y, w, h, **kwargs):
        &#34;&#34;&#34;
        Puts an Action annotation on a rectangular area of the page.

        Args:
            action (fpdf.actions.Action): the action to add
            x (float): horizontal position (from the left) to the left side of the link rectangle
            y (float): vertical position (from the top) to the bottom side of the link rectangle
            w (float): width of the link rectangle
            h (float): height of the link rectangle
        &#34;&#34;&#34;
        annotation = AnnotationDict(
            &#34;Action&#34;,
            x * self.k,
            self.h_pt - y * self.k,
            w * self.k,
            h * self.k,
            action=action,
            **kwargs,
        )
        self.pages[self.page].annots.append(annotation)
        return annotation

    @contextmanager
    def highlight(
        self, text, type=&#34;Highlight&#34;, color=(1, 1, 0), modification_time=None, **kwargs
    ):
        &#34;&#34;&#34;
        Context manager that adds a single highlight annotation based on the text lines inserted
        inside its indented block.

        Args:
            text (str): text of the annotation
            title (str): the text label that shall be displayed in the title bar of the annotation’s
                pop-up window when open and active. This entry shall identify the user who added the annotation.
            type (fpdf.enums.TextMarkupType, str): &#34;Highlight&#34;, &#34;Underline&#34;, &#34;Squiggly&#34; or &#34;StrikeOut&#34;.
            color (tuple): a tuple of numbers in the range 0.0 to 1.0, representing a colour used for
                the title bar of the annotation’s pop-up window. Defaults to yellow.
            modification_time (datetime): date and time when the annotation was most recently modified
        &#34;&#34;&#34;
        if self._record_text_quad_points:
            raise FPDFException(&#34;highlight() cannot be nested&#34;)
        self._record_text_quad_points = True
        yield
        for page, quad_points in self._text_quad_points.items():
            self.add_text_markup_annotation(
                type,
                text,
                quad_points=quad_points,
                modification_time=modification_time,
                page=page,
                color=color,
                **kwargs,
            )
        self._text_quad_points = defaultdict(list)
        self._record_text_quad_points = False

    @contextmanager
    def add_highlight(self, *args, **kwargs):
        warnings.warn(
            &#34;add_highlight() has been renamed to highlight() in v2.5.5.&#34;,
            DeprecationWarning,
            stacklevel=get_stack_level(),
        )
        with self.highlight(*args, **kwargs):
            yield

    @check_page
    def add_text_markup_annotation(
        self,
        type,
        text,
        quad_points,
        color=(1, 1, 0),
        modification_time=None,
        page=None,
        **kwargs,
    ):
        &#34;&#34;&#34;
        Adds a text markup annotation on some quadrilateral areas of the page.

        Args:
            type (fpdf.enums.TextMarkupType, str): &#34;Highlight&#34;, &#34;Underline&#34;, &#34;Squiggly&#34; or &#34;StrikeOut&#34;
            text (str): text of the annotation
            quad_points (tuple): array of 8 × n numbers specifying the coordinates of n quadrilaterals
                in default user space that comprise the region in which the link should be activated.
                The coordinates for each quadrilateral are given in the order: x1 y1 x2 y2 x3 y3 x4 y4
                specifying the four vertices of the quadrilateral in counterclockwise order
            title (str): the text label that shall be displayed in the title bar of the annotation’s
                pop-up window when open and active. This entry shall identify the user who added the annotation.
            color (tuple): a tuple of numbers in the range 0.0 to 1.0, representing a colour used for
                the title bar of the annotation’s pop-up window. Defaults to yellow.
            modification_time (datetime): date and time when the annotation was most recently modified
            page (int): index of the page where this annotation is added
        &#34;&#34;&#34;
        self._set_min_pdf_version(&#34;1.6&#34;)
        type = TextMarkupType.coerce(type).value
        if modification_time is None:
            modification_time = self.creation_date
        if page is None:
            page = self.page
        x_min = min(quad_points[0::2])
        y_min = min(quad_points[1::2])
        x_max = max(quad_points[0::2])
        y_max = max(quad_points[1::2])
        annotation = AnnotationDict(
            type,
            contents=text,
            x=y_min,
            y=y_max,
            width=x_max - x_min,
            height=y_max - y_min,
            modification_time=modification_time,
            quad_points=quad_points,
            color=color,
            **kwargs,
        )
        self.pages[page].annots.append(annotation)
        return annotation

    @check_page
    def ink_annotation(
        self, coords, text=&#34;&#34;, color=(1, 1, 0), border_width=1, **kwargs
    ):
        &#34;&#34;&#34;
        Adds add an ink annotation on the page.

        Args:
            coords (tuple): an iterable of coordinates (pairs of numbers) defining a path
            text (str): textual description
            title (str): the text label that shall be displayed in the title bar of the annotation’s
                pop-up window when open and active. This entry shall identify the user who added the annotation.
            color (tuple): a tuple of numbers in the range 0.0 to 1.0, representing a colour used for
                the title bar of the annotation’s pop-up window. Defaults to yellow.
            border_width (float): thickness of the path stroke.
        &#34;&#34;&#34;
        ink_list = sum(((x * self.k, (self.h - y) * self.k) for (x, y) in coords), ())
        x_min = min(ink_list[0::2])
        y_min = min(ink_list[1::2])
        x_max = max(ink_list[0::2])
        y_max = max(ink_list[1::2])
        annotation = AnnotationDict(
            &#34;Ink&#34;,
            x=y_min,
            y=y_max,
            width=x_max - x_min,
            height=y_max - y_min,
            ink_list=ink_list,
            contents=text,
            border_width=border_width,
            color=color,
            **kwargs,
        )
        self.pages[self.page].annots.append(annotation)
        return annotation

    @check_page
    @support_deprecated_txt_arg
    def text(self, x, y, text=&#34;&#34;):
        &#34;&#34;&#34;
        Prints a character string. The origin is on the left of the first character,
        on the baseline. This method allows placing a string precisely on the page,
        but it is usually easier to use the `FPDF.cell()`, `FPDF.multi_cell() or `FPDF.write()` methods.

        Args:
            x (float): abscissa of the origin
            y (float): ordinate of the origin
            text (str): string to print
            txt (str): [**DEPRECATED since v2.7.6**] string to print

        Notes
        -----

        `text()` lacks many of the features available in `FPDF.write()`,
        `FPDF.cell()` and `FPDF.multi_cell()` like markdown and text shaping.
        &#34;&#34;&#34;
        if not self.font_family:
            raise FPDFException(&#34;No font set, you need to call set_font() beforehand&#34;)
        text = self.normalize_text(text)
        if not self.current_font_is_set_on_page:
            self._out(self._set_font_for_page(self.current_font, self.font_size_pt))
        sl = [f&#34;BT {x * self.k:.2f} {(self.h - y) * self.k:.2f} Td&#34;]
        if self.text_mode != TextMode.FILL:
            sl.append(f&#34; {self.text_mode} Tr {self.line_width:.2f} w&#34;)
        sl.append(f&#34;{self.current_font.encode_text(text)} ET&#34;)
        if (
            text != &#34;&#34; and (self.underline or self.strikethrough)
        ) or self._record_text_quad_points:
            w = self.get_string_width(text, normalized=True, markdown=False)
            if text != &#34;&#34;:
                if self.underline:
                    sl.append(self._do_underline(x, y, w))
                if self.strikethrough:
                    sl.append(self._do_strikethrough(x, y, w))
            if self._record_text_quad_points:
                h = self.font_size
                y -= 0.8 * h  # same coefficient as in _render_styled_text_line()
                self._add_quad_points(x, y, w, h)
        attr_l = []
        if self.fill_color != self.text_color:
            attr_l.append(f&#34;{self.text_color.serialize().lower()}&#34;)
        if attr_l:
            sl = [&#34;q&#34;] + attr_l + sl + [&#34;Q&#34;]
        self._out(&#34; &#34;.join(sl))

    @check_page
    def rotate(self, angle, x=None, y=None):
        &#34;&#34;&#34;
        .. deprecated:: 2.1.0
            Use `FPDF.rotation()` instead.
        &#34;&#34;&#34;
        warnings.warn(
            (
                &#34;rotate() can produces malformed PDFs and is deprecated since v2.1.0. &#34;
                &#34;It will be removed in a future release. &#34;
                &#34;Use the rotation() context manager instead.&#34;
            ),
            DeprecationWarning,
            stacklevel=get_stack_level(),
        )
        if x is None:
            x = self.x
        if y is None:
            y = self.y

        if self._angle != 0:
            self._out(&#34;Q&#34;)
        self._angle = angle
        if angle != 0:
            angle *= math.pi / 180
            c = math.cos(angle)
            s = math.sin(angle)
            cx = x * self.k
            cy = (self.h - y) * self.k
            s = (
                f&#34;q {c:.5F} {s:.5F} {-s:.5F} {c:.5F} {cx:.2F} {cy:.2F} cm &#34;
                f&#34;1 0 0 1 {-cx:.2F} {-cy:.2F} cm&#34;
            )
            self._out(s)

    @check_page
    @contextmanager
    def rotation(self, angle, x=None, y=None):
        &#34;&#34;&#34;
        Method to perform a rotation around a given center.
        It must be used as a context-manager using `with`:

            with rotation(angle=90, x=x, y=y):
                pdf.something()

        The rotation affects all elements which are printed inside the indented
        context (with the exception of clickable areas).

        Args:
            angle (float): angle in degrees
            x (float): abscissa of the center of the rotation
            y (float): ordinate of the center of the rotation

        Notes
        -----

        Only the rendering is altered. The `FPDF.get_x()` and `FPDF.get_y()` methods are
        not affected, nor the automatic page break mechanism.
        The rotation also establishes a local graphics state, so that any
        graphics state settings changed within will not affect the operations
        invoked after it has finished.
        &#34;&#34;&#34;
        if x is None:
            x = self.x
        if y is None:
            y = self.y
        angle *= math.pi / 180
        c, s = math.cos(angle), math.sin(angle)
        cx, cy = x * self.k, (self.h - y) * self.k
        with self.local_context():
            self._out(
                f&#34;{c:.5F} {s:.5F} {-s:.5F} {c:.5F} {cx:.2F} {cy:.2F} cm &#34;
                f&#34;1 0 0 1 {-cx:.2F} {-cy:.2F} cm&#34;
            )
            yield

    @check_page
    @contextmanager
    def skew(self, ax=0, ay=0, x=None, y=None):
        &#34;&#34;&#34;
        Method to perform a skew transformation originating from a given center.
        It must be used as a context-manager using `with`:

            with skew(ax=15, ay=15, x=x, y=y):
                pdf.something()

        The skew transformation affects all elements which are printed inside the indented
        context (with the exception of clickable areas).

        Args:
            ax (float): angle of skew in the horizontal direction in degrees
            ay (float): angle of skew in the vertical direction in degrees
            x (float): abscissa of the center of the skew transformation
            y (float): ordinate of the center of the skew transformation
        &#34;&#34;&#34;
        lim_val = 2**32
        if x is None:
            x = self.x
        if y is None:
            y = self.y
        ax = max(min(math.tan(ax * (math.pi / 180)), lim_val), -lim_val)
        ay = max(min(math.tan(ay * (math.pi / 180)), lim_val), -lim_val)
        cx, cy = x * self.k, (self.h - y) * self.k
        with self.local_context():
            self._out(
                f&#34;1 {ay:.5f} {ax:.5f} 1 {cx:.2f} {cy:.2f} cm &#34;
                f&#34;1 0 0 1 -{cx:.2f} -{cy:.2f} cm&#34;
            )
            yield

    @check_page
    @contextmanager
    def mirror(self, origin, angle):
        &#34;&#34;&#34;
        Method to perform a reflection transformation over a given mirror line.
        It must be used as a context-manager using `with`:

            with mirror(origin=(15,15), angle=&#34;SOUTH&#34;):
                pdf.something()

        The mirror transformation affects all elements which are rendered inside the indented
        context (with the exception of clickable areas).

        Args:
            origin (float, Sequence(float, float)): a point on the mirror line
            angle: (fpdf.enums.Angle): the direction of the mirror line
        &#34;&#34;&#34;
        x, y = origin
        try:
            theta = Angle.coerce(angle).value
        except ValueError:
            theta = angle

        a = math.cos(math.radians(theta * 2))
        b = math.sin(math.radians(theta * 2))
        cx, cy = x * self.k, (self.h - y) * self.k

        with self.local_context():
            self._out(
                f&#34;{a:.5f} {b:.5f} {b:.5f} {a*-1:.5f} {cx:.2f} {cy:.2f} cm &#34;
                f&#34;1 0 0 1 -{cx:.2f} -{cy:.2f} cm&#34;
            )
            yield

    @check_page
    @contextmanager
    def local_context(self, **kwargs):
        &#34;&#34;&#34;
        Creates a local graphics state, which won&#39;t affect the surrounding code.
        This method must be used as a context manager using `with`:

            with pdf.local_context():
                set_some_state()
                draw_some_stuff()

        The affected settings are those controlled by GraphicsStateMixin and drawing.GraphicsStyle:

        * allow_transparency
        * auto_close
        * blend_mode
        * char_vpos
        * char_spacing
        * dash_pattern
        * denom_lift
        * denom_scale
        * draw_color
        * fill_color
        * fill_opacity
        * font_family
        * font_size
        * font_size_pt
        * font_style
        * font_stretching
        * intersection_rule
        * line_width
        * nom_lift
        * nom_scale
        * paint_rule
        * strikethrough
        * stroke_cap_style
        * stroke_join_style
        * stroke_miter_limit
        * stroke_opacity
        * sub_lift
        * sub_scale
        * sup_lift
        * sup_scale
        * text_color
        * text_mode
        * text_shaping
        * underline

        Font size can be specified in document units with `font_size` or in points with `font_size_pt`.

        Args:
            **kwargs: key-values settings to set at the beginning of this context.
        &#34;&#34;&#34;
        if self._in_unbreakable:
            raise FPDFException(
                &#34;cannot create a local context inside an unbreakable() code block&#34;
            )
        self._push_local_stack()
        self._start_local_context(**kwargs)
        yield
        self._end_local_context()
        self._pop_local_stack()

    def _start_local_context(
        self,
        font_family=None,
        font_style=None,
        font_size_pt=None,
        line_width=None,
        draw_color=None,
        fill_color=None,
        text_color=None,
        dash_pattern=None,
        **kwargs,
    ):
        &#34;&#34;&#34;
        This method starts a &#34;q/Q&#34; context in the page content stream,
        and inserts operators in it to initialize all the PDF settings specified.
        &#34;&#34;&#34;
        if &#34;font_size&#34; in kwargs:
            # At some point we may want to deprecate font_size here in favour of font_size_pt,
            # and raise a warning if font_size is provided:
            # * font_size_pt is more consistent with the size parameter of .set_font(), provided in points.
            # * font_size can be misused, as users may not be aware of the difference between the 2 properties,
            #   and may erroneously provide a value in points as font_size.
            if font_size_pt is not None:
                raise ValueError(&#34;font_size &amp; font_size_pt cannot be both provided&#34;)
            font_size_pt = kwargs[&#34;font_size&#34;] * self.k
            del kwargs[&#34;font_size&#34;]
        gs = None
        for key, value in kwargs.items():
            if key in (
                &#34;stroke_color&#34;,
                &#34;stroke_dash_phase&#34;,
                &#34;stroke_dash_pattern&#34;,
                &#34;stroke_width&#34;,
            ):
                raise ValueError(
                    f&#34;Unsupported setting: {key} - This can be controlled through dash_pattern / draw_color / line_width&#34;
                )
            if key in GraphicsStyle.MERGE_PROPERTIES:
                if gs is None:
                    gs = GraphicsStyle()
                setattr(gs, key, value)
                if key == &#34;blend_mode&#34;:
                    self._set_min_pdf_version(&#34;1.4&#34;)
            elif key in (
                &#34;char_vpos&#34;,
                &#34;char_spacing&#34;,
                &#34;current_font&#34;,
                &#34;denom_lift&#34;,
                &#34;denom_scale&#34;,
                &#34;font_stretching&#34;,
                &#34;nom_lift&#34;,
                &#34;nom_scale&#34;,
                &#34;strikethrough&#34;,
                &#34;sub_lift&#34;,
                &#34;sub_scale&#34;,
                &#34;sup_lift&#34;,
                &#34;sup_scale&#34;,
                &#34;text_mode&#34;,
                &#34;text_shaping&#34;,
                &#34;underline&#34;,
                &#34;current_font_is_set_on_page&#34;,
            ):
                setattr(self, key, value)
            else:
                raise ValueError(f&#34;Unsupported setting: {key}&#34;)
        if gs:
            gs_name = self._drawing_graphics_state_registry.register_style(gs)
            self._resource_catalog.add(PDFResourceType.EXT_G_STATE, gs_name, self.page)
            self._out(f&#34;q /{gs_name} gs&#34;)
        else:
            self._out(&#34;q&#34;)
        # All the following calls to .set*() methods invoke .out() and write to the stream buffer:
        if (
            font_family is not None
            or font_style is not None
            or font_size_pt is not None
        ):
            self.set_font(
                font_family or self.font_family,
                # Beware: font_style=&#39;&#39; must be handled distinctly from font_style=None
                self.font_style if font_style is None else font_style,
                font_size_pt or self.font_size_pt,
            )
        if line_width is not None:
            self.set_line_width(line_width)
        if draw_color is not None:
            self.set_draw_color(draw_color)
        if fill_color is not None:
            self.set_fill_color(fill_color)
        if text_color is not None:
            self.set_text_color(text_color)
        if dash_pattern is not None:
            self.set_dash_pattern(**dash_pattern)

    def _end_local_context(self):
        &#34;&#34;&#34;
        This method ends a &#34;q/Q&#34; context in the page content stream.
        &#34;&#34;&#34;
        self._out(&#34;Q&#34;)

    @property
    def accept_page_break(self):
        &#34;&#34;&#34;
        Whenever a page break condition is met, this method is called,
        and the break is issued or not depending on the returned value.

        The default implementation returns a value according to the mode selected by `FPDF.set_auto_page_break()`.
        This method is called automatically and should not be called directly by the application.
        &#34;&#34;&#34;
        return self.auto_page_break

    @check_page
    @support_deprecated_txt_arg
    def cell(
        self,
        w=None,
        h=None,
        text=&#34;&#34;,
        border=0,
        ln=&#34;DEPRECATED&#34;,
        align=Align.L,
        fill=False,
        link=&#34;&#34;,
        center=False,
        markdown=False,
        new_x=XPos.RIGHT,
        new_y=YPos.TOP,
    ):
        &#34;&#34;&#34;
        Prints a cell (rectangular area) with optional borders, background color and
        character string. The upper-left corner of the cell corresponds to the current
        position. The text can be aligned or centered. After the call, the current
        position moves to the selected `new_x`/`new_y` position. It is possible to put a link
        on the text. A cell has an horizontal padding, on the left &amp; right sides, defined by
        the.c_margin property.

        If automatic page breaking is enabled and the cell goes beyond the limit, a
        page break is performed before outputting.

        Args:
            w (float): Cell width. Default value: None, meaning to fit text width.
                If 0, the cell extends up to the right margin.
            h (float): Cell height. Default value: None, meaning an height equal
                to the current font size.
            text (str): String to print. Default value: empty string.
            border: Indicates if borders must be drawn around the cell.
                The value can be either a number (`0`: no border ; `1`: frame)
                or a string containing some or all of the following characters
                (in any order):
                `L`: left ; `T`: top ; `R`: right ; `B`: bottom. Default value: 0.
            new_x (fpdf.enums.XPos, str): New current position in x after the call. Default: RIGHT
            new_y (fpdf.enums.YPos, str): New current position in y after the call. Default: TOP
            ln (int): **DEPRECATED since 2.5.1**: Use `new_x` and `new_y` instead.
            align (fpdf.enums.Align, str): Set text alignment inside the cell.
                Possible values are: `L` or empty string: left align (default value) ;
                `C`: center; `X`: center around current x position; `R`: right align
            fill (bool): Indicates if the cell background must be painted (`True`)
                or transparent (`False`). Default value: False.
            link (str): optional link to add on the cell, internal
                (identifier returned by `FPDF.add_link`) or external URL.
            center (bool): center the cell horizontally on the page.
            markdown (bool): enable minimal markdown-like markup to render part
                of text as bold / italics / strikethrough / underlined.
                Supports `\\` as escape character. Default to False.
            txt (str): [**DEPRECATED since v2.7.6**] String to print. Default value: empty string.

        Returns: a boolean indicating if page break was triggered
        &#34;&#34;&#34;
        if not self.font_family:
            raise FPDFException(&#34;No font set, you need to call set_font() beforehand&#34;)
        if isinstance(w, str) or isinstance(h, str):
            raise ValueError(
                &#34;Parameter &#39;w&#39; and &#39;h&#39; must be numbers, not strings.&#34;
                &#34; You can omit them by passing string content with text=&#34;
            )
        if isinstance(border, int) and border not in (0, 1):
            warnings.warn(
                &#39;Integer values for &#34;border&#34; parameter other than 1 are currently ignored&#39;,
                stacklevel=get_stack_level(),
            )
            border = 1
        new_x = XPos.coerce(new_x)
        new_y = YPos.coerce(new_y)
        align = Align.coerce(align)
        if align == Align.J:
            raise ValueError(
                &#34;cell() only produces one text line, justified alignment is not possible&#34;
            )
        if ln != &#34;DEPRECATED&#34;:
            # For backwards compatibility, if &#34;ln&#34; is used we overwrite &#34;new_[xy]&#34;.
            if ln == 0:
                new_x = XPos.RIGHT
                new_y = YPos.TOP
            elif ln == 1:
                new_x = XPos.LMARGIN
                new_y = YPos.NEXT
            elif ln == 2:
                new_x = XPos.LEFT
                new_y = YPos.NEXT
            else:
                raise ValueError(
                    f&#39;Invalid value for parameter &#34;ln&#34; ({ln}),&#39;
                    &#34; must be an int between 0 and 2.&#34;
                )
            warnings.warn(
                (
                    &#39;The parameter &#34;ln&#34; is deprecated since v2.5.2.&#39;
                    f&#34; Instead of ln={ln} use new_x=XPos.{new_x.name}, new_y=YPos.{new_y.name}.&#34;
                ),
                DeprecationWarning,
                stacklevel=get_stack_level(),
            )
        # Font styles preloading must be performed before any call to FPDF.get_string_width:
        text = self.normalize_text(text)
        styled_txt_frags = (
            self._preload_bidirectional_text(text, markdown)
            if self.text_shaping
            else self._preload_font_styles(text, markdown)
        )
        return self._render_styled_text_line(
            TextLine(
                styled_txt_frags,
                text_width=0,
                number_of_spaces=0,
                align=Align.L if align == Align.J else align,
                height=h,
                max_width=w,
                trailing_nl=False,
            ),
            h,
            border,
            new_x=new_x,
            new_y=new_y,
            fill=fill,
            link=link,
            center=center,
            prevent_font_change=markdown,
        )

    def _render_styled_text_line(
        self,
        text_line: TextLine,
        h: float = None,
        border: Union[str, int] = 0,
        new_x: XPos = XPos.RIGHT,
        new_y: YPos = YPos.TOP,
        fill: bool = False,
        link: str = &#34;&#34;,
        center: bool = False,
        padding: Padding = None,
        prevent_font_change=False,
    ):
        &#34;&#34;&#34;
        Prints a cell (rectangular area) with optional borders, background color and
        character string. The upper-left corner of the cell corresponds to the current
        position. The text can be aligned, centered or justified. After the call, the
        current position moves to the requested new position. It is possible to put a
        link on the text.

        If automatic page breaking is enabled and the cell goes beyond the limit, a
        page break is performed before outputting.

        Args:
            text_line (TextLine instance): Contains the (possibly empty) tuple of
                fragments to render.
            h (float): Cell height. Default value: None, meaning an height equal
                to the current font size.
            border: Indicates if borders must be drawn around the cell.
                The value can be either a number (`0`: no border ; `1`: frame)
                or a string containing some or all of the following characters
                (in any order):
                `L`: left ; `T`: top ; `R`: right ; `B`: bottom. Default value: 0.
            new_x (fpdf.enums.XPos): New current position in x after the call.
            new_y (fpdf.enums.YPos): New current position in y after the call.
            fill (bool): Indicates if the cell background must be painted (`True`)
                or transparent (`False`). Default value: False.
            link (str): optional link to add on the cell, internal
                (identifier returned by `FPDF.add_link`) or external URL.
            center (bool): center the cell horizontally on the page.
            padding (Padding or None): optional padding to apply to the cell content.
                If padding for left and right is non-zero then c_margin is ignored.
            prevent_font_change (bool): ensure no font settings (family / size / style)
                change during this call.

        Returns: a boolean indicating if page break was triggered
        &#34;&#34;&#34;
        if isinstance(border, int) and border not in (0, 1):
            warnings.warn(
                &#39;Integer values for &#34;border&#34; parameter other than 1 are currently ignored&#39;,
                stacklevel=get_stack_level(),
            )
            border = 1
        elif isinstance(border, str) and set(border).issuperset(&#34;LTRB&#34;):
            border = 1

        if padding is None:
            padding = Padding(0, 0, 0, 0)
        l_c_margin = r_c_margin = 0
        if padding.left == 0:
            l_c_margin = self.c_margin
        if padding.right == 0:
            r_c_margin = self.c_margin

        styled_txt_width = text_line.text_width
        if not styled_txt_width:
            for i, frag in enumerate(text_line.fragments):
                unscaled_width = frag.get_width(initial_cs=i != 0)
                styled_txt_width += unscaled_width

        w = text_line.max_width
        if w is None:
            if not text_line.fragments:
                raise ValueError(
                    &#34;&#39;text_line&#39; must have fragments if &#39;text_line.text_width&#39; is None&#34;
                )
            w = styled_txt_width + l_c_margin + r_c_margin
        elif w == 0:
            w = self.w - self.r_margin - self.x
        if center:
            self.x = self.l_margin + (self.epw - w) / 2
        elif text_line.align == Align.X:
            self.x -= w / 2

        max_font_size = 0  # how much height we need to accommodate.
        # currently all font sizes within a line are vertically aligned on the baseline.
        fragments = text_line.get_ordered_fragments()
        for frag in fragments:
            if frag.font_size &gt; max_font_size:
                max_font_size = frag.font_size
        if h is None:
            h = max_font_size
        page_break_triggered = self._perform_page_break_if_need_be(h)
        sl = []

        k = self.k

        # pre-calc border edges with padding

        left = (self.x - padding.left) * k
        right = (self.x + w + padding.right) * k
        top = (self.h - self.y + padding.top) * k
        bottom = (self.h - (self.y + h) - padding.bottom) * k

        if fill:
            op = &#34;B&#34; if border == 1 else &#34;f&#34;
            sl.append(f&#34;{left:.2f} {top:.2f} {right-left:.2f} {bottom-top:.2f} re {op}&#34;)
        elif border == 1:
            sl.append(f&#34;{left:.2f} {top:.2f} {right-left:.2f} {bottom-top:.2f} re S&#34;)
        # pylint: enable=invalid-unary-operand-type

        if isinstance(border, str):
            if &#34;L&#34; in border:
                sl.append(f&#34;{left:.2f} {top:.2f} m {left:.2f} {bottom:.2f} l S&#34;)
            if &#34;T&#34; in border:
                sl.append(f&#34;{left:.2f} {top:.2f} m {right:.2f} {top:.2f} l S&#34;)
            if &#34;R&#34; in border:
                sl.append(f&#34;{right:.2f} {top:.2f} m {right:.2f} {bottom:.2f} l S&#34;)
            if &#34;B&#34; in border:
                sl.append(f&#34;{left:.2f} {bottom:.2f} m {right:.2f} {bottom:.2f} l S&#34;)

        if self._record_text_quad_points:
            self._add_quad_points(self.x, self.y, w, h)

        s_start = self.x
        s_width = 0
        # We try to avoid modifying global settings for temporary changes.
        current_ws = frag_ws = 0.0
        current_lift = 0.0
        current_char_vpos = CharVPos.LINE
        current_font = self.current_font
        current_font_size_pt = self.font_size_pt
        current_font_style = self.font_style
        current_text_mode = self.text_mode
        current_font_stretching = self.font_stretching
        current_char_spacing = self.char_spacing
        fill_color_changed = False
        last_used_color = self.fill_color
        if fragments:
            if text_line.align == Align.R:
                dx = w - l_c_margin - styled_txt_width
            elif text_line.align in [Align.C, Align.X]:
                dx = (w - styled_txt_width) / 2
            else:
                dx = l_c_margin
            s_start += dx
            word_spacing = 0
            if text_line.align == Align.J and text_line.number_of_spaces:
                word_spacing = (
                    w - l_c_margin - r_c_margin - styled_txt_width
                ) / text_line.number_of_spaces
            sl.append(
                f&#34;BT {(self.x + dx) * k:.2f} &#34;
                f&#34;{(self.h - self.y - 0.5 * h - 0.3 * max_font_size) * k:.2f} Td&#34;
            )
            underlines, strikethroughs = [], []
            for i, frag in enumerate(fragments):
                if isinstance(frag, TotalPagesSubstitutionFragment):
                    self.pages[self.page].add_text_substitution(frag)
                if frag.graphics_state[&#34;text_color&#34;] != last_used_color:
                    # allow to change color within the line of text.
                    last_used_color = frag.graphics_state[&#34;text_color&#34;]
                    sl.append(last_used_color.serialize().lower())
                    fill_color_changed = True
                if word_spacing and frag.font_stretching != 100:
                    # Space character is already stretched, extra spacing is absolute.
                    frag_ws = word_spacing * 100 / frag.font_stretching
                else:
                    frag_ws = word_spacing
                if current_font_stretching != frag.font_stretching:
                    current_font_stretching = frag.font_stretching
                    sl.append(f&#34;{frag.font_stretching:.2f} Tz&#34;)
                if current_char_spacing != frag.char_spacing:
                    current_char_spacing = frag.char_spacing
                    sl.append(f&#34;{frag.char_spacing:.2f} Tc&#34;)
                if not self.current_font_is_set_on_page:
                    if prevent_font_change:
                        # This is &#34;local&#34; to the current BT / ET context:
                        current_font = frag.font
                        current_font_size_pt = frag.font_size_pt
                        current_font_style = frag.font_style
                        sl.append(f&#34;/F{current_font.i} {current_font_size_pt:.2f} Tf&#34;)
                        self._resource_catalog.add(
                            PDFResourceType.FONT, current_font.i, self.page
                        )
                        current_char_vpos = frag.char_vpos
                    else:
                        # This is &#34;global&#34; to the page,
                        # as it is rendered in the content stream
                        # BEFORE the text_lines /fragments,
                        # wrapped into BT / ET operators:
                        current_font = self.current_font = frag.font
                        current_font_size_pt = self.font_size_pt = frag.font_size_pt
                        current_font_style = self.font_style = frag.font_style
                        self._out(
                            self._set_font_for_page(
                                current_font,
                                current_font_size_pt,
                            )
                        )
                        current_char_vpos = frag.char_vpos
                elif (
                    current_font != frag.font
                    or current_font_size_pt != frag.font_size_pt
                    or current_font_style != frag.font_style
                    or current_char_vpos != frag.char_vpos
                ):
                    # This is &#34;local&#34; to the current BT / ET context:
                    current_font = frag.font
                    current_font_size_pt = frag.font_size_pt
                    current_font_style = frag.font_style
                    sl.append(
                        self._set_font_for_page(
                            current_font,
                            current_font_size_pt,
                            wrap_in_text_object=False,
                        )
                    )
                    current_char_vpos = frag.char_vpos
                lift = frag.lift
                if lift != current_lift:
                    # Use text rise operator:
                    sl.append(f&#34;{lift:.2f} Ts&#34;)
                    current_lift = lift
                if (
                    frag.text_mode != TextMode.FILL
                    or frag.text_mode != current_text_mode
                ):
                    current_text_mode = frag.text_mode
                    sl.append(f&#34;{frag.text_mode} Tr {frag.line_width:.2f} w&#34;)

                r_text = frag.render_pdf_text(
                    frag_ws,
                    current_ws,
                    word_spacing,
                    self.x + dx + s_width,
                    self.y + (0.5 * h + 0.3 * max_font_size),
                    self.h,
                )
                if r_text:
                    sl.append(r_text)

                frag_width = frag.get_width(
                    initial_cs=i != 0
                ) + word_spacing * frag.characters.count(&#34; &#34;)
                if frag.underline:
                    underlines.append(
                        (self.x + dx + s_width, frag_width, frag.font, frag.font_size)
                    )
                if frag.strikethrough:
                    strikethroughs.append(
                        (self.x + dx + s_width, frag_width, frag.font, frag.font_size)
                    )
                if frag.link:
                    self.link(
                        x=self.x + dx + s_width,
                        y=self.y + (0.5 * h) - (0.5 * frag.font_size),
                        w=frag_width,
                        h=frag.font_size,
                        link=frag.link,
                    )
                if not frag.is_ttf_font:
                    current_ws = frag_ws
                s_width += frag_width

            sl.append(&#34;ET&#34;)

            # Underlines &amp; strikethrough must be rendred OUTSIDE BT/ET contexts,
            # cf. https://github.com/py-pdf/fpdf2/issues/1456
            if underlines:
                for start_x, width, font, font_size in underlines:
                    sl.append(
                        self._do_underline(
                            start_x, self.y + (0.5 * h) + (0.3 * font_size), width, font
                        )
                    )
            if strikethroughs:
                for start_x, width, font, font_size in strikethroughs:
                    sl.append(
                        self._do_strikethrough(
                            start_x, self.y + (0.5 * h) + (0.3 * font_size), width, font
                        )
                    )
            if link:
                self.link(
                    self.x + dx,
                    self.y + (0.5 * h) - (0.5 * frag.font_size),
                    styled_txt_width,
                    frag.font_size,
                    link,
                )

        if sl:
            # If any PDF settings have been left modified, wrap the line
            # in a local context.
            # pylint: disable=too-many-boolean-expressions
            if (
                current_ws != 0.0
                or current_lift != 0.0
                or current_char_vpos != CharVPos.LINE
                or current_font != self.current_font
                or current_font_size_pt != self.font_size_pt
                or current_font_style != self.font_style
                or current_text_mode != self.text_mode
                or fill_color_changed
                or current_font_stretching != self.font_stretching
                or current_char_spacing != self.char_spacing
            ):
                s = f&#34;q {&#39; &#39;.join(sl)} Q&#34;
            else:
                s = &#34; &#34;.join(sl)
            # pylint: enable=too-many-boolean-expressions
            self._out(s)
        # If the text is empty, h = max_font_size ends up as 0.
        # We still need a valid default height for self.ln() (issue #601).
        self._lasth = h or self.font_size

        # XPos.LEFT -&gt; self.x stays the same
        if new_x == XPos.RIGHT:
            self.x += w
        elif new_x == XPos.START:
            self.x = s_start
        elif new_x == XPos.END:
            self.x = s_start + s_width
        elif new_x == XPos.WCONT:
            if s_width:
                self.x = s_start + s_width - r_c_margin
            else:
                self.x = s_start
        elif new_x == XPos.CENTER:
            self.x = s_start + s_width / 2.0
        elif new_x == XPos.LMARGIN:
            self.x = self.l_margin
        elif new_x == XPos.RMARGIN:
            self.x = self.w - self.r_margin

        # YPos.TOP:  -&gt; self.y stays the same
        # YPos.LAST: -&gt; self.y stays the same (single line)
        if new_y == YPos.NEXT:
            self.y += h
        if new_y == YPos.TMARGIN:
            self.y = self.t_margin
        if new_y == YPos.BMARGIN:
            self.y = self.h - self.b_margin

        return page_break_triggered

    def _add_quad_points(self, x, y, w, h):
        self._text_quad_points[self.page].extend(
            [
                x * self.k,
                (self.h - y) * self.k,
                (x + w) * self.k,
                (self.h - y) * self.k,
                x * self.k,
                (self.h - y - h) * self.k,
                (x + w) * self.k,
                (self.h - y - h) * self.k,
            ]
        )

    def _preload_bidirectional_text(self, text, markdown):
        &#34;&#34;&#34; &#34;
        Break the text into bidirectional segments and preload font styles for each fragment
        &#34;&#34;&#34;
        if not self.text_shaping:
            return self._preload_font_styles(text, markdown)
        paragraph_direction = (
            self.text_shaping[&#34;direction&#34;]
            if self.text_shaping[&#34;direction&#34;]
            else auto_detect_base_direction(text)
        )

        paragraph = BidiParagraph(text=text, base_direction=paragraph_direction)
        directional_segments = paragraph.get_bidi_fragments()
        self.text_shaping[&#34;paragraph_direction&#34;] = paragraph.base_direction

        fragments = []
        for bidi_text, bidi_direction in directional_segments:
            self.text_shaping[&#34;fragment_direction&#34;] = bidi_direction
            fragments += self._preload_font_styles(bidi_text, markdown)
        return tuple(fragments)

    def _preload_font_styles(self, text, markdown):
        &#34;&#34;&#34;
        When Markdown styling is enabled, we require secondary fonts
        to ender text in bold &amp; italics.
        This function ensure that those fonts are available.
        It needs to perform Markdown parsing,
        so we return the resulting `styled_txt_frags` tuple
        to avoid repeating this processing later on.
        &#34;&#34;&#34;
        if not text:
            return tuple()
        prev_font_style = self.font_style
        if self.underline:
            prev_font_style += &#34;U&#34;
        if self.strikethrough:
            prev_font_style += &#34;S&#34;
        styled_txt_frags = tuple(self._parse_chars(text, markdown))
        if markdown:
            page = self.page
            # We set the current to page to zero so that
            # set_font() does not produce any text object on the stream buffer:
            self.page = 0
            if any(frag.font_style == &#34;B&#34; for frag in styled_txt_frags):
                # Ensuring bold font is supported:
                self.set_font(style=&#34;B&#34;)
            if any(frag.font_style == &#34;I&#34; for frag in styled_txt_frags):
                # Ensuring italics font is supported:
                self.set_font(style=&#34;I&#34;)
            if any(frag.font_style == &#34;BI&#34; for frag in styled_txt_frags):
                # Ensuring bold italics font is supported:
                self.set_font(style=&#34;BI&#34;)
            if any(frag.font_style == &#34;&#34; for frag in styled_txt_frags):
                # Ensuring base font is supported:
                self.set_font(style=&#34;&#34;)
            for frag in styled_txt_frags:
                frag.font = self.fonts[frag.font_family + frag.font_style]
            # Restoring initial style:
            self.set_font(style=prev_font_style)
            self.page = page
        return styled_txt_frags

    def get_fallback_font(self, char, style=&#34;&#34;):
        &#34;&#34;&#34;
        Returns which fallback font has the requested glyph.
        This method can be overridden to provide more control than the `select_mode` parameter
        of `FPDF.set_fallback_fonts()` provides.
        &#34;&#34;&#34;
        emphasis = TextEmphasis.coerce(style)
        fonts_with_char = [
            font_id
            for font_id in self._fallback_font_ids
            if ord(char) in self.fonts[font_id].cmap
        ]
        if not fonts_with_char:
            return None
        font_with_matching_emphasis = next(
            (font for font in fonts_with_char if self.fonts[font].emphasis == emphasis),
            None,
        )
        if font_with_matching_emphasis:
            return font_with_matching_emphasis
        if self._fallback_font_exact_match:
            return None
        return fonts_with_char[0]

    def _parse_chars(self, text: str, markdown: bool) -&gt; Iterator[Fragment]:
        &#34;Split text into fragments&#34;
        if not markdown and not self.text_shaping and not self._fallback_font_ids:
            if self.str_alias_nb_pages:
                for seq, fragment_text in enumerate(
                    text.split(self.str_alias_nb_pages)
                ):
                    if seq &gt; 0:
                        yield TotalPagesSubstitutionFragment(
                            self.str_alias_nb_pages,
                            self._get_current_graphics_state(),
                            self.k,
                        )
                    if fragment_text:
                        yield Fragment(
                            fragment_text, self._get_current_graphics_state(), self.k
                        )
                return

            yield Fragment(text, self._get_current_graphics_state(), self.k)
            return
        txt_frag, in_bold, in_italics, in_strikethrough, in_underline = (
            [],
            &#34;B&#34; in self.font_style,
            &#34;I&#34; in self.font_style,
            bool(self.strikethrough),
            bool(self.underline),
        )
        current_fallback_font = None
        current_text_script = None

        def frag():
            nonlocal txt_frag, current_fallback_font, current_text_script
            gstate = self._get_current_graphics_state()
            gstate[&#34;font_style&#34;] = (&#34;B&#34; if in_bold else &#34;&#34;) + (
                &#34;I&#34; if in_italics else &#34;&#34;
            )
            gstate[&#34;strikethrough&#34;] = in_strikethrough
            gstate[&#34;underline&#34;] = in_underline
            if current_fallback_font:
                gstate[&#34;font_family&#34;] = &#34;&#34;.join(
                    c for c in current_fallback_font if c.islower()
                )
                gstate[&#34;font_style&#34;] = &#34;&#34;.join(
                    c for c in current_fallback_font if c.isupper()
                )
                gstate[&#34;current_font&#34;] = self.fonts[current_fallback_font]
                current_fallback_font = None
                current_text_script = None
            fragment = Fragment(
                txt_frag,
                gstate,
                self.k,
            )
            txt_frag = []
            return fragment

        if self.is_ttf_font:
            font_glyphs = self.current_font.cmap
        else:
            font_glyphs = []
        num_escape_chars = 0

        while text:
            is_marker = text[:2] in (
                self.MARKDOWN_BOLD_MARKER,
                self.MARKDOWN_ITALICS_MARKER,
                self.MARKDOWN_STRIKETHROUGH_MARKER,
                self.MARKDOWN_UNDERLINE_MARKER,
            )
            half_marker = text[0]
            text_script = get_unicode_script(text[0])
            if text_script not in (
                UnicodeScript.COMMON,
                UnicodeScript.UNKNOWN,
                current_text_script,
            ):
                if txt_frag and current_text_script:
                    yield frag()
                current_text_script = text_script

            if self.str_alias_nb_pages:
                if text[: len(self.str_alias_nb_pages)] == self.str_alias_nb_pages:
                    if txt_frag:
                        yield frag()
                    gstate = self._get_current_graphics_state()
                    gstate[&#34;font_style&#34;] = (&#34;B&#34; if in_bold else &#34;&#34;) + (
                        &#34;I&#34; if in_italics else &#34;&#34;
                    )
                    gstate[&#34;strikethrough&#34;] = in_strikethrough
                    gstate[&#34;underline&#34;] = in_underline
                    yield TotalPagesSubstitutionFragment(
                        self.str_alias_nb_pages,
                        gstate,
                        self.k,
                    )
                    text = text[len(self.str_alias_nb_pages) :]
                    continue

            # Check that previous &amp; next characters are not identical to the marker:
            if markdown:
                if (
                    is_marker
                    and (not txt_frag or txt_frag[-1] != half_marker)
                    and (len(text) &lt; 3 or text[2] != half_marker)
                ):
                    txt_frag = (
                        txt_frag[: -((num_escape_chars + 1) // 2)]
                        if num_escape_chars &gt; 0
                        else txt_frag
                    )
                    if num_escape_chars % 2 == 0:
                        if txt_frag:
                            yield frag()
                        if text[:2] == self.MARKDOWN_BOLD_MARKER:
                            in_bold = not in_bold
                        if text[:2] == self.MARKDOWN_ITALICS_MARKER:
                            in_italics = not in_italics
                        if text[:2] == self.MARKDOWN_STRIKETHROUGH_MARKER:
                            in_strikethrough = not in_strikethrough
                        if text[:2] == self.MARKDOWN_UNDERLINE_MARKER:
                            in_underline = not in_underline
                        text = text[2:]
                        continue
                num_escape_chars = (
                    num_escape_chars + 1
                    if text[0] == self.MARKDOWN_ESCAPE_CHARACTER
                    else 0
                )
                is_link = self.MARKDOWN_LINK_REGEX.match(text)
                if is_link:
                    link_text, link_dest, text = is_link.groups()
                    if txt_frag:
                        yield frag()
                    gstate = self._get_current_graphics_state()
                    gstate[&#34;underline&#34;] = self.MARKDOWN_LINK_UNDERLINE
                    if self.MARKDOWN_LINK_COLOR:
                        gstate[&#34;text_color&#34;] = self.MARKDOWN_LINK_COLOR
                    try:
                        page = int(link_dest)
                        link_dest = self.add_link(page=page)
                    except ValueError:
                        pass
                    yield Fragment(
                        list(link_text),
                        gstate,
                        self.k,
                        link=link_dest,
                    )
                    continue
            if self.is_ttf_font and text[0] != &#34;\n&#34; and not ord(text[0]) in font_glyphs:
                style = (&#34;B&#34; if in_bold else &#34;&#34;) + (&#34;I&#34; if in_italics else &#34;&#34;)
                fallback_font = self.get_fallback_font(text[0], style)
                if fallback_font:
                    if fallback_font == current_fallback_font:
                        txt_frag.append(text[0])
                        text = text[1:]
                        continue
                    if txt_frag:
                        yield frag()
                    current_fallback_font = fallback_font
                    txt_frag.append(text[0])
                    text = text[1:]
                    continue
            if current_fallback_font:
                if txt_frag:
                    yield frag()
                current_fallback_font = None
            txt_frag.append(text[0])
            text = text[1:]
        if txt_frag:
            yield frag()

    def will_page_break(self, height):
        &#34;&#34;&#34;
        Let you know if adding an element will trigger a page break,
        based on its height and the current ordinate (`y` position).

        Args:
            height (float): height of the section that would be added, e.g. a cell

        Returns: a boolean indicating if a page break would occur
        &#34;&#34;&#34;
        return (
            self.y + height &gt; self.page_break_trigger
            and not self.in_footer
            and self.accept_page_break
        )

    def _perform_page_break_if_need_be(self, h):
        if self.will_page_break(h):
            LOGGER.debug(
                &#34;Page break on page %d at y=%d for element of height %d &gt; %d&#34;,
                self.page,
                self.y,
                h,
                self.page_break_trigger,
            )
            self._perform_page_break()
            return True
        return False

    def _perform_page_break(self):
        # Defensive check, this should have tested by a previous call to .will_page_break():
        if not self.accept_page_break or self.in_footer:
            return
        x = self.x
        # If we are in a .local_context(), we need to temporarily leave it,
        # by popping out every GraphicsState:
        gs_stack = []
        while self._is_current_graphics_state_nested():
            gs_stack.append(self._get_current_graphics_state())
            self._pop_local_stack()
            # This code assumes that every Graphics State in the stack
            # has been pushed in it while adding a &#34;q&#34; in the PDF stream
            # (which is what FPDF.local_context() does):
            self._end_local_context()
        # Using a temporary GS to render header &amp; footer:
        self.current_font_is_set_on_page = False
        self._push_local_stack()
        self.add_page(same=True)
        self._pop_local_stack()
        for prev_gs in reversed(gs_stack):
            self._push_local_stack()
            prev_gs[&#34;current_font_is_set_on_page&#34;] = False
            self._start_local_context(**prev_gs)
        self.x = x  # restore x but not y after drawing header

    def _has_next_page(self):
        return self.pages_count &gt; self.page

    @contextmanager
    def _disable_writing(self):
        if not isinstance(self._out, types.MethodType):
            # This mean that self._out has already been redefined.
            # This is the case of a nested call to this method: we do nothing
            yield
            return
        self._out = lambda *args, **kwargs: None
        prev_page, prev_pages_count, prev_x, prev_y = (
            self.page,
            self.pages_count,
            self.x,
            self.y,
        )
        annots = PDFArray(self.pages[self.page].annots)
        self._push_local_stack()
        try:
            yield
        finally:
            self._pop_local_stack()
            # restore location:
            for p in range(prev_pages_count + 1, self.pages_count + 1):
                del self.pages[p]
            self.page = prev_page
            self.pages[self.page].annots = annots
            self.set_xy(prev_x, prev_y)
            # restore writing function:
            del self._out

    @check_page
    @support_deprecated_txt_arg
    def multi_cell(
        self,
        w,
        h=None,
        text=&#34;&#34;,
        border=0,
        align=Align.J,
        fill=False,
        split_only=False,  # DEPRECATED
        link=&#34;&#34;,
        ln=&#34;DEPRECATED&#34;,
        max_line_height=None,
        markdown=False,
        print_sh=False,
        new_x=XPos.RIGHT,
        new_y=YPos.NEXT,
        wrapmode: WrapMode = WrapMode.WORD,
        dry_run=False,
        output=MethodReturnValue.PAGE_BREAK,
        center=False,
        padding=0,
    ):
        &#34;&#34;&#34;
        This method allows printing text with line breaks. They can be automatic
        (breaking at the most recent space or soft-hyphen character) as soon as the text
        reaches the right border of the cell, or explicit (via the `\\n` character).
        As many cells as necessary are stacked, one below the other.
        Text can be aligned, centered or justified. The cell block can be framed and
        the background painted. A cell has an horizontal padding, on the left &amp; right sides,
        defined by the.c_margin property.

        Args:
            w (float): cell width. If 0, they extend up to the right margin of the page.
            h (float): height of a single line of text.  Default value: None, meaning to use the current font size.
            text (str): string to print.
            border: Indicates if borders must be drawn around the cell.
                The value can be either a number (`0`: no border ; `1`: frame)
                or a string containing some or all of the following characters
                (in any order):
                `L`: left ; `T`: top ; `R`: right ; `B`: bottom. Default value: 0.
            align (fpdf.enums.Align, str): Set text alignment inside the cell.
                Possible values are:
                `J`: justify (default value); `L` or empty string: left align;
                `C`: center; `X`: center around current x position; `R`: right align
            fill (bool): Indicates if the cell background must be painted (`True`)
                or transparent (`False`). Default value: False.
            split_only (bool): **DEPRECATED since 2.7.4**:
                Use `dry_run=True` and `output=(&#34;LINES&#34;,)` instead.
            link (str): optional link to add on the cell, internal
                (identifier returned by `add_link`) or external URL.
            new_x (fpdf.enums.XPos, str): New current position in x after the call. Default: RIGHT
            new_y (fpdf.enums.YPos, str): New current position in y after the call. Default: NEXT
            ln (int): **DEPRECATED since 2.5.1**: Use `new_x` and `new_y` instead.
            max_line_height (float): optional maximum height of each sub-cell generated
            markdown (bool): enable minimal markdown-like markup to render part
                of text as bold / italics / strikethrough / underlined.
                Supports `\\` as escape character. Default to False.
            print_sh (bool): Treat a soft-hyphen (\\u00ad) as a normal printable
                character, instead of a line breaking opportunity. Default value: False
            wrapmode (fpdf.enums.WrapMode): &#34;WORD&#34; for word based line wrapping (default),
                &#34;CHAR&#34; for character based line wrapping.
            dry_run (bool): if `True`, does not output anything in the document.
                Can be useful when combined with `output`.
            output (fpdf.enums.MethodReturnValue): defines what this method returns.
                If several enum values are joined, the result will be a tuple.
            txt (str): [**DEPRECATED since v2.7.6**] string to print.
            center (bool): center the cell horizontally on the page.
            padding (float or Sequence): padding to apply around the text. Default value: 0.
                When one value is specified, it applies the same padding to all four sides.
                When two values are specified, the first padding applies to the top and bottom, the second to
                the left and right. When three values are specified, the first padding applies to the top,
                the second to the right and left, the third to the bottom. When four values are specified,
                the paddings apply to the top, right, bottom, and left in that order (clockwise)
                If padding for left or right ends up being non-zero then respective c_margin is ignored.

        Center overrides values for horizontal padding

        Using `new_x=XPos.RIGHT, new_y=XPos.TOP, maximum height=pdf.font_size` is
        useful to build tables with multiline text in cells.

        Returns: a single value or a tuple, depending on the `output` parameter value
        &#34;&#34;&#34;

        padding = Padding.new(padding)
        wrapmode = WrapMode.coerce(wrapmode)

        if split_only:
            warnings.warn(
                (
                    &#39;The parameter &#34;split_only&#34; is deprecated since v2.7.4.&#39;
                    &#39; Use instead dry_run=True and output=&#34;LINES&#34;.&#39;
                ),
                DeprecationWarning,
                stacklevel=get_stack_level(),
            )
        if dry_run or split_only:
            with self._disable_writing():
                return self.multi_cell(
                    w=w,
                    h=h,
                    text=text,
                    border=border,
                    align=align,
                    fill=fill,
                    link=link,
                    ln=ln,
                    max_line_height=max_line_height,
                    markdown=markdown,
                    print_sh=print_sh,
                    new_x=new_x,
                    new_y=new_y,
                    wrapmode=wrapmode,
                    dry_run=False,
                    split_only=False,
                    output=MethodReturnValue.LINES if split_only else output,
                    center=center,
                    padding=padding,
                )
        if not self.font_family:
            raise FPDFException(&#34;No font set, you need to call set_font() beforehand&#34;)
        if isinstance(w, str) or isinstance(h, str):
            raise ValueError(
                &#34;Parameter &#39;w&#39; and &#39;h&#39; must be numbers, not strings.&#34;
                &#34; You can omit them by passing string content with text=&#34;
            )
        new_x = XPos.coerce(new_x)
        new_y = YPos.coerce(new_y)
        if ln != &#34;DEPRECATED&#34;:
            # For backwards compatibility, if &#34;ln&#34; is used we overwrite &#34;new_[xy]&#34;.
            if ln == 0:
                new_x = XPos.RIGHT
                new_y = YPos.NEXT
            elif ln == 1:
                new_x = XPos.LMARGIN
                new_y = YPos.NEXT
            elif ln == 2:
                new_x = XPos.LEFT
                new_y = YPos.NEXT
            elif ln == 3:
                new_x = XPos.RIGHT
                new_y = YPos.TOP
            else:
                raise ValueError(
                    f&#39;Invalid value for parameter &#34;ln&#34; ({ln}),&#39;
                    &#34; must be an int between 0 and 3.&#34;
                )
            warnings.warn(
                (
                    &#39;The parameter &#34;ln&#34; is deprecated since v2.5.2.&#39;
                    f&#34; Instead of ln={ln} use new_x=XPos.{new_x.name}, new_y=YPos.{new_y.name}.&#34;
                ),
                DeprecationWarning,
                stacklevel=get_stack_level(),
            )
        align = Align.coerce(align)

        page_break_triggered = False

        if h is None:
            h = self.font_size

        # If width is 0, set width to available width between margins
        if w == 0:
            w = self.w - self.r_margin - self.x

        # Store the starting position before applying padding
        prev_x, prev_y = self.x, self.y

        # Apply padding to contents
        # decrease maximum allowed width by padding
        # shift the starting point by padding
        maximum_allowed_width = w = w - padding.right - padding.left
        clearance_margins = []
        # If we don&#39;t have padding on either side, we need a clearance margin.
        if not padding.left:
            clearance_margins.append(self.c_margin)
        if not padding.right:
            clearance_margins.append(self.c_margin)
        if align != Align.X:
            self.x += padding.left
        self.y += padding.top

        # Center overrides padding
        if center:
            self.x = (
                self.w / 2 if align == Align.X else self.l_margin + (self.epw - w) / 2
            )
            prev_x = self.x

        # Calculate text length
        text = self.normalize_text(text)
        normalized_string = text.replace(&#34;\r&#34;, &#34;&#34;)
        styled_text_fragments = (
            self._preload_bidirectional_text(normalized_string, markdown)
            if self.text_shaping
            else self._preload_font_styles(normalized_string, markdown)
        )

        prev_current_font = self.current_font
        prev_font_style = self.font_style
        prev_underline = self.underline
        total_height = 0

        text_lines = []
        multi_line_break = MultiLineBreak(
            styled_text_fragments,
            maximum_allowed_width,
            clearance_margins,
            align=align,
            print_sh=print_sh,
            wrapmode=wrapmode,
        )
        text_line = multi_line_break.get_line()
        while (text_line) is not None:
            text_lines.append(text_line)
            text_line = multi_line_break.get_line()

        if not text_lines:  # ensure we display at least one cell - cf. issue #349
            text_lines = [
                TextLine(
                    &#34;&#34;,
                    text_width=0,
                    number_of_spaces=0,
                    align=align,
                    height=h,
                    max_width=w,
                    trailing_nl=False,
                )
            ]

        if max_line_height is None or len(text_lines) == 1:
            line_height = h
        else:
            line_height = min(h, max_line_height)

        box_required = fill or border
        page_break_triggered = False

        for text_line_index, text_line in enumerate(text_lines):
            start_of_new_page = self._perform_page_break_if_need_be(h + padding.bottom)
            if start_of_new_page:
                page_break_triggered = True
                self.y += padding.top

            if box_required and (text_line_index == 0 or start_of_new_page):
                # estimate how many cells can fit on this page
                top_gap = self.y  # Top padding has already been added
                bottom_gap = padding.bottom + self.b_margin
                lines_before_break = int((self.h - top_gap - bottom_gap) // line_height)
                # check how many cells should be rendered
                num_lines = min(lines_before_break, len(text_lines) - text_line_index)
                box_height = max(
                    h - text_line_index * line_height, num_lines * line_height
                )
                # render the box
                x = self.x - (w / 2 if align == Align.X else 0)
                draw_box_borders(
                    self,
                    x - padding.left,
                    self.y - padding.top,
                    x + w + padding.right,
                    self.y + box_height + padding.bottom,
                    border,
                    self.fill_color if fill else None,
                )
            is_last_line = text_line_index == len(text_lines) - 1
            self._render_styled_text_line(
                text_line,
                h=line_height,
                new_x=new_x if is_last_line else XPos.LEFT,
                new_y=new_y if is_last_line else YPos.NEXT,
                border=0,  # already rendered
                fill=False,  # already rendered
                link=link,
                padding=Padding(0, padding.right, 0, padding.left),
                prevent_font_change=markdown,
            )
            total_height += line_height
            if not is_last_line and align == Align.X:
                # prevent cumulative shift to the left
                self.x = prev_x

        if total_height &lt; h:
            # Move to the bottom of the multi_cell
            if new_y == YPos.NEXT:
                self.y += h - total_height
            total_height = h

        if page_break_triggered and new_y == YPos.TOP:
            # When a page jump is performed and the requested y is TOP,
            # pretend we started at the top of the text block on the new page.
            # cf. test_multi_cell_table_with_automatic_page_break
            prev_y = self.y

        last_line = text_lines[-1]
        if last_line and last_line.trailing_nl and new_y in (YPos.LAST, YPos.NEXT):
            # The line renderer can&#39;t handle trailing newlines in the text.
            self.ln()

        if new_y == YPos.TOP:  # We may have jumped a few lines -&gt; reset
            self.y = prev_y
        elif new_y == YPos.NEXT:  # move down by bottom padding
            self.y += padding.bottom

        if markdown:
            self.font_style = prev_font_style
            self.current_font = prev_current_font
            self.underline = prev_underline

        if new_x == XPos.RIGHT:  # move right by right padding to align outer RHS edge
            self.x += padding.right
        elif new_x == XPos.LEFT:  # move left by left padding to align outer LHS edge
            self.x -= padding.left

        output = MethodReturnValue.coerce(output)
        return_value = ()
        if output &amp; MethodReturnValue.PAGE_BREAK:
            return_value += (page_break_triggered,)
        if output &amp; MethodReturnValue.LINES:
            output_lines = []
            for text_line in text_lines:
                characters = []
                for frag in text_line.fragments:
                    characters.extend(frag.characters)
                output_lines.append(&#34;&#34;.join(characters))
            return_value += (output_lines,)
        if output &amp; MethodReturnValue.HEIGHT:
            return_value += (total_height + padding.top + padding.bottom,)
        if len(return_value) == 1:
            return return_value[0]
        return return_value

    @check_page
    @support_deprecated_txt_arg
    def write(
        self,
        h: float = None,
        text: str = &#34;&#34;,
        link: str = &#34;&#34;,
        print_sh: bool = False,
        wrapmode: WrapMode = WrapMode.WORD,
    ):
        &#34;&#34;&#34;
        Prints text from the current position.
        When the right margin is reached, a line break occurs at the most recent
        space or soft-hyphen character, and text continues from the left margin.
        A manual break happens any time the \\n character is met,
        Upon method exit, the current position is left just at the end of the text.

        Args:
            h (float): line height. Default value: None, meaning to use the current font size.
            text (str): text content
            link (str): optional link to add on the text, internal
                (identifier returned by `FPDF.add_link`) or external URL.
            print_sh (bool): Treat a soft-hyphen (\\u00ad) as a normal printable
                character, instead of a line breaking opportunity. Default value: False
            wrapmode (fpdf.enums.WrapMode): &#34;WORD&#34; for word based line wrapping (default),
                &#34;CHAR&#34; for character based line wrapping.
            txt (str): [**DEPRECATED since v2.7.6**] text content
        &#34;&#34;&#34;
        wrapmode = WrapMode.coerce(wrapmode)
        if not self.font_family:
            raise FPDFException(&#34;No font set, you need to call set_font() beforehand&#34;)
        if isinstance(h, str):
            raise ValueError(
                &#34;Parameter &#39;h&#39; must be a number, not a string.&#34;
                &#34; You can omit it by passing string content with text=&#34;
            )
        if h is None:
            h = self.font_size

        page_break_triggered = False
        normalized_string = self.normalize_text(text).replace(&#34;\r&#34;, &#34;&#34;)
        styled_text_fragments = (
            self._preload_bidirectional_text(normalized_string, False)
            if self.text_shaping
            else self._preload_font_styles(normalized_string, False)
        )

        text_lines = []
        multi_line_break = MultiLineBreak(
            styled_text_fragments,
            lambda h: max_width,
            (self.c_margin, self.c_margin),
            print_sh=print_sh,
            wrapmode=wrapmode,
        )
        # first line from current x position to right margin
        first_width = self.w - self.x - self.r_margin
        max_width = first_width
        text_line = multi_line_break.get_line()
        # remaining lines fill between margins
        full_width = self.w - self.l_margin - self.r_margin
        max_width = full_width
        while (text_line) is not None:
            text_lines.append(text_line)
            text_line = multi_line_break.get_line()
        if not text_lines:
            return False

        for text_line_index, text_line in enumerate(text_lines):
            if text_line_index &gt; 0:
                self.ln()
            new_page = self._render_styled_text_line(
                text_line,
                h=h,
                border=0,
                new_x=XPos.WCONT,
                new_y=YPos.TOP,
                fill=False,
                link=link,
            )
            page_break_triggered = page_break_triggered or new_page
        if text_line.trailing_nl:
            # The line renderer can&#39;t handle trailing newlines in the text.
            self.ln()
        return page_break_triggered

    @check_page
    def text_columns(
        self,
        text: Optional[str] = None,
        img: Optional[str] = None,
        img_fill_width: bool = False,
        ncols: int = 1,
        gutter: float = 10,
        balance: bool = False,
        text_align: Union[Align, str] = &#34;LEFT&#34;,
        line_height: float = 1,
        l_margin: float = None,
        r_margin: float = None,
        print_sh: bool = False,
        wrapmode: WrapMode = WrapMode.WORD,
        skip_leading_spaces: bool = False,
    ):
        &#34;&#34;&#34;Establish a layout with multiple columns to fill with text.
        Args:
            text (str, optional): A first piece of text to insert.
            ncols (int, optional): the number of columns to create. (Default: 1).
            gutter (float, optional): The distance between the columns. (Default: 10).
            balance: (bool, optional): Specify whether multiple columns should end at approximately
                the same height, if they don&#39;t fill the page. (Default: False)
            text_align (Align or str, optional): The alignment of the text within the region.
                (Default: &#34;LEFT&#34;)
            line_height (float, optional): A multiplier relative to the font size changing the
                vertical space occupied by a line of text. (Default: 1.0).
            l_margin (float, optional): Override the current left page margin.
            r_margin (float, optional): Override the current right page margin.
            print_sh (bool, optional): Treat a soft-hyphen (\\u00ad) as a printable character,
                instead of a line breaking opportunity. (Default: False)
            wrapmode (fpdf.enums.WrapMode, optional): &#34;WORD&#34; for word based line wrapping,
                &#34;CHAR&#34; for character based line wrapping. (Default: &#34;WORD&#34;)
            skip_leading_spaces (bool, optional): On each line, any space characters at the
                beginning will be skipped if True. (Default: False)
        &#34;&#34;&#34;
        return TextColumns(
            self,
            text=text,
            img=img,
            img_fill_width=img_fill_width,
            ncols=ncols,
            gutter=gutter,
            balance=balance,
            text_align=text_align,
            line_height=line_height,
            l_margin=l_margin,
            r_margin=r_margin,
            print_sh=print_sh,
            wrapmode=wrapmode,
            skip_leading_spaces=skip_leading_spaces,
        )

    @check_page
    def image(
        self,
        name,
        x=None,
        y=None,
        w=0,
        h=0,
        type=&#34;&#34;,
        link=&#34;&#34;,
        title=None,
        alt_text=None,
        dims=None,
        keep_aspect_ratio=False,
    ):
        &#34;&#34;&#34;
        Put an image on the page.

        The size of the image on the page can be specified in different ways:
        * explicit width and height (expressed in user units)
        * one explicit dimension, the other being calculated automatically
          in order to keep the original proportions
        * no explicit dimension, in which case the image is put at 72 dpi.
        * explicit width and height (expressed in user units) and `keep_aspect_ratio=True`

        **Remarks**:
        * if an image is used several times, only one copy is embedded in the file.
        * when using an animated GIF, only the first frame is used.

        Args:
            name: either a string representing a file path to an image, an URL to an image,
                bytes, an io.BytesIO, or a instance of `PIL.Image.Image`
            x (float, fpdf.enums.Align): optional horizontal position where to put the image on the page.
                If not specified or equal to None, the current abscissa is used.
                `fpdf.enums.Align.C` can also be passed to center the image horizontally;
                and `fpdf.enums.Align.R` to place it along the right page margin
            y (float): optional vertical position where to put the image on the page.
                If not specified or equal to None, the current ordinate is used.
                After the call, the current ordinate is moved to the bottom of the image
            w (float): optional width of the image. If not specified or equal to zero,
                it is automatically calculated from the image size.
                Pass `pdf.epw` to scale horizontally to the full page width.
            h (float): optional height of the image. If not specified or equal to zero,
                it is automatically calculated from the image size.
                Pass `pdf.eph` to scale horizontally to the full page height.
            type (str): [**DEPRECATED since 2.2.0**] unused, will be removed in a later version.
            link (str): optional link to add on the image, internal
                (identifier returned by `FPDF.add_link`) or external URL.
            title (str): optional. Currently, never seem rendered by PDF readers.
            alt_text (str): optional alternative text describing the image,
                for accessibility purposes. Displayed by some PDF readers on hover.
            dims (Tuple[float]): optional dimensions as a tuple (width, height) to resize the image
                before storing it in the PDF. Note that those are the **intrinsic** image dimensions,
                but the image will still be rendered on the page with the width (`w`) and height (`h`)
                provided as parameters. Note also that the `.oversized_images` attribute of FPDF
                provides an automated way to auto-adjust those intrinsic image dimensions.
            keep_aspect_ratio (bool): ensure the image fits in the rectangle defined by `x`, `y`, `w` &amp; `h`
                while preserving its original aspect ratio. Defaults to False.
                Only meaningful if both `w` &amp; `h` are provided.

        If `y` is provided, this method will not trigger any page break;
        otherwise, auto page break detection will be performed.

        Returns: an instance of a subclass of `ImageInfo`.
        &#34;&#34;&#34;
        if type:
            warnings.warn(
                (
                    &#39;&#34;type&#34; parameter is deprecated since v2.2.0, &#39;
                    &#34;unused and will soon be removed&#34;
                ),
                DeprecationWarning,
                stacklevel=get_stack_level(),
            )

        name, img, info = preload_image(self.image_cache, name, dims)
        if isinstance(info, VectorImageInfo):
            return self._vector_image(
                name, img, info, x, y, w, h, link, title, alt_text, keep_aspect_ratio
            )
        return self._raster_image(
            name,
            img,
            info,
            x,
            y,
            w,
            h,
            link,
            title,
            alt_text,
            dims,
            keep_aspect_ratio,
        )

    def _raster_image(
        self,
        name,
        img,
        info: RasterImageInfo,
        x=None,
        y=None,
        w=0,
        h=0,
        link=&#34;&#34;,
        title=None,
        alt_text=None,
        dims=None,
        keep_aspect_ratio=False,
    ):
        if &#34;smask&#34; in info:
            self._set_min_pdf_version(&#34;1.4&#34;)

        # Automatic width and height calculation if needed
        w, h = info.size_in_document_units(w, h, scale=self.k)

        # Flowing mode
        if y is None:
            self._perform_page_break_if_need_be(h)
            y = self.y
            self.y += h
        if x is None:
            x = self.x

        if not isinstance(x, Number):
            x = self.x_by_align(x, w, h, info, keep_aspect_ratio)
        if keep_aspect_ratio:
            x, y, w, h = info.scale_inside_box(x, y, w, h)
        if self.oversized_images and info[&#34;usages&#34;] == 1 and not dims:
            info = self._downscale_image(name, img, info, w, h, scale=self.k)

        stream_content = stream_content_for_raster_image(
            info, x, y, w, h, keep_aspect_ratio, scale=self.k, pdf_height_to_flip=self.h
        )

        if title or alt_text:
            with self._marked_sequence(title=title, alt_text=alt_text):
                self._out(stream_content)
        else:
            self._out(stream_content)
        if link:
            self.link(x, y, w, h, link)

        self._resource_catalog.add(PDFResourceType.X_OBJECT, info[&#34;i&#34;], self.page)
        return RasterImageInfo(**info, rendered_width=w, rendered_height=h)

    def x_by_align(self, x, w, h, img_info, keep_aspect_ratio):
        if keep_aspect_ratio:
            _, _, w, h = img_info.scale_inside_box(0, 0, w, h)
        x = Align.coerce(x)
        if x == Align.C:
            return (self.w - w) / 2
        if x == Align.R:
            return self.w - w - self.r_margin
        if x == Align.L:
            return self.l_margin
        raise ValueError(f&#34;Unsupported &#39;x&#39; value passed to .image(): {x}&#34;)

    def _vector_image(
        self,
        name,
        svg: SVGObject,
        info: VectorImageInfo,
        x=None,
        y=None,
        w=0,
        h=0,
        link=&#34;&#34;,
        title=None,
        alt_text=None,
        keep_aspect_ratio=False,
    ):
        if not svg.viewbox and svg.width and svg.height:
            warnings.warn(
                &#39;&lt;svg&gt; has no &#34;viewBox&#34;, using its &#34;width&#34; &amp; &#34;height&#34; as default &#34;viewBox&#34;&#39;,
                stacklevel=get_stack_level(),
            )
            svg.viewbox = 0, 0, svg.width, svg.height
        if w == 0 and h == 0:
            if svg.width and svg.height:
                w = (
                    svg.width * self.epw / 100
                    if isinstance(svg.width, Percent)
                    else svg.width
                )
                h = (
                    svg.height * self.eph / 100
                    if isinstance(svg.height, Percent)
                    else svg.height
                )
            elif svg.viewbox:
                _, _, w, h = svg.viewbox
            else:
                svg_id = &#34;&lt;svg&gt;&#34; if isinstance(name, bytes) else name
                raise ValueError(
                    f&#39;{svg_id} has no &#34;viewBox&#34; nor &#34;height&#34; / &#34;width&#34;: w= and h= must be provided to FPDF.image()&#39;
                )
        elif w == 0 or h == 0:
            if svg.width and svg.height:
                svg_width, svg_height = svg.width, svg.height
            elif svg.viewbox:
                _, _, svg_width, svg_height = svg.viewbox
            else:
                raise ValueError(
                    &#39;&lt;svg&gt; has no &#34;viewBox&#34; nor &#34;height&#34; / &#34;width&#34;: w= and h= must be provided to FPDF.image()&#39;
                )
            if w == 0:
                w = h * svg_width / svg_height
            else:  # h == 0
                h = w * svg_height / svg_width

        # Flowing mode
        if y is None:
            self._perform_page_break_if_need_be(h)
            y = self.y
            self.y += h
        if x is None:
            x = self.x

        if keep_aspect_ratio:
            x, y, w, h = info.scale_inside_box(x, y, w, h)
        if not isinstance(x, Number):
            x = self.x_by_align(x, w, h, info, keep_aspect_ratio)

        _, _, path = svg.transform_to_rect_viewport(
            scale=1, width=w, height=h, ignore_svg_top_attrs=True
        )
        path.transform = path.transform @ Transform.translation(x, y)

        old_x, old_y = self.x, self.y
        try:
            self.set_xy(0, 0)
            if title or alt_text:
                # Alt text of vector graphics does NOT show as tool-tip in viewers, but should
                # be processed by screen readers.
                with self._marked_sequence(title=title, alt_text=alt_text):
                    self.draw_path(path)
            else:
                self.draw_path(path)
        finally:
            self.set_xy(old_x, old_y)
        if link:
            self.link(x, y, w, h, link)

        return VectorImageInfo(rendered_width=w, rendered_height=h)

    def _downscale_image(self, name, img, info, w, h, scale):
        images = self.image_cache.images
        width_in_pt, height_in_pt = w * scale, h * scale
        lowres_name = f&#34;lowres-{name}&#34;
        if (
            info[&#34;w&#34;] &gt; width_in_pt * self.oversized_images_ratio
            and info[&#34;h&#34;] &gt; height_in_pt * self.oversized_images_ratio
        ):
            factor = (
                min(info[&#34;w&#34;] / width_in_pt, info[&#34;h&#34;] / height_in_pt)
                / self.oversized_images_ratio
            )
            if self.oversized_images.lower().startswith(&#34;warn&#34;):
                LOGGER.warning(
                    (
                        &#34;OVERSIZED: Image %s with size %.1fx%.1fpx is rendered at size %.1fx%.1fpt.&#34;
                        &#34; Set pdf.oversized_images = &#39;DOWNSCALE&#39; to reduce embedded image size by a factor %.1f&#34;
                    ),
                    name,
                    info[&#34;w&#34;],
                    info[&#34;h&#34;],
                    width_in_pt,
                    height_in_pt,
                    factor,
                )
            elif self.oversized_images.lower() == &#34;downscale&#34;:
                dims = (
                    round(width_in_pt * self.oversized_images_ratio),
                    round(height_in_pt * self.oversized_images_ratio),
                )
                info[&#34;usages&#34;] -= 1  # no need to embed the high-resolution image
                if info[&#34;usages&#34;] == 0:
                    resources_per_page = self._resource_catalog.resources_per_page
                    for (_, rtype), resource in resources_per_page.items():
                        if rtype == PDFResourceType.X_OBJECT and info[&#34;i&#34;] in resource:
                            resource.remove(info[&#34;i&#34;])
                lowres_info = images.get(lowres_name)
                if lowres_info:  # Great, we&#39;ve already done the job!
                    info = lowres_info
                    if info[&#34;w&#34;] * info[&#34;h&#34;] &lt; dims[0] * dims[1]:
                        # The existing low-res image is too small, we need a bigger low-res image:
                        info.update(
                            get_img_info(
                                name,
                                img or load_image(name),
                                self.image_cache.image_filter,
                                dims,
                            )
                        )
                        LOGGER.debug(
                            &#34;OVERSIZED: Updated low-res image with name=%s id=%d to dims=%s&#34;,
                            lowres_name,
                            info[&#34;i&#34;],
                            dims,
                        )
                    info[&#34;usages&#34;] += 1
                else:
                    info = RasterImageInfo(
                        get_img_info(
                            name,
                            img or load_image(name),
                            self.image_cache.image_filter,
                            dims,
                        )
                    )
                    info[&#34;i&#34;] = len(images) + 1
                    info[&#34;usages&#34;] = 1
                    images[lowres_name] = info
                    LOGGER.debug(
                        &#34;OVERSIZED: Generated new low-res image with name=%s dims=%s id=%d&#34;,
                        lowres_name,
                        dims,
                        info[&#34;i&#34;],
                    )
            else:
                raise ValueError(
                    f&#34;Invalid value for attribute .oversized_images: {self.oversized_images}&#34;
                )
        return info

    def preload_image(self, name, dims=None):
        &#34;&#34;&#34;
        Read an image and load it into memory.

        .. deprecated:: 2.7.7
            Use `fpdf.image_parsing.preload_image` instead.
        &#34;&#34;&#34;
        warnings.warn(
            (
                &#34;FPDF.preload_image() is deprecated since v2.7.7 &#34;
                &#34;and will be removed in a future release. &#34;
                &#34;Use `fpdf.image_parsing.preload_image` instead.&#34;
            ),
            DeprecationWarning,
            stacklevel=get_stack_level(),
        )
        return preload_image(self.image_cache, name, dims)

    @contextmanager
    def _marked_sequence(self, **kwargs):
        &#34;&#34;&#34;
        Can receive as named arguments any of the entries described in section 14.7.2 &#39;Structure Hierarchy&#39;
        of the PDF spec: iD, a, c, r, lang, e, actualText
        &#34;&#34;&#34;
        mcid = self.struct_builder.next_mcid_for_page(self.page)
        struct_elem = self._add_marked_content(
            struct_type=&#34;/Figure&#34;, mcid=mcid, **kwargs
        )
        start_page = self.page
        self._out(f&#34;/P &lt;&lt;/MCID {mcid}&gt;&gt; BDC&#34;)
        yield struct_elem
        if self.page != start_page:
            raise FPDFException(&#34;A page jump occurred inside a marked sequence&#34;)
        self._out(&#34;EMC&#34;)

    def _add_marked_content(self, **kwargs):
        &#34;&#34;&#34;
        Can receive as named arguments any of the entries described in section 14.7.2 &#39;Structure Hierarchy&#39;
        of the PDF spec: iD, a, c, r, lang, e, actualText
        &#34;&#34;&#34;
        struct_elem, spid = self.struct_builder.add_marked_content(
            page_number=self.page, **kwargs
        )
        self.pages[self.page].struct_parents = spid
        self._set_min_pdf_version(&#34;1.4&#34;)  # due to using /MarkInfo
        return struct_elem

    @check_page
    def ln(self, h=None):
        &#34;&#34;&#34;
        Line Feed.
        The current abscissa goes back to the left margin and the ordinate increases by
        the amount passed as parameter.

        Args:
            h (float): The height of the break.
                By default, the value equals the height of the last printed text line
                (except when written by `.text()`). If no text has been written yet to
                the document, then the current font height is used.
        &#34;&#34;&#34;
        self.x = self.l_margin
        if h is not None:
            self.y += h
        elif self._lasth:
            self.y += self._lasth
        else:
            self.y += self.font_size

    def get_x(self):
        &#34;&#34;&#34;Returns the abscissa of the current position.&#34;&#34;&#34;
        return self.x

    def set_x(self, x):
        &#34;&#34;&#34;
        Defines the abscissa of the current position.
        If the value provided is negative, it is relative to the right of the page.

        Args:
            x (float): the new current abscissa
        &#34;&#34;&#34;
        self.x = x if x &gt;= 0 else self.w + x

    def get_y(self):
        &#34;&#34;&#34;Returns the ordinate of the current position.&#34;&#34;&#34;
        if self._in_unbreakable:
            raise FPDFException(
                &#34;Using get_y() inside an unbreakable() code block is error-prone&#34;
            )
        return self.y

    def set_y(self, y):
        &#34;&#34;&#34;
        Moves the current abscissa back to the left margin and sets the ordinate.
        If the value provided is negative, it is relative to the bottom of the page.

        Args:
            y (float): the new current ordinate
        &#34;&#34;&#34;
        self.x = self.l_margin
        self.y = y if y &gt;= 0 else self.h + y

    def set_xy(self, x, y):
        &#34;&#34;&#34;
        Defines the abscissa and ordinate of the current position.
        If the values provided are negative, they are relative respectively to the right and bottom of the page.

        Args:
            x (float): the new current abscissa
            y (float): the new current ordinate
        &#34;&#34;&#34;
        self.set_y(y)
        self.set_x(x)

    def normalize_text(self, text):
        &#34;&#34;&#34;Check that text input is in the correct format/encoding&#34;&#34;&#34;
        # - for TTF unicode fonts: unicode object (utf8 encoding)
        # - for built-in fonts: string instances (encoding: latin-1, cp1252)
        if not self.is_ttf_font and self.core_fonts_encoding:
            try:
                return text.encode(self.core_fonts_encoding).decode(&#34;latin-1&#34;)
            except UnicodeEncodeError as error:
                raise FPDFUnicodeEncodingException(
                    text_index=error.start,
                    character=text[error.start],
                    font_name=self.font_family + self.font_style,
                ) from error
        return text

    def sign_pkcs12(
        self,
        pkcs_filepath,
        password=None,
        hashalgo=&#34;sha256&#34;,
        contact_info=None,
        location=None,
        signing_time=None,
        reason=None,
        flags=(AnnotationFlag.PRINT, AnnotationFlag.LOCKED),
    ):
        &#34;&#34;&#34;
        Args:
            pkcs_filepath (str): file path to a .pfx or .p12 PKCS12,
                in the binary format described by RFC 7292
            password (bytes-like): the password to use to decrypt the data.
                `None` if the PKCS12 is not encrypted.
            hashalgo (str): hashing algorithm used, passed to `hashlib.new`
            contact_info (str): optional information provided by the signer to enable
                a recipient to contact the signer to verify the signature
            location (str): optional CPU host name or physical location of the signing
            signing_time (datetime): optional time of signing
            reason (str): optional signing reason
            flags (Tuple[fpdf.enums.AnnotationFlag], Tuple[str]): optional list of flags defining annotation properties
        &#34;&#34;&#34;
        if not signer:
            raise EnvironmentError(
                &#34;endesive.signer not available - PDF cannot be signed - Try: pip install endesive&#34;
            )
        with open(pkcs_filepath, &#34;rb&#34;) as pkcs_file:
            key, cert, extra_certs = pkcs12.load_key_and_certificates(
                pkcs_file.read(), password
            )
        self.sign(
            key=key,
            cert=cert,
            extra_certs=extra_certs,
            hashalgo=hashalgo,
            contact_info=contact_info,
            location=location,
            signing_time=signing_time,
            reason=reason,
            flags=flags,
        )

    @check_page
    def sign(
        self,
        key,
        cert,
        extra_certs=(),
        hashalgo=&#34;sha256&#34;,
        contact_info=None,
        location=None,
        signing_time=None,
        reason=None,
        flags=(AnnotationFlag.PRINT, AnnotationFlag.LOCKED),
    ):
        &#34;&#34;&#34;
        Args:
            key: certificate private key
            cert (cryptography.x509.Certificate): certificate
            extra_certs (list[cryptography.x509.Certificate]): list of additional PKCS12 certificates
            hashalgo (str): hashing algorithm used, passed to `hashlib.new`
            contact_info (str): optional information provided by the signer to enable
                a recipient to contact the signer to verify the signature
            location (str): optional CPU host name or physical location of the signing
            signing_time (datetime): optional time of signing
            reason (str): optional signing reason
            flags (Tuple[fpdf.enums.AnnotationFlag], Tuple[str]): optional list of flags defining annotation properties
        &#34;&#34;&#34;
        if not signer:
            raise EnvironmentError(
                &#34;endesive.signer not available - PDF cannot be signed - Try: pip install endesive&#34;
            )
        if self._sign_key:
            raise FPDFException(&#34;.sign* methods should be called only once&#34;)

        self._sign_key = key
        self._sign_cert = cert
        self._sign_extra_certs = extra_certs
        self._sign_hashalgo = hashalgo
        self._sign_time = signing_time or self.creation_date

        annotation = PDFAnnotation(
            &#34;Widget&#34;,
            field_type=&#34;Sig&#34;,
            x=0,
            y=0,
            width=0,
            height=0,
            flags=flags,
            title=&#34;signature&#34;,
            value=Signature(
                contact_info=contact_info,
                location=location,
                m=PDFDate(self._sign_time),
                reason=reason,
            ),
        )
        self.pages[self.page].annots.append(annotation)

    def _insert_table_of_contents(self):
        # Doc has been closed but we want to write to self.pages[self.page] instead of self.buffer:
        tocp = self.toc_placeholder
        prev_page, prev_y = self.page, self.y
        self.page, self.y = tocp.start_page, tocp.y
        # flag rendering ToC for page breaking function
        self.in_toc_rendering = True
        self._set_orientation(tocp.page_orientation, self.dw_pt, self.dh_pt)
        tocp.render_function(self, self._outline)
        self.in_toc_rendering = False  # set ToC rendering flag off
        expected_final_page = tocp.start_page + tocp.pages - 1
        if self.page != expected_final_page and not self._toc_allow_page_insertion:
            too = &#34;many&#34; if self.page &gt; expected_final_page else &#34;few&#34;
            error_msg = f&#34;The rendering function passed to FPDF.insert_toc_placeholder triggered too {too} page breaks: &#34;
            error_msg += f&#34;ToC ended on page {self.page} while it was expected to span exactly {tocp.pages} pages&#34;
            raise FPDFException(error_msg)
        if self._toc_inserted_pages:
            # Generating final page footer after more pages were inserted:
            self._render_footer()
            # We need to reorder the pages, because some new pages have been inserted in the ToC,
            # but they have been inserted at the end of self.pages:
            new_pages = [
                self.pages.pop(len(self.pages)) for _ in range(self._toc_inserted_pages)
            ]
            new_pages = list(reversed(new_pages))
            indices_remap = {}
            for page_index in range(
                tocp.start_page + 1, self.pages_count + len(new_pages) + 1
            ):
                if page_index in self.pages:
                    new_pages.append(self.pages.pop(page_index))
                page = self.pages[page_index] = new_pages.pop(0)
                # Fix page indices:
                indices_remap[page.index()] = page_index
                page.set_index(page_index)
                # Fix page labels:
                if tocp.reset_page_indices is False:
                    page.get_page_label().st = page_index
            assert len(new_pages) == 0, f&#34;#new_pages: {len(new_pages)}&#34;
            # Fix outline:
            for section in self._outline:
                new_index = indices_remap.get(section.page_number)
                if new_index is not None:
                    section.dest = section.dest.replace(page=new_index)
                    section.page_number = new_index
                    if section.struct_elem:
                        # pylint: disable=protected-access
                        section.struct_elem._page_number = new_index
            # Fix resource catalog:
            resources_per_page = self._resource_catalog.resources_per_page
            new_resources_per_page = defaultdict(set)
            for (page_number, resource_type), resource in resources_per_page.items():
                key = (indices_remap.get(page_number, page_number), resource_type)
                new_resources_per_page[key] = resource
            self._resource_catalog.resources_per_page = new_resources_per_page
        self.page, self.y = prev_page, prev_y

    def file_id(self):  # pylint: disable=no-self-use
        &#34;&#34;&#34;
        This method can be overridden in inherited classes
        in order to define a custom file identifier.
        Its output must have the format &#34;&lt;hex_string1&gt;&lt;hex_string2&gt;&#34;.
        If this method returns a falsy value (None, empty string),
        no /ID will be inserted in the generated PDF document.
        &#34;&#34;&#34;
        return -1

    def _default_file_id(self, buffer):
        # Quoting the PDF 1.7 spec, section 14.4 File Identifiers:
        # &gt; The value of this entry shall be an array of two byte strings.
        # &gt; The first byte string shall be a permanent identifier
        # &gt; based on the contents of the file at the time it was originally created
        # &gt; and shall not change when the file is incrementally updated.
        # &gt; The second byte string shall be a changing identifier
        # &gt; based on the file’s contents at the time it was last updated.
        # &gt; When a file is first written, both identifiers shall be set to the same value.
        id_hash = hashlib.new(&#34;md5&#34;, usedforsecurity=False)  # nosec B324
        id_hash.update(buffer)
        if self.creation_date:
            id_hash.update(self.creation_date.strftime(&#34;%Y%m%d%H%M%S&#34;).encode(&#34;utf8&#34;))
        hash_hex = id_hash.hexdigest().upper()
        return f&#34;&lt;{hash_hex}&gt;&lt;{hash_hex}&gt;&#34;

    def _do_underline(self, x, y, w, font=None):
        &#34;&#34;&#34;
        Draw an horizontal line under some text,
        starting from (x, y) with a length equal to &#39;w&#39;
        &#34;&#34;&#34;
        if font is None:
            font = self.current_font
        return (
            f&#34;{x * self.k:.2f} &#34;
            f&#34;{(self.h - y + font.up / 1000 * self.font_size) * self.k:.2f} &#34;
            f&#34;{w * self.k:.2f} &#34;
            f&#34;{-font.ut / 1000 * self.font_size_pt:.2f} re f&#34;
        )

    def _do_strikethrough(self, x, y, w, font=None):
        &#34;&#34;&#34;
        Draw an horizontal line through some text,
        starting from (x, y) with a length equal to &#39;w&#39;
        &#34;&#34;&#34;
        if font is None:
            font = self.current_font
        return (
            f&#34;{x * self.k:.2f} &#34;
            f&#34;{(self.h - y + font.sp / 1000 * self.font_size) * self.k:.2f} &#34;
            f&#34;{w * self.k:.2f} &#34;
            f&#34;{-font.ss / 1000 * self.font_size_pt:.2f} re f&#34;
        )

    def _out(self, s):
        if self.buffer:
            raise FPDFException(
                &#34;Content cannot be added on a finalized document, after calling output()&#34;
            )
        if not isinstance(s, bytes):
            if not isinstance(s, str):
                s = str(s)
            s = s.encode(&#34;latin1&#34;)
        if not self.page:
            raise FPDFException(&#34;No page open, you need to call add_page() first&#34;)
        self.pages[self.page].contents += s + b&#34;\n&#34;

    @check_page
    @support_deprecated_txt_arg
    def interleaved2of5(self, text, x, y, w=1, h=10):
        &#34;&#34;&#34;Barcode I2of5 (numeric), adds a 0 if odd length&#34;&#34;&#34;
        narrow = w / 3
        wide = w

        # wide/narrow codes for the digits
        bar_char = {
            &#34;0&#34;: &#34;nnwwn&#34;,
            &#34;1&#34;: &#34;wnnnw&#34;,
            &#34;2&#34;: &#34;nwnnw&#34;,
            &#34;3&#34;: &#34;wwnnn&#34;,
            &#34;4&#34;: &#34;nnwnw&#34;,
            &#34;5&#34;: &#34;wnwnn&#34;,
            &#34;6&#34;: &#34;nwwnn&#34;,
            &#34;7&#34;: &#34;nnnww&#34;,
            &#34;8&#34;: &#34;wnnwn&#34;,
            &#34;9&#34;: &#34;nwnwn&#34;,
            &#34;A&#34;: &#34;nn&#34;,
            &#34;Z&#34;: &#34;wn&#34;,
        }
        # The caller should do this, or we can&#39;t rotate the thing.
        # self.set_fill_color(0)
        code = text
        # add leading zero if code-length is odd
        if len(code) % 2 != 0:
            code = f&#34;0{code}&#34;

        # add start and stop codes
        code = f&#34;AA{code.lower()}ZA&#34;

        for i in range(0, len(code), 2):
            # choose next pair of digits
            char_bar = code[i]
            char_space = code[i + 1]
            # check whether it is a valid digit
            if char_bar not in bar_char:
                raise RuntimeError(f&#39;Char &#34;{char_bar}&#34; invalid for I25:&#39;)
            if char_space not in bar_char:
                raise RuntimeError(f&#39;Char &#34;{char_space}&#34; invalid for I25: &#39;)

            # create a wide/narrow-seq (first digit=bars, second digit=spaces)
            seq = &#34;&#34;.join(
                f&#34;{cb}{cs}&#34; for cb, cs in zip(bar_char[char_bar], bar_char[char_space])
            )

            for bar_index, char in enumerate(seq):
                # set line_width depending on value
                line_width = narrow if char == &#34;n&#34; else wide

                # draw every second value, the other is represented by space
                if bar_index % 2 == 0:
                    self.rect(x, y, line_width, h, &#34;F&#34;)

                x += line_width

    @check_page
    @support_deprecated_txt_arg
    def code39(self, text, x, y, w=1.5, h=5):
        &#34;&#34;&#34;Barcode 3of9&#34;&#34;&#34;
        dim = {&#34;w&#34;: w, &#34;n&#34;: w / 3}
        if not text.startswith(&#34;*&#34;) or not text.endswith(&#34;*&#34;):
            warnings.warn(
                (
                    &#34;Code 39 input must start and end with a &#39;*&#39; character to be valid.&#34;
                    &#34; This method does not insert it automatically.&#34;
                ),
                stacklevel=get_stack_level(),
            )
        chars = {
            &#34;0&#34;: &#34;nnnwwnwnn&#34;,
            &#34;1&#34;: &#34;wnnwnnnnw&#34;,
            &#34;2&#34;: &#34;nnwwnnnnw&#34;,
            &#34;3&#34;: &#34;wnwwnnnnn&#34;,
            &#34;4&#34;: &#34;nnnwwnnnw&#34;,
            &#34;5&#34;: &#34;wnnwwnnnn&#34;,
            &#34;6&#34;: &#34;nnwwwnnnn&#34;,
            &#34;7&#34;: &#34;nnnwnnwnw&#34;,
            &#34;8&#34;: &#34;wnnwnnwnn&#34;,
            &#34;9&#34;: &#34;nnwwnnwnn&#34;,
            &#34;A&#34;: &#34;wnnnnwnnw&#34;,
            &#34;B&#34;: &#34;nnwnnwnnw&#34;,
            &#34;C&#34;: &#34;wnwnnwnnn&#34;,
            &#34;D&#34;: &#34;nnnnwwnnw&#34;,
            &#34;E&#34;: &#34;wnnnwwnnn&#34;,
            &#34;F&#34;: &#34;nnwnwwnnn&#34;,
            &#34;G&#34;: &#34;nnnnnwwnw&#34;,
            &#34;H&#34;: &#34;wnnnnwwnn&#34;,
            &#34;I&#34;: &#34;nnwnnwwnn&#34;,
            &#34;J&#34;: &#34;nnnnwwwnn&#34;,
            &#34;K&#34;: &#34;wnnnnnnww&#34;,
            &#34;L&#34;: &#34;nnwnnnnww&#34;,
            &#34;M&#34;: &#34;wnwnnnnwn&#34;,
            &#34;N&#34;: &#34;nnnnwnnww&#34;,
            &#34;O&#34;: &#34;wnnnwnnwn&#34;,
            &#34;P&#34;: &#34;nnwnwnnwn&#34;,
            &#34;Q&#34;: &#34;nnnnnnwww&#34;,
            &#34;R&#34;: &#34;wnnnnnwwn&#34;,
            &#34;S&#34;: &#34;nnwnnnwwn&#34;,
            &#34;T&#34;: &#34;nnnnwnwwn&#34;,
            &#34;U&#34;: &#34;wwnnnnnnw&#34;,
            &#34;V&#34;: &#34;nwwnnnnnw&#34;,
            &#34;W&#34;: &#34;wwwnnnnnn&#34;,
            &#34;X&#34;: &#34;nwnnwnnnw&#34;,
            &#34;Y&#34;: &#34;wwnnwnnnn&#34;,
            &#34;Z&#34;: &#34;nwwnwnnnn&#34;,
            &#34;-&#34;: &#34;nwnnnnwnw&#34;,
            &#34;.&#34;: &#34;wwnnnnwnn&#34;,
            &#34; &#34;: &#34;nwwnnnwnn&#34;,
            &#34;*&#34;: &#34;nwnnwnwnn&#34;,
            &#34;$&#34;: &#34;nwnwnwnnn&#34;,
            &#34;/&#34;: &#34;nwnwnnnwn&#34;,
            &#34;+&#34;: &#34;nwnnnwnwn&#34;,
            &#34;%&#34;: &#34;nnnwnwnwn&#34;,
        }
        # The caller should do this, or we can&#39;t rotate the thing.
        # self.set_fill_color(0)
        for c in text.upper():
            if c not in chars:
                raise RuntimeError(f&#39;Invalid char &#34;{c}&#34; for Code39&#39;)
            for i, d in enumerate(chars[c]):
                if i % 2 == 0:
                    self.rect(x, y, dim[d], h, &#34;F&#34;)
                x += dim[d]
            x += dim[&#34;n&#34;]

    @check_page
    @contextmanager
    def rect_clip(self, x, y, w, h):
        &#34;&#34;&#34;
        Context manager that defines a rectangular crop zone,
        useful to render only part of an image.

        Args:
            x (float): abscissa of the clipping region top left corner
            y (float): ordinate of the clipping region top left corner
            w (float): width of the clipping region
            h (float): height of the clipping region
        &#34;&#34;&#34;
        self._out(
            (
                f&#34;q {x * self.k:.2f} {(self.h - y - h) * self.k:.2f} {w * self.k:.2f} &#34;
                f&#34;{h * self.k:.2f} re W n&#34;
            )
        )
        yield
        self._out(&#34;Q&#34;)

    @check_page
    @contextmanager
    def elliptic_clip(self, x, y, w, h):
        &#34;&#34;&#34;
        Context manager that defines an elliptic crop zone,
        useful to render only part of an image.

        Args:
            x (float): abscissa of the clipping region top left corner
            y (float): ordinate of the clipping region top left corner
            w (float): ellipse width
            h (float): ellipse height
        &#34;&#34;&#34;
        self._out(&#34;q&#34;)
        self._draw_ellipse(x, y, w, h, &#34;W n&#34;)
        yield
        self._out(&#34;Q&#34;)

    @check_page
    @contextmanager
    def round_clip(self, x, y, r):
        &#34;&#34;&#34;
        Context manager that defines a circular crop zone,
        useful to render only part of an image.

        Args:
            x (float): abscissa of the clipping region top left corner
            y (float): ordinate of the clipping region top left corner
            r (float): radius of the clipping region
        &#34;&#34;&#34;
        with self.elliptic_clip(x, y, r, r):
            yield

    @contextmanager
    def unbreakable(self):
        &#34;&#34;&#34;
        Ensures that all rendering performed in this context appear on a single page
        by performing page break beforehand if need be.

        Notes
        -----

        Using this method means to duplicate the FPDF `bytearray` buffer:
        when generating large PDFs, doubling memory usage may be troublesome.
        &#34;&#34;&#34;
        prev_page, prev_y = self.page, self.y
        recorder = FPDFRecorder(self, accept_page_break=False)
        recorder.page_break_triggered = False
        self._in_unbreakable = True
        LOGGER.debug(&#34;Starting unbreakable block&#34;)
        yield recorder
        y_scroll = recorder.y - prev_y + (recorder.page - prev_page) * self.eph
        if prev_y + y_scroll &gt; self.page_break_trigger or recorder.page &gt; prev_page:
            LOGGER.debug(&#34;Performing page jump due to unbreakable height&#34;)
            recorder.rewind()
            # pylint: disable=protected-access
            # Performing this call through .pdf so that it does not get recorded &amp; replayed:
            recorder.pdf._perform_page_break()
            recorder.replay()
            recorder.page_break_triggered = True
        self._in_unbreakable = False
        LOGGER.debug(&#34;Ending unbreakable block&#34;)

    @contextmanager
    def offset_rendering(self):
        &#34;&#34;&#34;
        All rendering performed in this context is made on a dummy FPDF object.
        This allows to test the results of some operations on the global layout
        before performing them &#34;for real&#34;.
        &#34;&#34;&#34;
        prev_page, prev_y = self.page, self.y
        recorder = FPDFRecorder(self, accept_page_break=False)
        recorder.page_break_triggered = False
        yield recorder
        y_scroll = recorder.y - prev_y + (recorder.page - prev_page) * self.eph
        if prev_y + y_scroll &gt; self.page_break_trigger or recorder.page &gt; prev_page:
            recorder.page_break_triggered = True
        recorder.rewind()

    @check_page
    def insert_toc_placeholder(
        self,
        render_toc_function: Callable,
        pages: int = 1,
        allow_extra_pages: bool = False,
        reset_page_indices: bool = True,
    ):
        &#34;&#34;&#34;
        Configure Table Of Contents rendering at the end of the document generation,
        and reserve some vertical space right now in order to insert it.
        At least one page break is triggered by this method.

        Args:
            render_toc_function (function): a function that will be invoked to render the ToC.
                This function will receive 2 parameters: `pdf`, an instance of FPDF, and `outline`,
                a list of `fpdf.outline.OutlineSection`.
            pages (int): the number of pages that the Table of Contents will span,
                including the current one that will. As many page breaks as the value of this argument
                will occur immediately after calling this method.
            allow_extra_pages (bool): If set to `True`, allows for an unlimited number of
                extra pages in the ToC, which may cause discrepancies with pre-rendered
                page numbers. For consistent numbering, using page labels to create a
                separate numbering style for the ToC is recommended.
            reset_page_indices (bool): Whether to reset the pages indices after the ToC. Default to True.
        &#34;&#34;&#34;
        if pages &lt; 1:
            raise ValueError(
                f&#34;&#39;pages&#39; parameter must be equal or greater than 1: {pages}&#34;
            )
        if not callable(render_toc_function):
            raise TypeError(
                f&#34;The first argument must be a callable, got: {type(render_toc_function)}&#34;
            )
        if self.toc_placeholder:
            raise FPDFException(
                &#34;A placeholder for the table of contents has already been defined&#34;
                f&#34; on page {self.toc_placeholder.start_page}&#34;
            )
        self.toc_placeholder = ToCPlaceholder(
            render_toc_function,
            self.page,
            self.y,
            self.cur_orientation,
            pages,
            reset_page_indices,
        )
        self._toc_allow_page_insertion = allow_extra_pages
        for _ in range(pages):
            self._perform_page_break()

    def set_section_title_styles(
        self,
        level0,
        level1=None,
        level2=None,
        level3=None,
        level4=None,
        level5=None,
        level6=None,
    ):
        &#34;&#34;&#34;
        Defines a style for section titles.
        After calling this method, calls to `FPDF.start_section` will render section names visually.

        Args:
            level0 (TextStyle): style for the top level section titles
            level1 (TextStyle): optional style for the level 1 section titles
            level2 (TextStyle): optional style for the level 2 section titles
            level3 (TextStyle): optional style for the level 3 section titles
            level4 (TextStyle): optional style for the level 4 section titles
            level5 (TextStyle): optional style for the level 5 section titles
            level6 (TextStyle): optional style for the level 6 section titles
        &#34;&#34;&#34;
        for level in (level0, level1, level2, level3, level4, level5, level6):
            if level and not isinstance(level, TextStyle):
                raise TypeError(
                    f&#34;Arguments must all be TextStyle instances, got: {type(level)}&#34;
                )
        self.section_title_styles = {
            0: level0,
            1: level1,
            2: level2,
            3: level3,
            4: level4,
            5: level5,
            6: level6,
        }

    @check_page
    def start_section(self, name, level=0, strict=True):
        &#34;&#34;&#34;
        Start a section in the document outline.
        If section_title_styles have been configured,
        render the section name visually as a title.

        Args:
            name (str): section name
            level (int): section level in the document outline. 0 means top-level.
            strict (bool): whether to raise an exception if levels increase incorrectly,
                for example with a level-3 section following a level-1 section.
        &#34;&#34;&#34;
        if level &lt; 0:
            raise ValueError(&#39;&#34;level&#34; mut be equal or greater than zero&#39;)
        if strict and self._outline and level &gt; self._outline[-1].level + 1:
            raise ValueError(
                f&#34;Incoherent hierarchy: cannot start a level {level} section after a level {self._outline[-1].level} one&#34;
            )
        dest = DestinationXYZ(self.page, top=self.h_pt - self.y * self.k)
        outline_struct_elem = None
        if self.section_title_styles:
            text_style = self.section_title_styles[level]
            # We first check if adding this multi-cell will trigger a page break:
            if text_style.size_pt is not None:
                prev_font_size_pt = self.font_size_pt
                self.font_size_pt = text_style.size_pt
            # check if l_margin value is of type Align or string
            align = Align.L
            if isinstance(text_style.l_margin, (Align, str)):
                align = Align.coerce(text_style.l_margin)
            page_break_triggered = self.multi_cell(
                w=self.epw,
                h=self.font_size,
                text=name,
                new_x=XPos.LMARGIN,
                new_y=YPos.NEXT,
                dry_run=True,  # =&gt; does not produce any output
                output=MethodReturnValue.PAGE_BREAK,
                align=align,
                padding=Padding(
                    top=text_style.t_margin or 0,
                    left=(
                        text_style.l_margin
                        if isinstance(text_style.l_margin, (int, float))
                        else 0
                    ),
                    bottom=text_style.b_margin or 0,
                ),
            )
            if text_style.size_pt is not None:
                self.font_size_pt = prev_font_size_pt
            if page_break_triggered:
                # If so, we trigger a page break manually beforehand:
                self.add_page()
            with self._marked_sequence(title=name) as struct_elem:
                outline_struct_elem = struct_elem
                with self.use_text_style(text_style):
                    self.multi_cell(
                        w=self.epw,
                        h=self.font_size,
                        text=name,
                        align=align,
                        new_x=XPos.LMARGIN,
                        new_y=YPos.NEXT,
                        center=text_style.l_margin == Align.C,
                    )
        self._outline.append(
            OutlineSection(name, level, self.page, dest, outline_struct_elem)
        )

    @contextmanager
    def use_text_style(self, text_style: TextStyle):
        prev_l_margin = None
        if text_style:
            if text_style.t_margin:
                self.ln(text_style.t_margin)
            if text_style.l_margin:
                if isinstance(text_style.l_margin, (float, int)):
                    prev_l_margin = self.l_margin
                    self.l_margin = text_style.l_margin
                    self.x = self.l_margin
                else:
                    LOGGER.debug(
                        &#34;Unsupported &#39;%s&#39; value provided as l_margin to .use_text_style()&#34;,
                        text_style.l_margin,
                    )
        with self.use_font_face(text_style):
            yield
        if text_style and text_style.b_margin:
            self.ln(text_style.b_margin)
        if prev_l_margin is not None:
            self.l_margin = prev_l_margin
            self.x = self.l_margin

    @contextmanager
    def use_font_face(self, font_face: FontFace):
        &#34;&#34;&#34;
        Sets the provided `fpdf.fonts.FontFace` in a local context,
        then restore font settings back to they were initially.
        This method must be used as a context manager using `with`:

            with pdf.use_font_face(FontFace(emphasis=&#34;BOLD&#34;, color=255, size_pt=42)):
                put_some_text()

        Known limitation: in case of a page jump in this local context,
        the temporary style may &#34;leak&#34; in the header() &amp; footer().
        &#34;&#34;&#34;
        if not font_face:
            yield
            return
        prev_font = (self.font_family, self.font_style, self.font_size_pt)
        self.set_font(
            font_face.family or self.font_family,
            (
                font_face.emphasis.style
                if font_face.emphasis is not None
                else self.font_style
            ),
            font_face.size_pt or self.font_size_pt,
        )
        self.current_font_is_set_on_page = False
        prev_text_color = self.text_color
        if font_face.color is not None and font_face.color != self.text_color:
            self.set_text_color(font_face.color)
        prev_fill_color = self.fill_color
        if font_face.fill_color is not None:
            self.set_fill_color(font_face.fill_color)
        yield
        if font_face.fill_color is not None:
            self.set_fill_color(prev_fill_color)
        self.text_color = prev_text_color
        self.set_font(*prev_font)

    @check_page
    @contextmanager
    def table(self, *args, **kwargs):
        &#34;&#34;&#34;
        Inserts a table, that can be built using the `fpdf.table.Table` object yield.
        Detailed usage documentation: https://py-pdf.github.io/fpdf2/Tables.html

        Args:
            rows: optional. Sequence of rows (iterable) of str to initiate the table cells with text content.
            align (str, fpdf.enums.Align): optional, default to CENTER. Sets the table horizontal position
                relative to the page, when it&#39;s not using the full page width.
            borders_layout (str, fpdf.enums.TableBordersLayout): optional, default to ALL. Control what cell
                borders are drawn.
            cell_fill_color (int, tuple, fpdf.drawing.DeviceCMYK, fpdf.drawing.DeviceGray, fpdf.drawing.DeviceRGB): optional.
                Defines the cells background color.
            cell_fill_mode (str, fpdf.enums.TableCellFillMode): optional. Defines which cells are filled
                with color in the background.
            col_widths (int, tuple): optional. Sets column width. Can be a single number or a sequence of numbers.
            first_row_as_headings (bool): optional, default to True. If False, the first row of the table
                is not styled differently from the others.
            gutter_height (float): optional vertical space between rows.
            gutter_width (float): optional horizontal space between columns.
            headings_style (fpdf.fonts.FontFace): optional, default to bold.
                Defines the visual style of the top headings row: size, color, emphasis...
            line_height (number): optional. Defines how much vertical space a line of text will occupy.
            markdown (bool): optional, default to False. Enable markdown interpretation of cells textual content.
            text_align (str, fpdf.enums.Align): optional, default to JUSTIFY. Control text alignment inside cells.
            v_align (str, fpdf.enums.VAlign): optional, default to CENTER. Control vertical alignment of cells content.
            width (number): optional. Sets the table width.
            wrapmode (fpdf.enums.WrapMode): &#34;WORD&#34; for word based line wrapping (default),
                &#34;CHAR&#34; for character based line wrapping.
            padding (number, tuple, Padding): optional. Sets the cell padding. Can be a single number or a sequence
                of numbers, default:0
                If padding for left or right ends up being non-zero then the respective c_margin is ignored.
            outer_border_width (number): optional. The outer_border_width will trigger rendering of the outer
                border of the table with the given width regardless of any other defined border styles.
            num_heading_rows (number): optional. Sets the number of heading rows, default value is 1. If this value is not 1,
                first_row_as_headings needs to be True if num_heading_rows&gt;1 and False if num_heading_rows=0. For backwards compatibility,
                first_row_as_headings is used in case num_heading_rows is 1.
            repeat_headings (fpdf.enums.TableHeadingsDisplay): optional, indicates whether to print table headings on every page, default to 1.
        &#34;&#34;&#34;
        table = Table(self, *args, **kwargs)
        yield table
        table.render()

    def output(
        self, name=&#34;&#34;, dest=&#34;&#34;, linearize=False, output_producer_class=OutputProducer
    ):
        &#34;&#34;&#34;
        Output PDF to some destination.
        The method first calls [close](close.md) if necessary to terminate the document.
        After calling this method, content cannot be added to the document anymore.

        By default the bytearray buffer is returned.
        If a `name` is given, the PDF is written to a new file.

        Args:
            name (str): optional File object or file path where to save the PDF under
            dest (str): [**DEPRECATED since 2.3.0**] unused, will be removed in a later version
            output_producer_class (class): use a custom class for PDF file generation
        &#34;&#34;&#34;
        if dest:
            warnings.warn(
                (
                    &#39;&#34;dest&#34; parameter is deprecated since v2.2.0, &#39;
                    &#34;unused and will soon be removed&#34;
                ),
                DeprecationWarning,
                stacklevel=get_stack_level(),
            )
        # Clear cache of cached functions to free up memory after output
        get_unicode_script.cache_clear()
        # Finish document if necessary:
        if not self.buffer:
            if self.page == 0:
                self.add_page()
            # Generating final page footer:
            self._render_footer()
            # Generating .buffer based on .pages:
            if self.toc_placeholder:
                self._insert_table_of_contents()
            if self.str_alias_nb_pages:
                for page in self.pages.values():
                    for substitution_item in page.get_text_substitutions():
                        page.contents = page.contents.replace(
                            substitution_item.get_placeholder_string().encode(
                                &#34;latin-1&#34;
                            ),
                            substitution_item.render_text_substitution(
                                str(self.pages_count)
                            ).encode(&#34;latin-1&#34;),
                        )
            if linearize:
                output_producer_class = LinearizedOutputProducer
            output_producer = output_producer_class(self)
            self.buffer = output_producer.bufferize()
        if name:
            if isinstance(name, os.PathLike):
                name.write_bytes(self.buffer)
            elif isinstance(name, str):
                Path(name).write_bytes(self.buffer)
            else:
                name.write(self.buffer)
            return None
        return self.buffer</code></pre>
</details>
<div class="desc"><p>PDF Generation class</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>orientation</code></strong> :&ensp;<code>str</code></dt>
<dd>possible values are "portrait" (can be abbreviated "P")
or "landscape" (can be abbreviated "L"). Default to "portrait".</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>str, int, float</code></dt>
<dd>possible values are "pt", "mm", "cm", "in", or a number.
A point equals 1/72 of an inch, that is to say about 0.35 mm (an inch being 2.54 cm).
This is a very common unit in typography; font sizes are expressed in this unit.
If given a number, then it will be treated as the number of points per unit.
(eg. 72 = 1 in)
Default to "mm".</dd>
<dt><strong><code>format</code></strong> :&ensp;<code>str</code></dt>
<dd>possible values are "a3", "a4", "a5", "letter", "legal" or a tuple
(width, height) expressed in the given unit. Default to "a4".</dd>
<dt><strong><code>font_cache_dir</code></strong> :&ensp;<code>Path</code> or <code>str</code></dt>
<dd>[<strong>DEPRECATED since v2.5.1</strong>] unused</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fpdf.graphics_state.GraphicsStateMixin" href="graphics_state.html#fpdf.graphics_state.GraphicsStateMixin">GraphicsStateMixin</a></li>
<li><a title="fpdf.text_region.TextRegionMixin" href="text_region.html#fpdf.text_region.TextRegionMixin">TextRegionMixin</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fpdf.fpdf.FPDF.DEFAULT_DRAW_COLOR"><code class="name">var <span class="ident">DEFAULT_DRAW_COLOR</span></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.graphics_state.GraphicsStateMixin" href="graphics_state.html#fpdf.graphics_state.GraphicsStateMixin">GraphicsStateMixin</a></code>.<code><a title="fpdf.graphics_state.GraphicsStateMixin.DEFAULT_DRAW_COLOR" href="graphics_state.html#fpdf.graphics_state.GraphicsStateMixin.DEFAULT_DRAW_COLOR">DEFAULT_DRAW_COLOR</a></code>
</p>
<div class="desc inherited"><p>The type of the None singleton.</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.DEFAULT_FILL_COLOR"><code class="name">var <span class="ident">DEFAULT_FILL_COLOR</span></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.graphics_state.GraphicsStateMixin" href="graphics_state.html#fpdf.graphics_state.GraphicsStateMixin">GraphicsStateMixin</a></code>.<code><a title="fpdf.graphics_state.GraphicsStateMixin.DEFAULT_FILL_COLOR" href="graphics_state.html#fpdf.graphics_state.GraphicsStateMixin.DEFAULT_FILL_COLOR">DEFAULT_FILL_COLOR</a></code>
</p>
<div class="desc inherited"><p>The type of the None singleton.</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.DEFAULT_TEXT_COLOR"><code class="name">var <span class="ident">DEFAULT_TEXT_COLOR</span></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.graphics_state.GraphicsStateMixin" href="graphics_state.html#fpdf.graphics_state.GraphicsStateMixin">GraphicsStateMixin</a></code>.<code><a title="fpdf.graphics_state.GraphicsStateMixin.DEFAULT_TEXT_COLOR" href="graphics_state.html#fpdf.graphics_state.GraphicsStateMixin.DEFAULT_TEXT_COLOR">DEFAULT_TEXT_COLOR</a></code>
</p>
<div class="desc inherited"><p>The type of the None singleton.</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.HTML2FPDF_CLASS"><code class="name">var <span class="ident">HTML2FPDF_CLASS</span></code></dt>
<dd>
<div class="desc"><p>Render basic HTML to FPDF</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.MARKDOWN_BOLD_MARKER"><code class="name">var <span class="ident">MARKDOWN_BOLD_MARKER</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.MARKDOWN_ESCAPE_CHARACTER"><code class="name">var <span class="ident">MARKDOWN_ESCAPE_CHARACTER</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.MARKDOWN_ITALICS_MARKER"><code class="name">var <span class="ident">MARKDOWN_ITALICS_MARKER</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.MARKDOWN_LINK_COLOR"><code class="name">var <span class="ident">MARKDOWN_LINK_COLOR</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.MARKDOWN_LINK_REGEX"><code class="name">var <span class="ident">MARKDOWN_LINK_REGEX</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.MARKDOWN_LINK_UNDERLINE"><code class="name">var <span class="ident">MARKDOWN_LINK_UNDERLINE</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.MARKDOWN_STRIKETHROUGH_MARKER"><code class="name">var <span class="ident">MARKDOWN_STRIKETHROUGH_MARKER</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.MARKDOWN_UNDERLINE_MARKER"><code class="name">var <span class="ident">MARKDOWN_UNDERLINE_MARKER</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.fpdf.FPDF.accept_page_break"><code class="name">prop <span class="ident">accept_page_break</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L3126-L3135" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def accept_page_break(self):
    &#34;&#34;&#34;
    Whenever a page break condition is met, this method is called,
    and the break is issued or not depending on the returned value.

    The default implementation returns a value according to the mode selected by `FPDF.set_auto_page_break()`.
    This method is called automatically and should not be called directly by the application.
    &#34;&#34;&#34;
    return self.auto_page_break</code></pre>
</details>
<div class="desc"><p>Whenever a page break condition is met, this method is called,
and the break is issued or not depending on the returned value.</p>
<p>The default implementation returns a value according to the mode selected by <code><a title="fpdf.fpdf.FPDF.set_auto_page_break" href="#fpdf.fpdf.FPDF.set_auto_page_break">FPDF.set_auto_page_break()</a></code>.
This method is called automatically and should not be called directly by the application.</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.char_vpos"><code class="name">prop <span class="ident">char_vpos</span></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.graphics_state.GraphicsStateMixin" href="graphics_state.html#fpdf.graphics_state.GraphicsStateMixin">GraphicsStateMixin</a></code>.<code><a title="fpdf.graphics_state.GraphicsStateMixin.char_vpos" href="graphics_state.html#fpdf.graphics_state.GraphicsStateMixin.char_vpos">char_vpos</a></code>
</p>
<div class="desc inherited"><p>Return vertical character position relative to line.
(<a href="../TextStyling.html#subscript-superscript-and-fractional-numbers">docs</a>)</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.core_fonts_encoding"><code class="name">var <span class="ident">core_fonts_encoding</span></code></dt>
<dd>
<div class="desc"><p>Font encoding, Latin-1 by default</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.default_page_dimensions"><code class="name">prop <span class="ident">default_page_dimensions</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L619-L626" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def default_page_dimensions(self):
    &#34;Return a pair (width, height) in the unit specified to FPDF constructor&#34;
    return (
        (self.dw_pt, self.dh_pt)
        if self.def_orientation == PageOrientation.PORTRAIT
        else (self.dh_pt, self.dw_pt)
    )</code></pre>
</details>
<div class="desc"><p>Return a pair (width, height) in the unit specified to FPDF constructor</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.denom_lift"><code class="name">prop <span class="ident">denom_lift</span></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.graphics_state.GraphicsStateMixin" href="graphics_state.html#fpdf.graphics_state.GraphicsStateMixin">GraphicsStateMixin</a></code>.<code><a title="fpdf.graphics_state.GraphicsStateMixin.denom_lift" href="graphics_state.html#fpdf.graphics_state.GraphicsStateMixin.denom_lift">denom_lift</a></code>
</p>
<div class="desc inherited"><p>Return lift factor for denominator text.
(<a href="../TextStyling.html#subscript-superscript-and-fractional-numbers">docs</a>)</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.denom_scale"><code class="name">prop <span class="ident">denom_scale</span></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.graphics_state.GraphicsStateMixin" href="graphics_state.html#fpdf.graphics_state.GraphicsStateMixin">GraphicsStateMixin</a></code>.<code><a title="fpdf.graphics_state.GraphicsStateMixin.denom_scale" href="graphics_state.html#fpdf.graphics_state.GraphicsStateMixin.denom_scale">denom_scale</a></code>
</p>
<div class="desc inherited"><p>Return scale factor for denominator text.
(<a href="../TextStyling.html#subscript-superscript-and-fractional-numbers">docs</a>)</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.emphasis"><code class="name">prop <span class="ident">emphasis</span> : <a title="fpdf.enums.TextEmphasis" href="enums.html#fpdf.enums.TextEmphasis">TextEmphasis</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L454-L462" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def emphasis(self) -&gt; TextEmphasis:
    &#34;The current text emphasis: bold, italics, underline and/or strikethrough.&#34;
    font_style = self.font_style
    if self.strikethrough:
        font_style += &#34;S&#34;
    if self.underline:
        font_style += &#34;U&#34;
    return TextEmphasis.coerce(font_style)</code></pre>
</details>
<div class="desc"><p>The current text emphasis: bold, italics, underline and/or strikethrough.</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.eph"><code class="name">prop <span class="ident">eph</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L532-L537" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def eph(self):
    &#34;&#34;&#34;
    Effective page height: the page height minus its vertical margins.
    &#34;&#34;&#34;
    return self.h - self.t_margin - self.b_margin</code></pre>
</details>
<div class="desc"><p>Effective page height: the page height minus its vertical margins.</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.epw"><code class="name">prop <span class="ident">epw</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L525-L530" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def epw(self):
    &#34;&#34;&#34;
    Effective page width: the page width minus its horizontal margins.
    &#34;&#34;&#34;
    return self.w - self.l_margin - self.r_margin</code></pre>
</details>
<div class="desc"><p>Effective page width: the page width minus its horizontal margins.</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.is_ttf_font"><code class="name">prop <span class="ident">is_ttf_font</span> : bool</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L464-L466" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def is_ttf_font(self) -&gt; bool:
    return self.current_font and self.current_font.type == &#34;TTF&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fpdf.FPDF.nom_lift"><code class="name">prop <span class="ident">nom_lift</span></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.graphics_state.GraphicsStateMixin" href="graphics_state.html#fpdf.graphics_state.GraphicsStateMixin">GraphicsStateMixin</a></code>.<code><a title="fpdf.graphics_state.GraphicsStateMixin.nom_lift" href="graphics_state.html#fpdf.graphics_state.GraphicsStateMixin.nom_lift">nom_lift</a></code>
</p>
<div class="desc inherited"><p>Return lift factor for nominator text.
(<a href="../TextStyling.html#subscript-superscript-and-fractional-numbers">docs</a>)</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.nom_scale"><code class="name">prop <span class="ident">nom_scale</span></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.graphics_state.GraphicsStateMixin" href="graphics_state.html#fpdf.graphics_state.GraphicsStateMixin">GraphicsStateMixin</a></code>.<code><a title="fpdf.graphics_state.GraphicsStateMixin.nom_scale" href="graphics_state.html#fpdf.graphics_state.GraphicsStateMixin.nom_scale">nom_scale</a></code>
</p>
<div class="desc inherited"><p>Return scale factor for nominator text.
(<a href="../TextStyling.html#subscript-superscript-and-fractional-numbers">docs</a>)</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.output_intents"><code class="name">prop <span class="ident">output_intents</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L480-L482" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def output_intents(self):
    return self._output_intents.values()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fpdf.FPDF.page"><code class="name">var <span class="ident">page</span></code></dt>
<dd>
<div class="desc"><p>Note: Setting the page manually may result in unexpected behavior.
<code>pdf.add_page()</code> takes special care to ensure the page's content stream
matches FPDF's instance attributes. Manually setting the page does not.</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.page_layout"><code class="name">prop <span class="ident">page_layout</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L745-L747" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def page_layout(self):
    return self._page_layout</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fpdf.FPDF.page_mode"><code class="name">prop <span class="ident">page_mode</span> : <a title="fpdf.enums.PageMode" href="enums.html#fpdf.enums.PageMode">PageMode</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L468-L470" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def page_mode(self) -&gt; PageMode:
    return self._page_mode</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fpdf.FPDF.pages_count"><code class="name">prop <span class="ident">pages_count</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L539-L544" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def pages_count(self):
    &#34;&#34;&#34;
    Returns the total pages of the document.
    &#34;&#34;&#34;
    return len(self.pages)</code></pre>
</details>
<div class="desc"><p>Returns the total pages of the document.</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.single_resources_object"><code class="name">var <span class="ident">single_resources_object</span></code></dt>
<dd>
<div class="desc"><p>Setting this to True restore the old behaviour before 2.7.9.
Using a single /Resources object makes the resulting PDF document smaller,
but is less compatible with the PDF spec.</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.sub_lift"><code class="name">prop <span class="ident">sub_lift</span></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.graphics_state.GraphicsStateMixin" href="graphics_state.html#fpdf.graphics_state.GraphicsStateMixin">GraphicsStateMixin</a></code>.<code><a title="fpdf.graphics_state.GraphicsStateMixin.sub_lift" href="graphics_state.html#fpdf.graphics_state.GraphicsStateMixin.sub_lift">sub_lift</a></code>
</p>
<div class="desc inherited"><p>Return lift factor for subscript text.
(<a href="../TextStyling.html#subscript-superscript-and-fractional-numbers">docs</a>)</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.sub_scale"><code class="name">prop <span class="ident">sub_scale</span></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.graphics_state.GraphicsStateMixin" href="graphics_state.html#fpdf.graphics_state.GraphicsStateMixin">GraphicsStateMixin</a></code>.<code><a title="fpdf.graphics_state.GraphicsStateMixin.sub_scale" href="graphics_state.html#fpdf.graphics_state.GraphicsStateMixin.sub_scale">sub_scale</a></code>
</p>
<div class="desc inherited"><p>Return scale factor for subscript text.
(<a href="../TextStyling.html#subscript-superscript-and-fractional-numbers">docs</a>)</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.sup_lift"><code class="name">prop <span class="ident">sup_lift</span></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.graphics_state.GraphicsStateMixin" href="graphics_state.html#fpdf.graphics_state.GraphicsStateMixin">GraphicsStateMixin</a></code>.<code><a title="fpdf.graphics_state.GraphicsStateMixin.sup_lift" href="graphics_state.html#fpdf.graphics_state.GraphicsStateMixin.sup_lift">sup_lift</a></code>
</p>
<div class="desc inherited"><p>Return lift factor for superscript text.
(<a href="../TextStyling.html#subscript-superscript-and-fractional-numbers">docs</a>)</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.sup_scale"><code class="name">prop <span class="ident">sup_scale</span></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.graphics_state.GraphicsStateMixin" href="graphics_state.html#fpdf.graphics_state.GraphicsStateMixin">GraphicsStateMixin</a></code>.<code><a title="fpdf.graphics_state.GraphicsStateMixin.sup_scale" href="graphics_state.html#fpdf.graphics_state.GraphicsStateMixin.sup_scale">sup_scale</a></code>
</p>
<div class="desc inherited"><p>Return scale factor for superscript text.
(<a href="../TextStyling.html#subscript-superscript-and-fractional-numbers">docs</a>)</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.fpdf.FPDF._get_current_graphics_state"><code class="name flex">
<span>def <span class="ident">_get_current_graphics_state</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.graphics_state.GraphicsStateMixin" href="graphics_state.html#fpdf.graphics_state.GraphicsStateMixin">GraphicsStateMixin</a></code>.<code><a title="fpdf.graphics_state.GraphicsStateMixin._get_current_graphics_state" href="graphics_state.html#fpdf.graphics_state.GraphicsStateMixin._get_current_graphics_state">_get_current_graphics_state</a></code>
</p>
<div class="desc inherited"><p>Retrieve the current graphics state</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF._is_current_graphics_state_nested"><code class="name flex">
<span>def <span class="ident">_is_current_graphics_state_nested</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.graphics_state.GraphicsStateMixin" href="graphics_state.html#fpdf.graphics_state.GraphicsStateMixin">GraphicsStateMixin</a></code>.<code><a title="fpdf.graphics_state.GraphicsStateMixin._is_current_graphics_state_nested" href="graphics_state.html#fpdf.graphics_state.GraphicsStateMixin._is_current_graphics_state_nested">_is_current_graphics_state_nested</a></code>
</p>
<div class="desc inherited"><p>Indicate if the stack contains items (else it is empty)</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF._pop_local_stack"><code class="name flex">
<span>def <span class="ident">_pop_local_stack</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.graphics_state.GraphicsStateMixin" href="graphics_state.html#fpdf.graphics_state.GraphicsStateMixin">GraphicsStateMixin</a></code>.<code><a title="fpdf.graphics_state.GraphicsStateMixin._pop_local_stack" href="graphics_state.html#fpdf.graphics_state.GraphicsStateMixin._pop_local_stack">_pop_local_stack</a></code>
</p>
<div class="desc inherited"><p>Pop the last graphics state on the stack</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF._push_local_stack"><code class="name flex">
<span>def <span class="ident">_push_local_stack</span></span>(<span>self, new=None)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.graphics_state.GraphicsStateMixin" href="graphics_state.html#fpdf.graphics_state.GraphicsStateMixin">GraphicsStateMixin</a></code>.<code><a title="fpdf.graphics_state.GraphicsStateMixin._push_local_stack" href="graphics_state.html#fpdf.graphics_state.GraphicsStateMixin._push_local_stack">_push_local_stack</a></code>
</p>
<div class="desc inherited"><p>Push a graphics state on the stack</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.add_action"><code class="name flex">
<span>def <span class="ident">add_action</span></span>(<span>self, action, x, y, w, h, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L2613-L2635" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@check_page
def add_action(self, action, x, y, w, h, **kwargs):
    &#34;&#34;&#34;
    Puts an Action annotation on a rectangular area of the page.

    Args:
        action (fpdf.actions.Action): the action to add
        x (float): horizontal position (from the left) to the left side of the link rectangle
        y (float): vertical position (from the top) to the bottom side of the link rectangle
        w (float): width of the link rectangle
        h (float): height of the link rectangle
    &#34;&#34;&#34;
    annotation = AnnotationDict(
        &#34;Action&#34;,
        x * self.k,
        self.h_pt - y * self.k,
        w * self.k,
        h * self.k,
        action=action,
        **kwargs,
    )
    self.pages[self.page].annots.append(annotation)
    return annotation</code></pre>
</details>
<div class="desc"><p>Puts an Action annotation on a rectangular area of the page.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>action</code></strong> :&ensp;<code><a title="fpdf.actions.Action" href="actions.html#fpdf.actions.Action">Action</a></code></dt>
<dd>the action to add</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>horizontal position (from the left) to the left side of the link rectangle</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>vertical position (from the top) to the bottom side of the link rectangle</dd>
<dt><strong><code>w</code></strong> :&ensp;<code>float</code></dt>
<dd>width of the link rectangle</dd>
<dt><strong><code>h</code></strong> :&ensp;<code>float</code></dt>
<dd>height of the link rectangle</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.add_font"><code class="name flex">
<span>def <span class="ident">add_font</span></span>(<span>self, family=None, style='', fname=None, uni='DEPRECATED')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L2095-L2159" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def add_font(self, family=None, style=&#34;&#34;, fname=None, uni=&#34;DEPRECATED&#34;):
    &#34;&#34;&#34;
    Imports a TrueType or OpenType font and makes it available
    for later calls to the `FPDF.set_font()` method.

    You will find more information on the &#34;Unicode&#34; documentation page.

    Args:
        family (str): optional name of the font family. Used as a reference for `FPDF.set_font()`.
            If not provided, use the base name of the `fname` font path, without extension.
        style (str): font style. &#34;&#34; for regular, include &#39;B&#39; for bold, and/or &#39;I&#39; for italic.
        fname (str): font file name. You can specify a relative or full path.
            If the file is not found, it will be searched in `FPDF_FONT_DIR`.
        uni (bool): [**DEPRECATED since 2.5.1**] unused
    &#34;&#34;&#34;
    if not fname:
        raise ValueError(&#39;&#34;fname&#34; parameter is required&#39;)

    ext = splitext(str(fname))[1].lower()
    if ext not in (&#34;.otf&#34;, &#34;.otc&#34;, &#34;.ttf&#34;, &#34;.ttc&#34;):
        raise ValueError(
            f&#34;Unsupported font file extension: {ext}.&#34;
            &#34; add_font() used to accept .pkl file as input, but for security reasons&#34;
            &#34; this feature is deprecated since v2.5.1 and has been removed in v2.5.3.&#34;
        )

    if uni != &#34;DEPRECATED&#34;:
        warnings.warn(
            (
                &#39;&#34;uni&#34; parameter is deprecated since v2.5.1, &#39;
                &#34;unused and will soon be removed&#34;
            ),
            DeprecationWarning,
            stacklevel=get_stack_level(),
        )

    style = &#34;&#34;.join(sorted(style.upper()))
    if any(letter not in &#34;BI&#34; for letter in style):
        raise ValueError(
            f&#34;Unknown style provided (only B &amp; I letters are allowed): {style}&#34;
        )

    for parent in (&#34;.&#34;, FPDF_FONT_DIR):
        if not parent:
            continue

        if (Path(parent) / fname).exists():
            font_file_path = Path(parent) / fname
            break
    else:
        raise FileNotFoundError(f&#34;TTF Font file not found: {fname}&#34;)

    if family is None:
        family = font_file_path.stem

    fontkey = f&#34;{family.lower()}{style}&#34;
    # Check if font already added or one of the core fonts
    if fontkey in self.fonts or fontkey in CORE_FONTS:
        warnings.warn(
            f&#34;Core font or font already added &#39;{fontkey}&#39;: doing nothing&#34;,
            stacklevel=get_stack_level(),
        )
        return

    self.fonts[fontkey] = TTFFont(self, font_file_path, fontkey, style)</code></pre>
</details>
<div class="desc"><p>Imports a TrueType or OpenType font and makes it available
for later calls to the <code><a title="fpdf.fpdf.FPDF.set_font" href="#fpdf.fpdf.FPDF.set_font">FPDF.set_font()</a></code> method.</p>
<p>You will find more information on the "Unicode" documentation page.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>family</code></strong> :&ensp;<code>str</code></dt>
<dd>optional name of the font family. Used as a reference for <code><a title="fpdf.fpdf.FPDF.set_font" href="#fpdf.fpdf.FPDF.set_font">FPDF.set_font()</a></code>.
If not provided, use the base name of the <code>fname</code> font path, without extension.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code>str</code></dt>
<dd>font style. "" for regular, include 'B' for bold, and/or 'I' for italic.</dd>
<dt><strong><code>fname</code></strong> :&ensp;<code>str</code></dt>
<dd>font file name. You can specify a relative or full path.
If the file is not found, it will be searched in <code>FPDF_FONT_DIR</code>.</dd>
<dt><strong><code>uni</code></strong> :&ensp;<code>bool</code></dt>
<dd>[<strong>DEPRECATED since 2.5.1</strong>] unused</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.add_link"><code class="name flex">
<span>def <span class="ident">add_link</span></span>(<span>self, y=0, x=0, page=-1, zoom='null')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L2336-L2362" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def add_link(self, y=0, x=0, page=-1, zoom=&#34;null&#34;):
    &#34;&#34;&#34;
    Creates a new internal link and returns its identifier.
    An internal link is a clickable area which directs to another place within the document.

    The identifier can then be passed to the `FPDF.cell()`, `FPDF.write()`, `FPDF.image()`
    or `FPDF.link()` methods.

    Args:
        y (float): optional ordinate of target position.
            The default value is 0 (top of page).
        x (float): optional abscissa of target position.
            The default value is 0 (top of page).
        page (int): optional number of target page.
            -1 indicates the current page, which is the default value.
        zoom (float): optional new zoom level after following the link.
            Currently ignored by Sumatra PDF Reader, but observed by Adobe Acrobat reader.
    &#34;&#34;&#34;
    link = DestinationXYZ(
        self.page if page == -1 else page,
        top=self.h_pt - y * self.k,
        left=x * self.k,
        zoom=zoom,
    )
    link_index = len(self.links) + 1
    self.links[link_index] = link
    return link_index</code></pre>
</details>
<div class="desc"><p>Creates a new internal link and returns its identifier.
An internal link is a clickable area which directs to another place within the document.</p>
<p>The identifier can then be passed to the <code><a title="fpdf.fpdf.FPDF.cell" href="#fpdf.fpdf.FPDF.cell">FPDF.cell()</a></code>, <code><a title="fpdf.fpdf.FPDF.write" href="#fpdf.fpdf.FPDF.write">FPDF.write()</a></code>, <code><a title="fpdf.fpdf.FPDF.image" href="#fpdf.fpdf.FPDF.image">FPDF.image()</a></code>
or <code><a title="fpdf.fpdf.FPDF.link" href="#fpdf.fpdf.FPDF.link">FPDF.link()</a></code> methods.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>optional ordinate of target position.
The default value is 0 (top of page).</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>optional abscissa of target position.
The default value is 0 (top of page).</dd>
<dt><strong><code>page</code></strong> :&ensp;<code>int</code></dt>
<dd>optional number of target page.
-1 indicates the current page, which is the default value.</dd>
<dt><strong><code>zoom</code></strong> :&ensp;<code>float</code></dt>
<dd>optional new zoom level after following the link.
Currently ignored by Sumatra PDF Reader, but observed by Adobe Acrobat reader.</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.add_output_intent"><code class="name flex">
<span>def <span class="ident">add_output_intent</span></span>(<span>self,<br>subtype: <a title="fpdf.enums.OutputIntentSubType" href="enums.html#fpdf.enums.OutputIntentSubType">OutputIntentSubType</a>,<br>output_condition_identifier: str = None,<br>output_condition: str = None,<br>registry_name: str = None,<br>dest_output_profile: <a title="fpdf.output.PDFICCProfile" href="output.html#fpdf.output.PDFICCProfile">PDFICCProfile</a> = None,<br>info: str = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L485-L523" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def add_output_intent(
    self,
    subtype: OutputIntentSubType,
    output_condition_identifier: str = None,
    output_condition: str = None,
    registry_name: str = None,
    dest_output_profile: PDFICCProfile = None,
    info: str = None,
):
    &#34;&#34;&#34;
    Adds desired Output Intent to the Output Intents array:

    Args:
        subtype (OutputIntentSubType, required): PDFA, PDFX or ISOPDF
        output_condition_identifier (str, required): see the Name in
            https://www.color.org/registry.xalter
        output_condition (str, optional): see the Definition in
            https://www.color.org/registry.xalter
        registry_name (str, optional): &#34;https://www.color.org&#34;
        dest_output_profile (PDFICCProfile, required/optional):
            PDFICCProfile | None # (required  if
            output_condition_identifier does not specify a standard
            production condition; optional otherwise)
        info (str, required/optional see dest_output_profile): human
            readable description of profile
    &#34;&#34;&#34;
    if subtype.value in self._output_intents:
        raise ValueError(
            &#34;add_output_intent: subtype &#39;&#34; + subtype.value + &#34;&#39; already exists.&#34;
        )
    self._output_intents[subtype.value] = OutputIntentDictionary(
        subtype,
        output_condition_identifier,
        output_condition,
        registry_name,
        dest_output_profile,
        info,
    )
    self._set_min_pdf_version(&#34;1.4&#34;)</code></pre>
</details>
<div class="desc"><p>Adds desired Output Intent to the Output Intents array:</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>subtype</code></strong> :&ensp;<code>OutputIntentSubType, required</code></dt>
<dd>PDFA, PDFX or ISOPDF</dd>
<dt><strong><code>output_condition_identifier</code></strong> :&ensp;<code>str, required</code></dt>
<dd>see the Name in
<a href="https://www.color.org/registry.xalter">https://www.color.org/registry.xalter</a></dd>
<dt><strong><code>output_condition</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>see the Definition in
<a href="https://www.color.org/registry.xalter">https://www.color.org/registry.xalter</a></dd>
<dt><strong><code>registry_name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>"https://www.color.org"</dd>
</dl>
<p>dest_output_profile (PDFICCProfile, required/optional):
PDFICCProfile | None # (required
if
output_condition_identifier does not specify a standard
production condition; optional otherwise)
info (str, required/optional see dest_output_profile): human
readable description of profile</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.add_page"><code class="name flex">
<span>def <span class="ident">add_page</span></span>(<span>self,<br>orientation: str = '',<br>format: str = '',<br>same: bool = False,<br>duration: float = 0,<br>transition: <a title="fpdf.transitions.Transition" href="transitions.html#fpdf.transitions.Transition">Transition</a> = None,<br>label_style: str | <a title="fpdf.enums.PageLabelStyle" href="enums.html#fpdf.enums.PageLabelStyle">PageLabelStyle</a> = None,<br>label_prefix: str = None,<br>label_start: int = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L962-L1108" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def add_page(
    self,
    orientation: str = &#34;&#34;,
    format: str = &#34;&#34;,
    same: bool = False,
    duration: float = 0,
    transition: Transition = None,
    label_style: Union[str, PageLabelStyle] = None,
    label_prefix: str = None,
    label_start: int = None,
):
    &#34;&#34;&#34;
    Adds a new page to the document.
    If a page is already present, the `FPDF.footer()` method is called first.
    Then the page  is added, the current position is set to the top-left corner,
    with respect to the left and top margins, and the `FPDF.header()` method is called.

    Args:
        orientation (str): &#34;portrait&#34; (can be abbreviated &#34;P&#34;)
            or &#34;landscape&#34; (can be abbreviated &#34;L&#34;). Default to &#34;portrait&#34;.
        format (str): &#34;a3&#34;, &#34;a4&#34;, &#34;a5&#34;, &#34;letter&#34;, &#34;legal&#34; or a tuple
            (width, height). Default to &#34;a4&#34;.
        same (bool): indicates to use the same page format as the previous page.
            Default to False.
        duration (float): optional page’s display duration, i.e. the maximum length of time,
            in seconds, that the page is displayed in presentation mode,
            before the viewer application automatically advances to the next page.
            Can be configured globally through the `.page_duration` FPDF property.
            As of june 2021, onored by Adobe Acrobat reader, but ignored by Sumatra PDF reader.
        transition (Transition child class): optional visual transition to use when moving
            from another page to the given page during a presentation.
            Can be configured globally through the `.page_transition` FPDF property.
            As of june 2021, onored by Adobe Acrobat reader, but ignored by Sumatra PDF reader.
        label_style (str or PageLabelStyle): Defines the numbering style for the numeric portion of each
            page label. Possible values are:
            - &#34;D&#34;: Decimal Arabic numerals.
            - &#34;R&#34;: Uppercase Roman numerals.
            - &#34;r&#34;: Lowercase Roman numerals.
            - &#34;A&#34;: Uppercase letters (A to Z for the first 26 pages, followed by AA to ZZ, etc.).
            - &#34;a&#34;: Lowercase letters (a to z for the first 26 pages, followed by aa to zz, etc.).
        label_prefix (str): Prefix string applied to the page label, preceding the numeric portion.
        label_start (int): Starting number for the first page of a page label range.
    &#34;&#34;&#34;
    if self.buffer:
        raise FPDFException(
            &#34;A page cannot be added on a closed document, after calling output()&#34;
        )

    self.current_font_is_set_on_page = False

    family = self.font_family
    emphasis = self.emphasis
    size = self.font_size_pt
    lw = self.line_width
    dc = self.draw_color
    fc = self.fill_color
    tc = self.text_color
    stretching = self.font_stretching
    char_spacing = self.char_spacing
    dash_pattern = self.dash_pattern

    in_toc_extra_page = (
        self.in_toc_rendering
        and self._toc_allow_page_insertion
        and self.page &gt; self.toc_placeholder.start_page
    )
    if self.page &gt; 0 and (not self.in_toc_rendering or in_toc_extra_page):
        # Page footer
        self._render_footer()

    current_page_label = (
        None if self.page == 0 else self.pages[self.page].get_page_label()
    )
    new_page_label = None
    if label_style or label_prefix or label_start:
        label_style = (
            PageLabelStyle.coerce(label_style, case_sensitive=True)
            if label_style
            else None
        )
        new_page_label = PDFPageLabel(label_style, label_prefix, label_start)

    # Start new page
    self._beginpage(
        orientation,
        format,
        same,
        duration or self.page_duration,
        transition or self.page_transition,
        new_page=not self._has_next_page(),
    )

    self.pages[self.page].set_page_label(current_page_label, new_page_label)

    if self.page_background:
        if isinstance(self.page_background, tuple):
            self.set_fill_color(*self.page_background)
            self.rect(0, 0, self.w, self.h, style=&#34;F&#34;)
            self.set_fill_color(*fc.colors255)
        else:
            self.image(self.page_background, 0, 0, self.w, self.h)

    self._out(&#34;2 J&#34;)  # Set line cap style to square
    self.line_width = lw  # Set line width
    self._out(f&#34;{lw * self.k:.2f} w&#34;)

    # Set font
    if family:
        self.set_font(family, emphasis, size)

    # Set colors
    self.draw_color = dc
    if dc != self.DEFAULT_DRAW_COLOR:
        self._out(dc.serialize().upper())
    self.fill_color = fc
    if fc != self.DEFAULT_FILL_COLOR:
        self._out(fc.serialize().lower())
    self.text_color = tc

    # BEGIN Page header
    if (not self.in_toc_rendering) or self._toc_allow_page_insertion:
        self.header()

    if self.line_width != lw:  # Restore line width
        self.line_width = lw
        self._out(f&#34;{lw * self.k:.2f} w&#34;)

    if family:
        self.set_font(family, emphasis, size)  # Restore font

    if self.draw_color != dc:  # Restore colors
        self.draw_color = dc
        self._out(dc.serialize().upper())
    if self.fill_color != fc:
        self.fill_color = fc
        self._out(fc.serialize().lower())
    self.text_color = tc

    if stretching != 100:  # Restore stretching
        self.set_stretching(stretching)
    if char_spacing != 0:
        self.set_char_spacing(char_spacing)
    if dash_pattern != dict(dash=0, gap=0, phase=0):
        self._write_dash_pattern(
            dash_pattern[&#34;dash&#34;], dash_pattern[&#34;gap&#34;], dash_pattern[&#34;phase&#34;]
        )
    # END Page header</code></pre>
</details>
<div class="desc"><p>Adds a new page to the document.
If a page is already present, the <code><a title="fpdf.fpdf.FPDF.footer" href="#fpdf.fpdf.FPDF.footer">FPDF.footer()</a></code> method is called first.
Then the page
is added, the current position is set to the top-left corner,
with respect to the left and top margins, and the <code><a title="fpdf.fpdf.FPDF.header" href="#fpdf.fpdf.FPDF.header">FPDF.header()</a></code> method is called.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>orientation</code></strong> :&ensp;<code>str</code></dt>
<dd>"portrait" (can be abbreviated "P")
or "landscape" (can be abbreviated "L"). Default to "portrait".</dd>
<dt><strong><code>format</code></strong> :&ensp;<code>str</code></dt>
<dd>"a3", "a4", "a5", "letter", "legal" or a tuple
(width, height). Default to "a4".</dd>
<dt><strong><code>same</code></strong> :&ensp;<code>bool</code></dt>
<dd>indicates to use the same page format as the previous page.
Default to False.</dd>
<dt><strong><code>duration</code></strong> :&ensp;<code>float</code></dt>
<dd>optional page’s display duration, i.e. the maximum length of time,
in seconds, that the page is displayed in presentation mode,
before the viewer application automatically advances to the next page.
Can be configured globally through the <code>.page_duration</code> FPDF property.
As of june 2021, onored by Adobe Acrobat reader, but ignored by Sumatra PDF reader.</dd>
<dt><strong><code>transition</code></strong> :&ensp;<code>Transition child class</code></dt>
<dd>optional visual transition to use when moving
from another page to the given page during a presentation.
Can be configured globally through the <code>.page_transition</code> FPDF property.
As of june 2021, onored by Adobe Acrobat reader, but ignored by Sumatra PDF reader.</dd>
<dt><strong><code>label_style</code></strong> :&ensp;<code>str</code> or <code>PageLabelStyle</code></dt>
<dd>Defines the numbering style for the numeric portion of each
page label. Possible values are:
- "D": Decimal Arabic numerals.
- "R": Uppercase Roman numerals.
- "r": Lowercase Roman numerals.
- "A": Uppercase letters (A to Z for the first 26 pages, followed by AA to ZZ, etc.).
- "a": Lowercase letters (a to z for the first 26 pages, followed by aa to zz, etc.).</dd>
<dt><strong><code>label_prefix</code></strong> :&ensp;<code>str</code></dt>
<dd>Prefix string applied to the page label, preceding the numeric portion.</dd>
<dt><strong><code>label_start</code></strong> :&ensp;<code>int</code></dt>
<dd>Starting number for the first page of a page label range.</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.add_text_markup_annotation"><code class="name flex">
<span>def <span class="ident">add_text_markup_annotation</span></span>(<span>self,<br>type,<br>text,<br>quad_points,<br>color=(1, 1, 0),<br>modification_time=None,<br>page=None,<br>**kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L2681-L2732" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@check_page
def add_text_markup_annotation(
    self,
    type,
    text,
    quad_points,
    color=(1, 1, 0),
    modification_time=None,
    page=None,
    **kwargs,
):
    &#34;&#34;&#34;
    Adds a text markup annotation on some quadrilateral areas of the page.

    Args:
        type (fpdf.enums.TextMarkupType, str): &#34;Highlight&#34;, &#34;Underline&#34;, &#34;Squiggly&#34; or &#34;StrikeOut&#34;
        text (str): text of the annotation
        quad_points (tuple): array of 8 × n numbers specifying the coordinates of n quadrilaterals
            in default user space that comprise the region in which the link should be activated.
            The coordinates for each quadrilateral are given in the order: x1 y1 x2 y2 x3 y3 x4 y4
            specifying the four vertices of the quadrilateral in counterclockwise order
        title (str): the text label that shall be displayed in the title bar of the annotation’s
            pop-up window when open and active. This entry shall identify the user who added the annotation.
        color (tuple): a tuple of numbers in the range 0.0 to 1.0, representing a colour used for
            the title bar of the annotation’s pop-up window. Defaults to yellow.
        modification_time (datetime): date and time when the annotation was most recently modified
        page (int): index of the page where this annotation is added
    &#34;&#34;&#34;
    self._set_min_pdf_version(&#34;1.6&#34;)
    type = TextMarkupType.coerce(type).value
    if modification_time is None:
        modification_time = self.creation_date
    if page is None:
        page = self.page
    x_min = min(quad_points[0::2])
    y_min = min(quad_points[1::2])
    x_max = max(quad_points[0::2])
    y_max = max(quad_points[1::2])
    annotation = AnnotationDict(
        type,
        contents=text,
        x=y_min,
        y=y_max,
        width=x_max - x_min,
        height=y_max - y_min,
        modification_time=modification_time,
        quad_points=quad_points,
        color=color,
        **kwargs,
    )
    self.pages[page].annots.append(annotation)
    return annotation</code></pre>
</details>
<div class="desc"><p>Adds a text markup annotation on some quadrilateral areas of the page.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>type</code></strong> :&ensp;<code><a title="fpdf.enums.TextMarkupType" href="enums.html#fpdf.enums.TextMarkupType">TextMarkupType</a>, str</code></dt>
<dd>"Highlight", "Underline", "Squiggly" or "StrikeOut"</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>text of the annotation</dd>
<dt><strong><code>quad_points</code></strong> :&ensp;<code>tuple</code></dt>
<dd>array of 8 × n numbers specifying the coordinates of n quadrilaterals
in default user space that comprise the region in which the link should be activated.
The coordinates for each quadrilateral are given in the order: x1 y1 x2 y2 x3 y3 x4 y4
specifying the four vertices of the quadrilateral in counterclockwise order</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code></dt>
<dd>the text label that shall be displayed in the title bar of the annotation’s
pop-up window when open and active. This entry shall identify the user who added the annotation.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>tuple</code></dt>
<dd>a tuple of numbers in the range 0.0 to 1.0, representing a colour used for
the title bar of the annotation’s pop-up window. Defaults to yellow.</dd>
<dt><strong><code>modification_time</code></strong> :&ensp;<code>datetime</code></dt>
<dd>date and time when the annotation was most recently modified</dd>
<dt><strong><code>page</code></strong> :&ensp;<code>int</code></dt>
<dd>index of the page where this annotation is added</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.alias_nb_pages"><code class="name flex">
<span>def <span class="ident">alias_nb_pages</span></span>(<span>self, alias='{nb}')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L903-L925" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def alias_nb_pages(self, alias=&#34;{nb}&#34;):
    &#34;&#34;&#34;
    Defines an alias for the total number of pages.
    It will be substituted as the document is closed.

    This is useful to insert the number of pages of the document
    at a time when this number is not known by the program.

    This substitution can be disabled for performances reasons, by calling `alias_nb_pages(None)`.

    Args:
        alias (str): the alias. Defaults to &#34;{nb}&#34;.

    Notes
    -----

    When using this feature with the `FPDF.cell` / `FPDF.multi_cell` methods,
    or the `.underline` / `.strikethrough` attributes of `FPDF` class,
    the width of the text rendered will take into account the alias length,
    not the length of the &#34;actual number of pages&#34; string,
    which can causes slight positioning differences.
    &#34;&#34;&#34;
    self.str_alias_nb_pages = alias</code></pre>
</details>
<div class="desc"><p>Defines an alias for the total number of pages.
It will be substituted as the document is closed.</p>
<p>This is useful to insert the number of pages of the document
at a time when this number is not known by the program.</p>
<p>This substitution can be disabled for performances reasons, by calling <code>alias_nb_pages(None)</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>alias</code></strong> :&ensp;<code>str</code></dt>
<dd>the alias. Defaults to "{nb}".</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>When using this feature with the <code><a title="fpdf.fpdf.FPDF.cell" href="#fpdf.fpdf.FPDF.cell">FPDF.cell()</a></code> / <code><a title="fpdf.fpdf.FPDF.multi_cell" href="#fpdf.fpdf.FPDF.multi_cell">FPDF.multi_cell()</a></code> methods,
or the <code>.underline</code> / <code>.strikethrough</code> attributes of <code><a title="fpdf.fpdf.FPDF" href="#fpdf.fpdf.FPDF">FPDF</a></code> class,
the width of the text rendered will take into account the alias length,
not the length of the "actual number of pages" string,
which can causes slight positioning differences.</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.arc"><code class="name flex">
<span>def <span class="ident">arc</span></span>(<span>self,<br>x,<br>y,<br>a,<br>start_angle,<br>end_angle,<br>b=None,<br>inclination=0,<br>clockwise=False,<br>start_from_center=False,<br>end_at_center=False,<br>style=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L1837-L1984" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@check_page
def arc(
    self,
    x,
    y,
    a,
    start_angle,
    end_angle,
    b=None,
    inclination=0,
    clockwise=False,
    start_from_center=False,
    end_at_center=False,
    style=None,
):
    &#34;&#34;&#34;
    Outputs an arc.
    It can be drawn (border only), filled (with no border) or both.

    Args:
        x (float): Abscissa of upper-left corner of the bounding box of the full ellipse.
        y (float): Ordinate of upper-left corner of the bounding box of the full ellipse.
        a (float): Major axis diameter (width of bounding box).
        b (float): Minor axis diameter (height of bounding box), if None, equals to a (default: None).
        start_angle (float): Start angle of the arc (in degrees).
        end_angle (float): End angle of the arc (in degrees).
        inclination (float): Inclination of the arc in respect of the x-axis (default: 0).
        clockwise (bool): Way of drawing the arc (True: clockwise, False: counterclockwise) (default: False).
        start_from_center (bool): Start drawing from the center of the ellipse (default: False).
        end_at_center (bool): End drawing at the center of the ellipse (default: False).
        style (fpdf.enums.RenderStyle, str): Optional style of rendering. Allowed values are:

        * `D` or None: draw border. This is the default value.
        * `F`: fill
        * `DF` or `FD`: draw and fill
    &#34;&#34;&#34;
    style = RenderStyle.coerce(style)

    if b is None:
        b = a

    a /= 2
    b /= 2

    cx = x + a
    cy = y + b

    # Functions used only to construct other points of the bezier curve
    def deg_to_rad(deg):
        return deg * math.pi / 180

    def angle_to_param(angle):
        angle = deg_to_rad(angle % 360)
        eta = math.atan2(math.sin(angle) / b, math.cos(angle) / a)

        if eta &lt; 0:
            eta += 2 * math.pi
        return eta

    theta = deg_to_rad(inclination)
    cos_theta = math.cos(theta)
    sin_theta = math.sin(theta)

    def evaluate(eta):
        a_cos_eta = a * math.cos(eta)
        b_sin_eta = b * math.sin(eta)

        return [
            cx + a_cos_eta * cos_theta - b_sin_eta * sin_theta,
            cy + a_cos_eta * sin_theta + b_sin_eta * cos_theta,
        ]

    def derivative_evaluate(eta):
        a_sin_eta = a * math.sin(eta)
        b_cos_eta = b * math.cos(eta)

        return [
            -a_sin_eta * cos_theta - b_cos_eta * sin_theta,
            -a_sin_eta * sin_theta + b_cos_eta * cos_theta,
        ]

    # Calculating start_eta and end_eta so that
    #   start_eta &lt; end_eta   &lt;= start_eta + 2*PI if counterclockwise
    #   end_eta   &lt; start_eta &lt;= end_eta + 2*PI   if clockwise
    start_eta = angle_to_param(start_angle)
    end_eta = angle_to_param(end_angle)

    if not clockwise and end_eta &lt;= start_eta:
        end_eta += 2 * math.pi
    elif clockwise and end_eta &gt;= start_eta:
        start_eta += 2 * math.pi

    start_point = evaluate(start_eta)

    # Move to the start point
    if start_from_center:
        self._out(f&#34;{cx * self.k:.2f} {(self.h - cy) * self.k:.2f} m&#34;)
        self._out(
            f&#34;{start_point[0] * self.k:.2f} {(self.h - start_point[1]) * self.k:.2f} l&#34;
        )
    else:
        self._out(
            f&#34;{start_point[0] * self.k:.2f} {(self.h - start_point[1]) * self.k:.2f} m&#34;
        )

    # Number of curves to use, maximal segment angle is 2*PI/max_curves
    max_curves = 4
    n = min(
        max_curves, math.ceil(abs(end_eta - start_eta) / (2 * math.pi / max_curves))
    )
    d_eta = (end_eta - start_eta) / n

    alpha = math.sin(d_eta) * (math.sqrt(4 + 3 * math.tan(d_eta / 2) ** 2) - 1) / 3

    eta2 = start_eta
    p2 = evaluate(eta2)
    p2_prime = derivative_evaluate(eta2)

    for i in range(n):
        p1 = p2
        p1_prime = p2_prime

        eta2 += d_eta
        p2 = evaluate(eta2)
        p2_prime = derivative_evaluate(eta2)

        control_point_1 = [p1[0] + alpha * p1_prime[0], p1[1] + alpha * p1_prime[1]]
        control_point_2 = [p2[0] - alpha * p2_prime[0], p2[1] - alpha * p2_prime[1]]

        end = &#34;&#34;
        if i == n - 1 and not end_at_center:
            end = f&#34; {style.operator}&#34;

        self._out(
            (
                f&#34;{control_point_1[0] * self.k:.2f} {(self.h - control_point_1[1]) * self.k:.2f} &#34;
                f&#34;{control_point_2[0] * self.k:.2f} {(self.h - control_point_2[1]) * self.k:.2f} &#34;
                f&#34;{p2[0] * self.k:.2f} {(self.h - p2[1]) * self.k:.2f} c&#34; + end
            )
        )

    if end_at_center:
        if start_from_center:
            self._out(f&#34;h {style.operator}&#34;)
        else:
            self._out(
                f&#34;{cx * self.k:.2f} {(self.h - cy) * self.k:.2f} l {style.operator}&#34;
            )</code></pre>
</details>
<div class="desc"><p>Outputs an arc.
It can be drawn (border only), filled (with no border) or both.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>Abscissa of upper-left corner of the bounding box of the full ellipse.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>Ordinate of upper-left corner of the bounding box of the full ellipse.</dd>
<dt><strong><code>a</code></strong> :&ensp;<code>float</code></dt>
<dd>Major axis diameter (width of bounding box).</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>float</code></dt>
<dd>Minor axis diameter (height of bounding box), if None, equals to a (default: None).</dd>
<dt><strong><code>start_angle</code></strong> :&ensp;<code>float</code></dt>
<dd>Start angle of the arc (in degrees).</dd>
<dt><strong><code>end_angle</code></strong> :&ensp;<code>float</code></dt>
<dd>End angle of the arc (in degrees).</dd>
<dt><strong><code>inclination</code></strong> :&ensp;<code>float</code></dt>
<dd>Inclination of the arc in respect of the x-axis (default: 0).</dd>
<dt><strong><code>clockwise</code></strong> :&ensp;<code>bool</code></dt>
<dd>Way of drawing the arc (True: clockwise, False: counterclockwise) (default: False).</dd>
<dt><strong><code>start_from_center</code></strong> :&ensp;<code>bool</code></dt>
<dd>Start drawing from the center of the ellipse (default: False).</dd>
<dt><strong><code>end_at_center</code></strong> :&ensp;<code>bool</code></dt>
<dd>End drawing at the center of the ellipse (default: False).</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.enums.RenderStyle" href="enums.html#fpdf.enums.RenderStyle">RenderStyle</a>, str</code></dt>
<dd>Optional style of rendering. Allowed values are:</dd>
</dl>
<ul>
<li><code>D</code> or None: draw border. This is the default value.</li>
<li><code>F</code>: fill</li>
<li><code>DF</code> or <code>FD</code>: draw and fill</li>
</ul></div>
</dd>
<dt id="fpdf.fpdf.FPDF.bezier"><code class="name flex">
<span>def <span class="ident">bezier</span></span>(<span>self, point_list, closed=False, style=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L2031-L2093" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def bezier(self, point_list, closed=False, style=None):
    &#34;&#34;&#34;
    Outputs a quadratic or cubic Bézier curve, defined by three or four coordinates.

    Args:
        point_list (list of tuples): List of Abscissa and Ordinate of
                                    segments that should be drawn. Should be
                                    three or four tuples. The first and last
                                    points are the start and end point. The
                                    middle point(s) are the control point(s).
        closed (bool): True to draw the curve as a closed path, False (default)
                                    for it to be drawn as an open path.
        style (fpdf.enums.RenderStyle, str): Optional style of rendering. Allowed values are:
        * `D` or None: draw border. This is the default value.
        * `F`: fill
        * `DF` or `FD`: draw and fill
    &#34;&#34;&#34;
    points = len(point_list)
    if points not in (3, 4):
        raise ValueError(
            &#34;point_list should contain 3 tuples for a quadratic curve&#34;
            &#34; or 4 tuples for a cubic curve.&#34;
        )
    style = RenderStyle.coerce(style)

    # QuadraticBezierCurve and BezierCurve make use of `initial_point` when instantiated.
    # If we want to define all 3 (quad.) or 4 (cubic) points, we can set `initial_point`
    # to be the first point given in `point_list` by creating a separate dummy path at that pos.
    with self.drawing_context() as ctxt:
        p1 = point_list[0]
        x1, y1 = p1[0], p1[1]

        dummy_path = PaintedPath(x1, y1)
        ctxt.add_item(dummy_path)

        p2 = point_list[1]
        x2, y2 = p2[0], p2[1]

        p3 = point_list[2]
        x3, y3 = p3[0], p3[1]

        if points == 4:
            p4 = point_list[3]
            x4, y4 = p4[0], p4[1]

        path = PaintedPath(x1, y1)

        # Translate enum style (RenderStyle) into rule (PathPaintRule)
        rule = PathPaintRule.STROKE_FILL_NONZERO
        if style.is_draw and not style.is_fill:
            rule = PathPaintRule.STROKE
        elif style.is_fill and not style.is_draw:
            rule = PathPaintRule.FILL_NONZERO

        path.style.paint_rule = rule
        path.style.auto_close = closed

        if points == 4:
            path.curve_to(x2, y2, x3, y3, x4, y4)
        elif points == 3:
            path.curve_to(x2, y2, x2, y2, x3, y3)

        ctxt.add_item(path)</code></pre>
</details>
<div class="desc"><p>Outputs a quadratic or cubic Bézier curve, defined by three or four coordinates.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>point_list</code></strong> :&ensp;<code>list</code> of <code>tuples</code></dt>
<dd>List of Abscissa and Ordinate of
segments that should be drawn. Should be
three or four tuples. The first and last
points are the start and end point. The
middle point(s) are the control point(s).</dd>
<dt><strong><code>closed</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to draw the curve as a closed path, False (default)
for it to be drawn as an open path.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.enums.RenderStyle" href="enums.html#fpdf.enums.RenderStyle">RenderStyle</a>, str</code></dt>
<dd>Optional style of rendering. Allowed values are:</dd>
</dl>
<ul>
<li><code>D</code> or None: draw border. This is the default value.</li>
<li><code>F</code>: fill</li>
<li><code>DF</code> or <code>FD</code>: draw and fill</li>
</ul></div>
</dd>
<dt id="fpdf.fpdf.FPDF.cell"><code class="name flex">
<span>def <span class="ident">cell</span></span>(<span>self,<br>w=None,<br>h=None,<br>text='',<br>border=0,<br>ln='DEPRECATED',<br>align=Align.L,<br>fill=False,<br>link='',<br>center=False,<br>markdown=False,<br>new_x=XPos.RIGHT,<br>new_y=YPos.TOP)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L3137-L3263" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@check_page
@support_deprecated_txt_arg
def cell(
    self,
    w=None,
    h=None,
    text=&#34;&#34;,
    border=0,
    ln=&#34;DEPRECATED&#34;,
    align=Align.L,
    fill=False,
    link=&#34;&#34;,
    center=False,
    markdown=False,
    new_x=XPos.RIGHT,
    new_y=YPos.TOP,
):
    &#34;&#34;&#34;
    Prints a cell (rectangular area) with optional borders, background color and
    character string. The upper-left corner of the cell corresponds to the current
    position. The text can be aligned or centered. After the call, the current
    position moves to the selected `new_x`/`new_y` position. It is possible to put a link
    on the text. A cell has an horizontal padding, on the left &amp; right sides, defined by
    the.c_margin property.

    If automatic page breaking is enabled and the cell goes beyond the limit, a
    page break is performed before outputting.

    Args:
        w (float): Cell width. Default value: None, meaning to fit text width.
            If 0, the cell extends up to the right margin.
        h (float): Cell height. Default value: None, meaning an height equal
            to the current font size.
        text (str): String to print. Default value: empty string.
        border: Indicates if borders must be drawn around the cell.
            The value can be either a number (`0`: no border ; `1`: frame)
            or a string containing some or all of the following characters
            (in any order):
            `L`: left ; `T`: top ; `R`: right ; `B`: bottom. Default value: 0.
        new_x (fpdf.enums.XPos, str): New current position in x after the call. Default: RIGHT
        new_y (fpdf.enums.YPos, str): New current position in y after the call. Default: TOP
        ln (int): **DEPRECATED since 2.5.1**: Use `new_x` and `new_y` instead.
        align (fpdf.enums.Align, str): Set text alignment inside the cell.
            Possible values are: `L` or empty string: left align (default value) ;
            `C`: center; `X`: center around current x position; `R`: right align
        fill (bool): Indicates if the cell background must be painted (`True`)
            or transparent (`False`). Default value: False.
        link (str): optional link to add on the cell, internal
            (identifier returned by `FPDF.add_link`) or external URL.
        center (bool): center the cell horizontally on the page.
        markdown (bool): enable minimal markdown-like markup to render part
            of text as bold / italics / strikethrough / underlined.
            Supports `\\` as escape character. Default to False.
        txt (str): [**DEPRECATED since v2.7.6**] String to print. Default value: empty string.

    Returns: a boolean indicating if page break was triggered
    &#34;&#34;&#34;
    if not self.font_family:
        raise FPDFException(&#34;No font set, you need to call set_font() beforehand&#34;)
    if isinstance(w, str) or isinstance(h, str):
        raise ValueError(
            &#34;Parameter &#39;w&#39; and &#39;h&#39; must be numbers, not strings.&#34;
            &#34; You can omit them by passing string content with text=&#34;
        )
    if isinstance(border, int) and border not in (0, 1):
        warnings.warn(
            &#39;Integer values for &#34;border&#34; parameter other than 1 are currently ignored&#39;,
            stacklevel=get_stack_level(),
        )
        border = 1
    new_x = XPos.coerce(new_x)
    new_y = YPos.coerce(new_y)
    align = Align.coerce(align)
    if align == Align.J:
        raise ValueError(
            &#34;cell() only produces one text line, justified alignment is not possible&#34;
        )
    if ln != &#34;DEPRECATED&#34;:
        # For backwards compatibility, if &#34;ln&#34; is used we overwrite &#34;new_[xy]&#34;.
        if ln == 0:
            new_x = XPos.RIGHT
            new_y = YPos.TOP
        elif ln == 1:
            new_x = XPos.LMARGIN
            new_y = YPos.NEXT
        elif ln == 2:
            new_x = XPos.LEFT
            new_y = YPos.NEXT
        else:
            raise ValueError(
                f&#39;Invalid value for parameter &#34;ln&#34; ({ln}),&#39;
                &#34; must be an int between 0 and 2.&#34;
            )
        warnings.warn(
            (
                &#39;The parameter &#34;ln&#34; is deprecated since v2.5.2.&#39;
                f&#34; Instead of ln={ln} use new_x=XPos.{new_x.name}, new_y=YPos.{new_y.name}.&#34;
            ),
            DeprecationWarning,
            stacklevel=get_stack_level(),
        )
    # Font styles preloading must be performed before any call to FPDF.get_string_width:
    text = self.normalize_text(text)
    styled_txt_frags = (
        self._preload_bidirectional_text(text, markdown)
        if self.text_shaping
        else self._preload_font_styles(text, markdown)
    )
    return self._render_styled_text_line(
        TextLine(
            styled_txt_frags,
            text_width=0,
            number_of_spaces=0,
            align=Align.L if align == Align.J else align,
            height=h,
            max_width=w,
            trailing_nl=False,
        ),
        h,
        border,
        new_x=new_x,
        new_y=new_y,
        fill=fill,
        link=link,
        center=center,
        prevent_font_change=markdown,
    )</code></pre>
</details>
<div class="desc"><p>Prints a cell (rectangular area) with optional borders, background color and
character string. The upper-left corner of the cell corresponds to the current
position. The text can be aligned or centered. After the call, the current
position moves to the selected <code>new_x</code>/<code>new_y</code> position. It is possible to put a link
on the text. A cell has an horizontal padding, on the left &amp; right sides, defined by
the.c_margin property.</p>
<p>If automatic page breaking is enabled and the cell goes beyond the limit, a
page break is performed before outputting.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>w</code></strong> :&ensp;<code>float</code></dt>
<dd>Cell width. Default value: None, meaning to fit text width.
If 0, the cell extends up to the right margin.</dd>
<dt><strong><code>h</code></strong> :&ensp;<code>float</code></dt>
<dd>Cell height. Default value: None, meaning an height equal
to the current font size.</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>String to print. Default value: empty string.</dd>
<dt><strong><code>border</code></strong></dt>
<dd>Indicates if borders must be drawn around the cell.
The value can be either a number (<code>0</code>: no border ; <code>1</code>: frame)
or a string containing some or all of the following characters
(in any order):
<code>L</code>: left ; <code>T</code>: top ; <code>R</code>: right ; <code>B</code>: bottom. Default value: 0.</dd>
<dt><strong><code>new_x</code></strong> :&ensp;<code><a title="fpdf.enums.XPos" href="enums.html#fpdf.enums.XPos">XPos</a>, str</code></dt>
<dd>New current position in x after the call. Default: RIGHT</dd>
<dt><strong><code>new_y</code></strong> :&ensp;<code><a title="fpdf.enums.YPos" href="enums.html#fpdf.enums.YPos">YPos</a>, str</code></dt>
<dd>New current position in y after the call. Default: TOP</dd>
<dt><strong><code>ln</code></strong> :&ensp;<code>int</code></dt>
<dd><strong>DEPRECATED since 2.5.1</strong>: Use <code>new_x</code> and <code>new_y</code> instead.</dd>
<dt><strong><code>align</code></strong> :&ensp;<code><a title="fpdf.enums.Align" href="enums.html#fpdf.enums.Align">Align</a>, str</code></dt>
<dd>Set text alignment inside the cell.
Possible values are: <code>L</code> or empty string: left align (default value) ;
<code>C</code>: center; <code>X</code>: center around current x position; <code>R</code>: right align</dd>
<dt><strong><code>fill</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates if the cell background must be painted (<code>True</code>)
or transparent (<code>False</code>). Default value: False.</dd>
<dt><strong><code>link</code></strong> :&ensp;<code>str</code></dt>
<dd>optional link to add on the cell, internal
(identifier returned by <code><a title="fpdf.fpdf.FPDF.add_link" href="#fpdf.fpdf.FPDF.add_link">FPDF.add_link()</a></code>) or external URL.</dd>
<dt><strong><code>center</code></strong> :&ensp;<code>bool</code></dt>
<dd>center the cell horizontally on the page.</dd>
<dt><strong><code>markdown</code></strong> :&ensp;<code>bool</code></dt>
<dd>enable minimal markdown-like markup to render part
of text as bold / italics / strikethrough / underlined.
Supports <code>\</code> as escape character. Default to False.</dd>
<dt><strong><code>txt</code></strong> :&ensp;<code>str</code></dt>
<dd>[<strong>DEPRECATED since v2.7.6</strong>] String to print. Default value: empty string.</dd>
</dl>
<p>Returns: a boolean indicating if page break was triggered</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.circle"><code class="name flex">
<span>def <span class="ident">circle</span></span>(<span>self, x, y, radius, style=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L1750-L1768" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@check_page
def circle(self, x, y, radius, style=None):
    &#34;&#34;&#34;
    Outputs a circle.
    It can be drawn (border only), filled (with no border) or both.

    WARNING: This method changed parameters in [release 2.8.0](https://github.com/py-pdf/fpdf2/releases/tag/2.8.0)

    Args:
        x (float): Abscissa of upper-left bounding box.
        y (float): Ordinate of upper-left bounding box.
        radius (float): Radius of the circle.
        style (str): Style of rendering. Possible values are:

        * `D` or None: draw border. This is the default value.
        * `F`: fill
        * `DF` or `FD`: draw and fill
    &#34;&#34;&#34;
    self.ellipse(x - radius, y - radius, 2 * radius, 2 * radius, style)</code></pre>
</details>
<div class="desc"><p>Outputs a circle.
It can be drawn (border only), filled (with no border) or both.</p>
<p>WARNING: This method changed parameters in <a href="https://github.com/py-pdf/fpdf2/releases/tag/2.8.0">release 2.8.0</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>Abscissa of upper-left bounding box.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>Ordinate of upper-left bounding box.</dd>
<dt><strong><code>radius</code></strong> :&ensp;<code>float</code></dt>
<dd>Radius of the circle.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code>str</code></dt>
<dd>Style of rendering. Possible values are:</dd>
</dl>
<ul>
<li><code>D</code> or None: draw border. This is the default value.</li>
<li><code>F</code>: fill</li>
<li><code>DF</code> or <code>FD</code>: draw and fill</li>
</ul></div>
</dd>
<dt id="fpdf.fpdf.FPDF.code39"><code class="name flex">
<span>def <span class="ident">code39</span></span>(<span>self, text, x, y, w=1.5, h=5)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L5184-L5252" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@check_page
@support_deprecated_txt_arg
def code39(self, text, x, y, w=1.5, h=5):
    &#34;&#34;&#34;Barcode 3of9&#34;&#34;&#34;
    dim = {&#34;w&#34;: w, &#34;n&#34;: w / 3}
    if not text.startswith(&#34;*&#34;) or not text.endswith(&#34;*&#34;):
        warnings.warn(
            (
                &#34;Code 39 input must start and end with a &#39;*&#39; character to be valid.&#34;
                &#34; This method does not insert it automatically.&#34;
            ),
            stacklevel=get_stack_level(),
        )
    chars = {
        &#34;0&#34;: &#34;nnnwwnwnn&#34;,
        &#34;1&#34;: &#34;wnnwnnnnw&#34;,
        &#34;2&#34;: &#34;nnwwnnnnw&#34;,
        &#34;3&#34;: &#34;wnwwnnnnn&#34;,
        &#34;4&#34;: &#34;nnnwwnnnw&#34;,
        &#34;5&#34;: &#34;wnnwwnnnn&#34;,
        &#34;6&#34;: &#34;nnwwwnnnn&#34;,
        &#34;7&#34;: &#34;nnnwnnwnw&#34;,
        &#34;8&#34;: &#34;wnnwnnwnn&#34;,
        &#34;9&#34;: &#34;nnwwnnwnn&#34;,
        &#34;A&#34;: &#34;wnnnnwnnw&#34;,
        &#34;B&#34;: &#34;nnwnnwnnw&#34;,
        &#34;C&#34;: &#34;wnwnnwnnn&#34;,
        &#34;D&#34;: &#34;nnnnwwnnw&#34;,
        &#34;E&#34;: &#34;wnnnwwnnn&#34;,
        &#34;F&#34;: &#34;nnwnwwnnn&#34;,
        &#34;G&#34;: &#34;nnnnnwwnw&#34;,
        &#34;H&#34;: &#34;wnnnnwwnn&#34;,
        &#34;I&#34;: &#34;nnwnnwwnn&#34;,
        &#34;J&#34;: &#34;nnnnwwwnn&#34;,
        &#34;K&#34;: &#34;wnnnnnnww&#34;,
        &#34;L&#34;: &#34;nnwnnnnww&#34;,
        &#34;M&#34;: &#34;wnwnnnnwn&#34;,
        &#34;N&#34;: &#34;nnnnwnnww&#34;,
        &#34;O&#34;: &#34;wnnnwnnwn&#34;,
        &#34;P&#34;: &#34;nnwnwnnwn&#34;,
        &#34;Q&#34;: &#34;nnnnnnwww&#34;,
        &#34;R&#34;: &#34;wnnnnnwwn&#34;,
        &#34;S&#34;: &#34;nnwnnnwwn&#34;,
        &#34;T&#34;: &#34;nnnnwnwwn&#34;,
        &#34;U&#34;: &#34;wwnnnnnnw&#34;,
        &#34;V&#34;: &#34;nwwnnnnnw&#34;,
        &#34;W&#34;: &#34;wwwnnnnnn&#34;,
        &#34;X&#34;: &#34;nwnnwnnnw&#34;,
        &#34;Y&#34;: &#34;wwnnwnnnn&#34;,
        &#34;Z&#34;: &#34;nwwnwnnnn&#34;,
        &#34;-&#34;: &#34;nwnnnnwnw&#34;,
        &#34;.&#34;: &#34;wwnnnnwnn&#34;,
        &#34; &#34;: &#34;nwwnnnwnn&#34;,
        &#34;*&#34;: &#34;nwnnwnwnn&#34;,
        &#34;$&#34;: &#34;nwnwnwnnn&#34;,
        &#34;/&#34;: &#34;nwnwnnnwn&#34;,
        &#34;+&#34;: &#34;nwnnnwnwn&#34;,
        &#34;%&#34;: &#34;nnnwnwnwn&#34;,
    }
    # The caller should do this, or we can&#39;t rotate the thing.
    # self.set_fill_color(0)
    for c in text.upper():
        if c not in chars:
            raise RuntimeError(f&#39;Invalid char &#34;{c}&#34; for Code39&#39;)
        for i, d in enumerate(chars[c]):
            if i % 2 == 0:
                self.rect(x, y, dim[d], h, &#34;F&#34;)
            x += dim[d]
        x += dim[&#34;n&#34;]</code></pre>
</details>
<div class="desc"><p>Barcode 3of9</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.dashed_line"><code class="name flex">
<span>def <span class="ident">dashed_line</span></span>(<span>self, x1, y1, x2, y2, dash_length=1, space_length=1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L1554-L1581" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@check_page
def dashed_line(self, x1, y1, x2, y2, dash_length=1, space_length=1):
    &#34;&#34;&#34;
    Draw a dashed line between two points.

    Args:
        x1 (float): Abscissa of first point
        y1 (float): Ordinate of first point
        x2 (float): Abscissa of second point
        y2 (float): Ordinate of second point
        dash_length (float): Length of the dash
        space_length (float): Length of the space between 2 dashes

    .. deprecated:: 2.4.6
        Use `FPDF.set_dash_pattern()` and the normal drawing operations instead.
    &#34;&#34;&#34;
    warnings.warn(
        (
            &#34;dashed_line() is deprecated since v2.4.6, &#34;
            &#34;and will be removed in a future release. &#34;
            &#34;Use set_dash_pattern() and the normal drawing operations instead.&#34;
        ),
        DeprecationWarning,
        stacklevel=get_stack_level(),
    )
    self.set_dash_pattern(dash_length, space_length)
    self.line(x1, y1, x2, y2)
    self.set_dash_pattern()</code></pre>
</details>
<div class="desc"><p>Draw a dashed line between two points.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x1</code></strong> :&ensp;<code>float</code></dt>
<dd>Abscissa of first point</dd>
<dt><strong><code>y1</code></strong> :&ensp;<code>float</code></dt>
<dd>Ordinate of first point</dd>
<dt><strong><code>x2</code></strong> :&ensp;<code>float</code></dt>
<dd>Abscissa of second point</dd>
<dt><strong><code>y2</code></strong> :&ensp;<code>float</code></dt>
<dd>Ordinate of second point</dd>
<dt><strong><code>dash_length</code></strong> :&ensp;<code>float</code></dt>
<dd>Length of the dash</dd>
<dt><strong><code>space_length</code></strong> :&ensp;<code>float</code></dt>
<dd>Length of the space between 2 dashes</dd>
</dl>
<div class="admonition deprecated">
<p class="admonition-title">Deprecated since version:&ensp;2.4.6</p>
<p>Use <code><a title="fpdf.fpdf.FPDF.set_dash_pattern" href="#fpdf.fpdf.FPDF.set_dash_pattern">FPDF.set_dash_pattern()</a></code> and the normal drawing operations instead.</p>
</div></div>
</dd>
<dt id="fpdf.fpdf.FPDF.draw_path"><code class="name flex">
<span>def <span class="ident">draw_path</span></span>(<span>self, path, debug_stream=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L1429-L1440" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def draw_path(self, path, debug_stream=None):
    &#34;&#34;&#34;
    Add a pre-constructed path to the document.

    Args:
        path (drawing.PaintedPath): the path to be drawn.
        debug_stream (TextIO): print a pretty tree of all items to be rendered
            to the provided stream. To store the output in a string, use
            `io.StringIO`.
    &#34;&#34;&#34;
    with self.drawing_context(debug_stream=debug_stream) as ctxt:
        ctxt.add_item(path)</code></pre>
</details>
<div class="desc"><p>Add a pre-constructed path to the document.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>drawing.PaintedPath</code></dt>
<dd>the path to be drawn.</dd>
<dt><strong><code>debug_stream</code></strong> :&ensp;<code>TextIO</code></dt>
<dd>print a pretty tree of all items to be rendered
to the provided stream. To store the output in a string, use
<code>io.StringIO</code>.</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.drawing_context"><code class="name flex">
<span>def <span class="ident">drawing_context</span></span>(<span>self, debug_stream=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L1309-L1364" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@contextmanager
@check_page
def drawing_context(self, debug_stream=None):
    &#34;&#34;&#34;
    Create a context for drawing paths on the current page.

    If this context manager is called again inside of an active context, it will
    raise an exception, as base drawing contexts cannot be nested.

    Args:
        debug_stream (TextIO): print a pretty tree of all items to be rendered
            to the provided stream. To store the output in a string, use
            `io.StringIO`.
    &#34;&#34;&#34;

    if self._current_draw_context is not None:
        raise FPDFException(
            &#34;cannot create a drawing context while one is already open&#34;
        )

    context = DrawingContext()
    self._current_draw_context = context
    try:
        yield context
    finally:
        self._current_draw_context = None

    starting_style = self._current_graphic_style()
    render_args = (
        self._drawing_graphics_state_registry,
        Point(self.x, self.y),
        self.k,
        self.h,
        starting_style,
    )

    if debug_stream:
        rendered = context.render_debug(*render_args, debug_stream)
    else:
        rendered = context.render(*render_args)

    for match in self._GS_REGEX.finditer(rendered):
        self._resource_catalog.add(
            PDFResourceType.EXT_G_STATE, match.group(1), self.page
        )
    # Registering raster images embedded in the vector graphics:
    for match in self._IMG_REGEX.finditer(rendered):
        self._resource_catalog.add(
            PDFResourceType.X_OBJECT, int(match.group(1)), self.page
        )
    # Once we handle text-rendering SVG tags (cf. PR #1029),
    # we should also detect fonts used and add them to the resource catalog

    self._out(rendered)
    # The drawing API makes use of features (notably transparency and blending modes) that were introduced in PDF 1.4:
    self._set_min_pdf_version(&#34;1.4&#34;)</code></pre>
</details>
<div class="desc"><p>Create a context for drawing paths on the current page.</p>
<p>If this context manager is called again inside of an active context, it will
raise an exception, as base drawing contexts cannot be nested.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>debug_stream</code></strong> :&ensp;<code>TextIO</code></dt>
<dd>print a pretty tree of all items to be rendered
to the provided stream. To store the output in a string, use
<code>io.StringIO</code>.</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.ellipse"><code class="name flex">
<span>def <span class="ident">ellipse</span></span>(<span>self, x, y, w, h, style=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L1691-L1709" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@check_page
def ellipse(self, x, y, w, h, style=None):
    &#34;&#34;&#34;
    Outputs an ellipse.
    It can be drawn (border only), filled (with no border) or both.

    Args:
        x (float): Abscissa of upper-left bounding box.
        y (float): Ordinate of upper-left bounding box.
        w (float): Width
        h (float): Height
        style (fpdf.enums.RenderStyle, str): Optional style of rendering. Possible values are:

        * `D` or empty string: draw border. This is the default value.
        * `F`: fill
        * `DF` or `FD`: draw and fill
    &#34;&#34;&#34;
    style = RenderStyle.coerce(style)
    self._draw_ellipse(x, y, w, h, style.operator)</code></pre>
</details>
<div class="desc"><p>Outputs an ellipse.
It can be drawn (border only), filled (with no border) or both.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>Abscissa of upper-left bounding box.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>Ordinate of upper-left bounding box.</dd>
<dt><strong><code>w</code></strong> :&ensp;<code>float</code></dt>
<dd>Width</dd>
<dt><strong><code>h</code></strong> :&ensp;<code>float</code></dt>
<dd>Height</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.enums.RenderStyle" href="enums.html#fpdf.enums.RenderStyle">RenderStyle</a>, str</code></dt>
<dd>Optional style of rendering. Possible values are:</dd>
</dl>
<ul>
<li><code>D</code> or empty string: draw border. This is the default value.</li>
<li><code>F</code>: fill</li>
<li><code>DF</code> or <code>FD</code>: draw and fill</li>
</ul></div>
</dd>
<dt id="fpdf.fpdf.FPDF.elliptic_clip"><code class="name flex">
<span>def <span class="ident">elliptic_clip</span></span>(<span>self, x, y, w, h)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L5276-L5292" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@check_page
@contextmanager
def elliptic_clip(self, x, y, w, h):
    &#34;&#34;&#34;
    Context manager that defines an elliptic crop zone,
    useful to render only part of an image.

    Args:
        x (float): abscissa of the clipping region top left corner
        y (float): ordinate of the clipping region top left corner
        w (float): ellipse width
        h (float): ellipse height
    &#34;&#34;&#34;
    self._out(&#34;q&#34;)
    self._draw_ellipse(x, y, w, h, &#34;W n&#34;)
    yield
    self._out(&#34;Q&#34;)</code></pre>
</details>
<div class="desc"><p>Context manager that defines an elliptic crop zone,
useful to render only part of an image.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>abscissa of the clipping region top left corner</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>ordinate of the clipping region top left corner</dd>
<dt><strong><code>w</code></strong> :&ensp;<code>float</code></dt>
<dd>ellipse width</dd>
<dt><strong><code>h</code></strong> :&ensp;<code>float</code></dt>
<dd>ellipse height</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.embed_file"><code class="name flex">
<span>def <span class="ident">embed_file</span></span>(<span>self, file_path=None, bytes=None, basename=None, modification_date=None, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L2437-L2492" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def embed_file(
    self,
    file_path=None,
    bytes=None,
    basename=None,
    modification_date=None,
    **kwargs,
):
    &#34;&#34;&#34;
    Embed a file into the PDF document

    Args:
        file_path (str or Path): filesystem path to the existing file to embed
        bytes (bytes): optional, as an alternative to file_path, bytes content of the file to embed
        basename (str): optional, required if bytes is provided, file base name
        creation_date (datetime): date and time when the file was created
        modification_date (datetime): date and time when the file was last modified
        desc (str): optional description of the file
        compress (bool): enabled zlib compression of the file - False by default
        checksum (bool): insert a MD5 checksum of the file content - False by default

    Returns: a PDFEmbeddedFile instance, with a .basename string attribute representing the internal file name
    &#34;&#34;&#34;
    if file_path:
        if bytes:
            raise ValueError(&#34;&#39;bytes&#39; cannot be provided with &#39;file_path&#39;&#34;)
        if basename:
            raise ValueError(&#34;&#39;basename&#39; cannot be provided with &#39;file_path&#39;&#34;)
        file_path = Path(file_path)
        with file_path.open(&#34;rb&#34;) as input_file:
            bytes = input_file.read()
        basename = file_path.name
        stats = file_path.stat()
        if modification_date is None:
            modification_date = datetime.fromtimestamp(stats.st_mtime).astimezone()
    else:
        if not bytes:
            raise ValueError(&#34;&#39;bytes&#39; is required if &#39;file_path&#39; is not provided&#34;)
        if not basename:
            raise ValueError(
                &#34;&#39;basename&#39; is required if &#39;file_path&#39; is not provided&#34;
            )
    already_embedded_basenames = set(
        file.basename() for file in self.embedded_files
    )
    if basename in already_embedded_basenames:
        raise ValueError(f&#34;{basename} has already been embedded in this file&#34;)
    embedded_file = PDFEmbeddedFile(
        basename=basename,
        contents=bytes,
        modification_date=modification_date,
        **kwargs,
    )
    self.embedded_files.append(embedded_file)
    self._set_min_pdf_version(&#34;1.4&#34;)
    return embedded_file</code></pre>
</details>
<div class="desc"><p>Embed a file into the PDF document</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code> or <code>Path</code></dt>
<dd>filesystem path to the existing file to embed</dd>
<dt><strong><code>bytes</code></strong> :&ensp;<code>bytes</code></dt>
<dd>optional, as an alternative to file_path, bytes content of the file to embed</dd>
<dt><strong><code>basename</code></strong> :&ensp;<code>str</code></dt>
<dd>optional, required if bytes is provided, file base name</dd>
<dt><strong><code>creation_date</code></strong> :&ensp;<code>datetime</code></dt>
<dd>date and time when the file was created</dd>
<dt><strong><code>modification_date</code></strong> :&ensp;<code>datetime</code></dt>
<dd>date and time when the file was last modified</dd>
<dt><strong><code>desc</code></strong> :&ensp;<code>str</code></dt>
<dd>optional description of the file</dd>
<dt><strong><code>compress</code></strong> :&ensp;<code>bool</code></dt>
<dd>enabled zlib compression of the file - False by default</dd>
<dt><strong><code>checksum</code></strong> :&ensp;<code>bool</code></dt>
<dd>insert a MD5 checksum of the file content - False by default</dd>
</dl>
<p>Returns: a PDFEmbeddedFile instance, with a .basename string attribute representing the internal file name</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.file_attachment_annotation"><code class="name flex">
<span>def <span class="ident">file_attachment_annotation</span></span>(<span>self,<br>file_path,<br>x,<br>y,<br>w=1,<br>h=1,<br>name=None,<br>flags=(&lt;AnnotationFlag.PRINT: 4&gt;,),<br>**kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L2494-L2530" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@check_page
def file_attachment_annotation(
    self, file_path, x, y, w=1, h=1, name=None, flags=DEFAULT_ANNOT_FLAGS, **kwargs
):
    &#34;&#34;&#34;
    Puts a file attachment annotation on a rectangular area of the page.

    Args:
        file_path (str or Path): filesystem path to the existing file to embed
        x (float): horizontal position (from the left) to the left side of the link rectangle
        y (float): vertical position (from the top) to the bottom side of the link rectangle
        w (float): optional width of the link rectangle
        h (float): optional height of the link rectangle
        name (fpdf.enums.FileAttachmentAnnotationName, str): optional icon that shall be used in displaying the annotation
        flags (Tuple[fpdf.enums.AnnotationFlag], Tuple[str]): optional list of flags defining annotation properties
        bytes (bytes): optional, as an alternative to file_path, bytes content of the file to embed
        basename (str): optional, required if bytes is provided, file base name
        creation_date (datetime): date and time when the file was created
        modification_date (datetime): date and time when the file was last modified
        desc (str): optional description of the file
        compress (bool): enabled zlib compression of the file - False by default
        checksum (bool): insert a MD5 checksum of the file content - False by default
    &#34;&#34;&#34;
    embedded_file = self.embed_file(file_path, **kwargs)
    embedded_file.set_globally_enclosed(False)
    annotation = AnnotationDict(
        &#34;FileAttachment&#34;,
        x * self.k,
        self.h_pt - y * self.k,
        w * self.k,
        h * self.k,
        file_spec=embedded_file.file_spec(),
        name=FileAttachmentAnnotationName.coerce(name) if name else None,
        flags=flags,
    )
    self.pages[self.page].annots.append(annotation)
    return annotation</code></pre>
</details>
<div class="desc"><p>Puts a file attachment annotation on a rectangular area of the page.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code> or <code>Path</code></dt>
<dd>filesystem path to the existing file to embed</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>horizontal position (from the left) to the left side of the link rectangle</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>vertical position (from the top) to the bottom side of the link rectangle</dd>
<dt><strong><code>w</code></strong> :&ensp;<code>float</code></dt>
<dd>optional width of the link rectangle</dd>
<dt><strong><code>h</code></strong> :&ensp;<code>float</code></dt>
<dd>optional height of the link rectangle</dd>
<dt><strong><code>name</code></strong> :&ensp;<code><a title="fpdf.enums.FileAttachmentAnnotationName" href="enums.html#fpdf.enums.FileAttachmentAnnotationName">FileAttachmentAnnotationName</a>, str</code></dt>
<dd>optional icon that shall be used in displaying the annotation</dd>
<dt><strong><code>flags</code></strong> :&ensp;<code>Tuple[<a title="fpdf.enums.AnnotationFlag" href="enums.html#fpdf.enums.AnnotationFlag">AnnotationFlag</a>], Tuple[str]</code></dt>
<dd>optional list of flags defining annotation properties</dd>
<dt><strong><code>bytes</code></strong> :&ensp;<code>bytes</code></dt>
<dd>optional, as an alternative to file_path, bytes content of the file to embed</dd>
<dt><strong><code>basename</code></strong> :&ensp;<code>str</code></dt>
<dd>optional, required if bytes is provided, file base name</dd>
<dt><strong><code>creation_date</code></strong> :&ensp;<code>datetime</code></dt>
<dd>date and time when the file was created</dd>
<dt><strong><code>modification_date</code></strong> :&ensp;<code>datetime</code></dt>
<dd>date and time when the file was last modified</dd>
<dt><strong><code>desc</code></strong> :&ensp;<code>str</code></dt>
<dd>optional description of the file</dd>
<dt><strong><code>compress</code></strong> :&ensp;<code>bool</code></dt>
<dd>enabled zlib compression of the file - False by default</dd>
<dt><strong><code>checksum</code></strong> :&ensp;<code>bool</code></dt>
<dd>insert a MD5 checksum of the file content - False by default</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.file_id"><code class="name flex">
<span>def <span class="ident">file_id</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L5060-L5068" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def file_id(self):  # pylint: disable=no-self-use
    &#34;&#34;&#34;
    This method can be overridden in inherited classes
    in order to define a custom file identifier.
    Its output must have the format &#34;&lt;hex_string1&gt;&lt;hex_string2&gt;&#34;.
    If this method returns a falsy value (None, empty string),
    no /ID will be inserted in the generated PDF document.
    &#34;&#34;&#34;
    return -1</code></pre>
</details>
<div class="desc"><p>This method can be overridden in inherited classes
in order to define a custom file identifier.
Its output must have the format "<hex_string1><hex_string2>".
If this method returns a falsy value (None, empty string),
no /ID will be inserted in the generated PDF document.</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.font_face"><code class="name flex">
<span>def <span class="ident">font_face</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.graphics_state.GraphicsStateMixin" href="graphics_state.html#fpdf.graphics_state.GraphicsStateMixin">GraphicsStateMixin</a></code>.<code><a title="fpdf.graphics_state.GraphicsStateMixin.font_face" href="graphics_state.html#fpdf.graphics_state.GraphicsStateMixin.font_face">font_face</a></code>
</p>
<div class="desc inherited"><p>Return a <code><a title="fpdf.fonts.FontFace" href="fonts.html#fpdf.fonts.FontFace">FontFace</a></code> instance
representing a subset of properties of this GraphicsState.</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.footer"><code class="name flex">
<span>def <span class="ident">footer</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L1176-L1184" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def footer(self):
    &#34;&#34;&#34;
    Footer to be implemented in your own inherited class.

    This is automatically called by `FPDF.add_page()` and `FPDF.output()`
    and should not be called directly by the user application.
    The default implementation performs nothing: you have to override this method
    in a subclass to implement your own rendering logic.
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Footer to be implemented in your own inherited class.</p>
<p>This is automatically called by <code><a title="fpdf.fpdf.FPDF.add_page" href="#fpdf.fpdf.FPDF.add_page">FPDF.add_page()</a></code> and <code><a title="fpdf.fpdf.FPDF.output" href="#fpdf.fpdf.FPDF.output">FPDF.output()</a></code>
and should not be called directly by the user application.
The default implementation performs nothing: you have to override this method
in a subclass to implement your own rendering logic.</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.free_text_annotation"><code class="name flex">
<span>def <span class="ident">free_text_annotation</span></span>(<span>self, text, x=None, y=None, w=None, h=None, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L2561-L2611" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@check_page
def free_text_annotation(
    self,
    text,
    x=None,
    y=None,
    w=None,
    h=None,
    **kwargs,
):
    &#34;&#34;&#34;
    Puts a free text annotation on a rectangular area of the page.

    Args:
        text (str): text to display
        x (float): optional horizontal position (from the left) to the left side of the link rectangle.
            Default value: None, meaning the current abscissa is used
        y (float): vertical position (from the top) to the bottom side of the link rectangle.
            Default value: None, meaning the current ordinate is used
        w (float): optional width of the link rectangle. Default value: None, meaning the length of text in user unit
        h (float): optional height of the link rectangle. Default value: None, meaning an height equal
            to the current font size
        flags (Tuple[fpdf.enums.AnnotationFlag], Tuple[str]): optional list of flags defining annotation properties
        color (tuple): a tuple of numbers in the range 0.0 to 1.0, representing a colour used for the annotation background
        border_width (float): width of the annotation border
    &#34;&#34;&#34;
    if not self.font_family:
        raise FPDFException(&#34;No font set, you need to call set_font() beforehand&#34;)
    if not self.current_font_is_set_on_page:
        self._out(self._set_font_for_page(self.current_font, self.font_size_pt))
    if x is None:
        x = self.x
    if y is None:
        y = self.y
    if h is None:
        h = self.font_size
    if w is None:
        w = self.get_string_width(text, normalized=True, markdown=False)

    annotation = AnnotationDict(
        &#34;FreeText&#34;,
        x * self.k,
        self.h_pt - y * self.k,
        w * self.k,
        h * self.k,
        contents=text,
        default_appearance=f&#34;({self.draw_color.serialize()} /F{self.current_font.i} {self.font_size_pt:.2f} Tf)&#34;,
        **kwargs,
    )
    self.pages[self.page].annots.append(annotation)
    return annotation</code></pre>
</details>
<div class="desc"><p>Puts a free text annotation on a rectangular area of the page.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>text to display</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>optional horizontal position (from the left) to the left side of the link rectangle.
Default value: None, meaning the current abscissa is used</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>vertical position (from the top) to the bottom side of the link rectangle.
Default value: None, meaning the current ordinate is used</dd>
<dt><strong><code>w</code></strong> :&ensp;<code>float</code></dt>
<dd>optional width of the link rectangle. Default value: None, meaning the length of text in user unit</dd>
<dt><strong><code>h</code></strong> :&ensp;<code>float</code></dt>
<dd>optional height of the link rectangle. Default value: None, meaning an height equal
to the current font size</dd>
<dt><strong><code>flags</code></strong> :&ensp;<code>Tuple[<a title="fpdf.enums.AnnotationFlag" href="enums.html#fpdf.enums.AnnotationFlag">AnnotationFlag</a>], Tuple[str]</code></dt>
<dd>optional list of flags defining annotation properties</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>tuple</code></dt>
<dd>a tuple of numbers in the range 0.0 to 1.0, representing a colour used for the annotation background</dd>
<dt><strong><code>border_width</code></strong> :&ensp;<code>float</code></dt>
<dd>width of the annotation border</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.get_fallback_font"><code class="name flex">
<span>def <span class="ident">get_fallback_font</span></span>(<span>self, char, style='')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L3689-L3711" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def get_fallback_font(self, char, style=&#34;&#34;):
    &#34;&#34;&#34;
    Returns which fallback font has the requested glyph.
    This method can be overridden to provide more control than the `select_mode` parameter
    of `FPDF.set_fallback_fonts()` provides.
    &#34;&#34;&#34;
    emphasis = TextEmphasis.coerce(style)
    fonts_with_char = [
        font_id
        for font_id in self._fallback_font_ids
        if ord(char) in self.fonts[font_id].cmap
    ]
    if not fonts_with_char:
        return None
    font_with_matching_emphasis = next(
        (font for font in fonts_with_char if self.fonts[font].emphasis == emphasis),
        None,
    )
    if font_with_matching_emphasis:
        return font_with_matching_emphasis
    if self._fallback_font_exact_match:
        return None
    return fonts_with_char[0]</code></pre>
</details>
<div class="desc"><p>Returns which fallback font has the requested glyph.
This method can be overridden to provide more control than the <code>select_mode</code> parameter
of <code><a title="fpdf.fpdf.FPDF.set_fallback_fonts" href="#fpdf.fpdf.FPDF.set_fallback_fonts">FPDF.set_fallback_fonts()</a></code> provides.</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.get_page_label"><code class="name flex">
<span>def <span class="ident">get_page_label</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L1190-L1196" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def get_page_label(self):
    &#34;&#34;&#34;
    Return the current page `fpdf.output.PDFPageLabel`.
    This will be displayed by some PDF readers to identify pages.
    `FPDF.set_page_label()` needs to be called first for those to be inserted.
    &#34;&#34;&#34;
    return self.pages[self.page].get_label()</code></pre>
</details>
<div class="desc"><p>Return the current page <code><a title="fpdf.output.PDFPageLabel" href="output.html#fpdf.output.PDFPageLabel">PDFPageLabel</a></code>.
This will be displayed by some PDF readers to identify pages.
<code><a title="fpdf.fpdf.FPDF.set_page_label" href="#fpdf.fpdf.FPDF.set_page_label">FPDF.set_page_label()</a></code> needs to be called first for those to be inserted.</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.get_string_width"><code class="name flex">
<span>def <span class="ident">get_string_width</span></span>(<span>self, s, normalized=False, markdown=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L1251-L1269" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def get_string_width(self, s, normalized=False, markdown=False):
    &#34;&#34;&#34;
    Returns the length of a string in user unit. A font must be selected.
    The value is calculated with stretching and spacing.

    Note that the width of a cell has some extra padding added to this width,
    on the left &amp; right sides, equal to the .c_margin property.

    Args:
        s (str): the string whose length is to be computed.
        normalized (bool): whether normalization needs to be performed on the input string.
        markdown (bool): indicates if basic markdown support is enabled
    &#34;&#34;&#34;
    # normalized is parameter for internal use
    s = s if normalized else self.normalize_text(s)
    w = 0
    for frag in self._preload_bidirectional_text(s, markdown):
        w += frag.get_width()
    return w</code></pre>
</details>
<div class="desc"><p>Returns the length of a string in user unit. A font must be selected.
The value is calculated with stretching and spacing.</p>
<p>Note that the width of a cell has some extra padding added to this width,
on the left &amp; right sides, equal to the .c_margin property.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>str</code></dt>
<dd>the string whose length is to be computed.</dd>
<dt><strong><code>normalized</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether normalization needs to be performed on the input string.</dd>
<dt><strong><code>markdown</code></strong> :&ensp;<code>bool</code></dt>
<dd>indicates if basic markdown support is enabled</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.get_x"><code class="name flex">
<span>def <span class="ident">get_x</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L4841-L4843" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def get_x(self):
    &#34;&#34;&#34;Returns the abscissa of the current position.&#34;&#34;&#34;
    return self.x</code></pre>
</details>
<div class="desc"><p>Returns the abscissa of the current position.</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.get_y"><code class="name flex">
<span>def <span class="ident">get_y</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L4855-L4861" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def get_y(self):
    &#34;&#34;&#34;Returns the ordinate of the current position.&#34;&#34;&#34;
    if self._in_unbreakable:
        raise FPDFException(
            &#34;Using get_y() inside an unbreakable() code block is error-prone&#34;
        )
    return self.y</code></pre>
</details>
<div class="desc"><p>Returns the ordinate of the current position.</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.header"><code class="name flex">
<span>def <span class="ident">header</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L1163-L1174" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def header(self):
    &#34;&#34;&#34;
    Header to be implemented in your own inherited class

    This is automatically called by `FPDF.add_page()`
    and should not be called directly by the user application.
    The default implementation performs nothing: you have to override this method
    in a subclass to implement your own rendering logic.

    Note that header rendering can have an impact on the initial
    (x,y) position when starting to render the page content.
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Header to be implemented in your own inherited class</p>
<p>This is automatically called by <code><a title="fpdf.fpdf.FPDF.add_page" href="#fpdf.fpdf.FPDF.add_page">FPDF.add_page()</a></code>
and should not be called directly by the user application.
The default implementation performs nothing: you have to override this method
in a subclass to implement your own rendering logic.</p>
<p>Note that header rendering can have an impact on the initial
(x,y) position when starting to render the page content.</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.highlight"><code class="name flex">
<span>def <span class="ident">highlight</span></span>(<span>self, text, type='Highlight', color=(1, 1, 0), modification_time=None, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L2637-L2669" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@contextmanager
def highlight(
    self, text, type=&#34;Highlight&#34;, color=(1, 1, 0), modification_time=None, **kwargs
):
    &#34;&#34;&#34;
    Context manager that adds a single highlight annotation based on the text lines inserted
    inside its indented block.

    Args:
        text (str): text of the annotation
        title (str): the text label that shall be displayed in the title bar of the annotation’s
            pop-up window when open and active. This entry shall identify the user who added the annotation.
        type (fpdf.enums.TextMarkupType, str): &#34;Highlight&#34;, &#34;Underline&#34;, &#34;Squiggly&#34; or &#34;StrikeOut&#34;.
        color (tuple): a tuple of numbers in the range 0.0 to 1.0, representing a colour used for
            the title bar of the annotation’s pop-up window. Defaults to yellow.
        modification_time (datetime): date and time when the annotation was most recently modified
    &#34;&#34;&#34;
    if self._record_text_quad_points:
        raise FPDFException(&#34;highlight() cannot be nested&#34;)
    self._record_text_quad_points = True
    yield
    for page, quad_points in self._text_quad_points.items():
        self.add_text_markup_annotation(
            type,
            text,
            quad_points=quad_points,
            modification_time=modification_time,
            page=page,
            color=color,
            **kwargs,
        )
    self._text_quad_points = defaultdict(list)
    self._record_text_quad_points = False</code></pre>
</details>
<div class="desc"><p>Context manager that adds a single highlight annotation based on the text lines inserted
inside its indented block.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>text of the annotation</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code></dt>
<dd>the text label that shall be displayed in the title bar of the annotation’s
pop-up window when open and active. This entry shall identify the user who added the annotation.</dd>
<dt><strong><code>type</code></strong> :&ensp;<code><a title="fpdf.enums.TextMarkupType" href="enums.html#fpdf.enums.TextMarkupType">TextMarkupType</a>, str</code></dt>
<dd>"Highlight", "Underline", "Squiggly" or "StrikeOut".</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>tuple</code></dt>
<dd>a tuple of numbers in the range 0.0 to 1.0, representing a colour used for
the title bar of the annotation’s pop-up window. Defaults to yellow.</dd>
<dt><strong><code>modification_time</code></strong> :&ensp;<code>datetime</code></dt>
<dd>date and time when the annotation was most recently modified</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.image"><code class="name flex">
<span>def <span class="ident">image</span></span>(<span>self,<br>name,<br>x=None,<br>y=None,<br>w=0,<br>h=0,<br>type='',<br>link='',<br>title=None,<br>alt_text=None,<br>dims=None,<br>keep_aspect_ratio=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L4447-L4540" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@check_page
def image(
    self,
    name,
    x=None,
    y=None,
    w=0,
    h=0,
    type=&#34;&#34;,
    link=&#34;&#34;,
    title=None,
    alt_text=None,
    dims=None,
    keep_aspect_ratio=False,
):
    &#34;&#34;&#34;
    Put an image on the page.

    The size of the image on the page can be specified in different ways:
    * explicit width and height (expressed in user units)
    * one explicit dimension, the other being calculated automatically
      in order to keep the original proportions
    * no explicit dimension, in which case the image is put at 72 dpi.
    * explicit width and height (expressed in user units) and `keep_aspect_ratio=True`

    **Remarks**:
    * if an image is used several times, only one copy is embedded in the file.
    * when using an animated GIF, only the first frame is used.

    Args:
        name: either a string representing a file path to an image, an URL to an image,
            bytes, an io.BytesIO, or a instance of `PIL.Image.Image`
        x (float, fpdf.enums.Align): optional horizontal position where to put the image on the page.
            If not specified or equal to None, the current abscissa is used.
            `fpdf.enums.Align.C` can also be passed to center the image horizontally;
            and `fpdf.enums.Align.R` to place it along the right page margin
        y (float): optional vertical position where to put the image on the page.
            If not specified or equal to None, the current ordinate is used.
            After the call, the current ordinate is moved to the bottom of the image
        w (float): optional width of the image. If not specified or equal to zero,
            it is automatically calculated from the image size.
            Pass `pdf.epw` to scale horizontally to the full page width.
        h (float): optional height of the image. If not specified or equal to zero,
            it is automatically calculated from the image size.
            Pass `pdf.eph` to scale horizontally to the full page height.
        type (str): [**DEPRECATED since 2.2.0**] unused, will be removed in a later version.
        link (str): optional link to add on the image, internal
            (identifier returned by `FPDF.add_link`) or external URL.
        title (str): optional. Currently, never seem rendered by PDF readers.
        alt_text (str): optional alternative text describing the image,
            for accessibility purposes. Displayed by some PDF readers on hover.
        dims (Tuple[float]): optional dimensions as a tuple (width, height) to resize the image
            before storing it in the PDF. Note that those are the **intrinsic** image dimensions,
            but the image will still be rendered on the page with the width (`w`) and height (`h`)
            provided as parameters. Note also that the `.oversized_images` attribute of FPDF
            provides an automated way to auto-adjust those intrinsic image dimensions.
        keep_aspect_ratio (bool): ensure the image fits in the rectangle defined by `x`, `y`, `w` &amp; `h`
            while preserving its original aspect ratio. Defaults to False.
            Only meaningful if both `w` &amp; `h` are provided.

    If `y` is provided, this method will not trigger any page break;
    otherwise, auto page break detection will be performed.

    Returns: an instance of a subclass of `ImageInfo`.
    &#34;&#34;&#34;
    if type:
        warnings.warn(
            (
                &#39;&#34;type&#34; parameter is deprecated since v2.2.0, &#39;
                &#34;unused and will soon be removed&#34;
            ),
            DeprecationWarning,
            stacklevel=get_stack_level(),
        )

    name, img, info = preload_image(self.image_cache, name, dims)
    if isinstance(info, VectorImageInfo):
        return self._vector_image(
            name, img, info, x, y, w, h, link, title, alt_text, keep_aspect_ratio
        )
    return self._raster_image(
        name,
        img,
        info,
        x,
        y,
        w,
        h,
        link,
        title,
        alt_text,
        dims,
        keep_aspect_ratio,
    )</code></pre>
</details>
<div class="desc"><p>Put an image on the page.</p>
<p>The size of the image on the page can be specified in different ways:
* explicit width and height (expressed in user units)
* one explicit dimension, the other being calculated automatically
in order to keep the original proportions
* no explicit dimension, in which case the image is put at 72 dpi.
* explicit width and height (expressed in user units) and <code>keep_aspect_ratio=True</code></p>
<p><strong>Remarks</strong>:
* if an image is used several times, only one copy is embedded in the file.
* when using an animated GIF, only the first frame is used.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>either a string representing a file path to an image, an URL to an image,
bytes, an io.BytesIO, or a instance of <code>PIL.Image.Image</code></dd>
<dt><strong><code>x</code></strong> :&ensp;<code>float, <a title="fpdf.enums.Align" href="enums.html#fpdf.enums.Align">Align</a></code></dt>
<dd>optional horizontal position where to put the image on the page.
If not specified or equal to None, the current abscissa is used.
<code><a title="fpdf.enums.Align.C" href="enums.html#fpdf.enums.Align.C">Align.C</a></code> can also be passed to center the image horizontally;
and <code><a title="fpdf.enums.Align.R" href="enums.html#fpdf.enums.Align.R">Align.R</a></code> to place it along the right page margin</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>optional vertical position where to put the image on the page.
If not specified or equal to None, the current ordinate is used.
After the call, the current ordinate is moved to the bottom of the image</dd>
<dt><strong><code>w</code></strong> :&ensp;<code>float</code></dt>
<dd>optional width of the image. If not specified or equal to zero,
it is automatically calculated from the image size.
Pass <code>pdf.epw</code> to scale horizontally to the full page width.</dd>
<dt><strong><code>h</code></strong> :&ensp;<code>float</code></dt>
<dd>optional height of the image. If not specified or equal to zero,
it is automatically calculated from the image size.
Pass <code>pdf.eph</code> to scale horizontally to the full page height.</dd>
<dt><strong><code>type</code></strong> :&ensp;<code>str</code></dt>
<dd>[<strong>DEPRECATED since 2.2.0</strong>] unused, will be removed in a later version.</dd>
<dt><strong><code>link</code></strong> :&ensp;<code>str</code></dt>
<dd>optional link to add on the image, internal
(identifier returned by <code><a title="fpdf.fpdf.FPDF.add_link" href="#fpdf.fpdf.FPDF.add_link">FPDF.add_link()</a></code>) or external URL.</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code></dt>
<dd>optional. Currently, never seem rendered by PDF readers.</dd>
<dt><strong><code>alt_text</code></strong> :&ensp;<code>str</code></dt>
<dd>optional alternative text describing the image,
for accessibility purposes. Displayed by some PDF readers on hover.</dd>
<dt><strong><code>dims</code></strong> :&ensp;<code>Tuple[float]</code></dt>
<dd>optional dimensions as a tuple (width, height) to resize the image
before storing it in the PDF. Note that those are the <strong>intrinsic</strong> image dimensions,
but the image will still be rendered on the page with the width (<code>w</code>) and height (<code>h</code>)
provided as parameters. Note also that the <code>.oversized_images</code> attribute of FPDF
provides an automated way to auto-adjust those intrinsic image dimensions.</dd>
<dt><strong><code>keep_aspect_ratio</code></strong> :&ensp;<code>bool</code></dt>
<dd>ensure the image fits in the rectangle defined by <code>x</code>, <code>y</code>, <code>w</code> &amp; <code>h</code>
while preserving its original aspect ratio. Defaults to False.
Only meaningful if both <code>w</code> &amp; <code>h</code> are provided.</dd>
</dl>
<p>If <code>y</code> is provided, this method will not trigger any page break;
otherwise, auto page break detection will be performed.</p>
<p>Returns: an instance of a subclass of <code><a title="fpdf.fpdf.ImageInfo" href="#fpdf.fpdf.ImageInfo">ImageInfo</a></code>.</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.ink_annotation"><code class="name flex">
<span>def <span class="ident">ink_annotation</span></span>(<span>self, coords, text='', color=(1, 1, 0), border_width=1, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L2734-L2768" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@check_page
def ink_annotation(
    self, coords, text=&#34;&#34;, color=(1, 1, 0), border_width=1, **kwargs
):
    &#34;&#34;&#34;
    Adds add an ink annotation on the page.

    Args:
        coords (tuple): an iterable of coordinates (pairs of numbers) defining a path
        text (str): textual description
        title (str): the text label that shall be displayed in the title bar of the annotation’s
            pop-up window when open and active. This entry shall identify the user who added the annotation.
        color (tuple): a tuple of numbers in the range 0.0 to 1.0, representing a colour used for
            the title bar of the annotation’s pop-up window. Defaults to yellow.
        border_width (float): thickness of the path stroke.
    &#34;&#34;&#34;
    ink_list = sum(((x * self.k, (self.h - y) * self.k) for (x, y) in coords), ())
    x_min = min(ink_list[0::2])
    y_min = min(ink_list[1::2])
    x_max = max(ink_list[0::2])
    y_max = max(ink_list[1::2])
    annotation = AnnotationDict(
        &#34;Ink&#34;,
        x=y_min,
        y=y_max,
        width=x_max - x_min,
        height=y_max - y_min,
        ink_list=ink_list,
        contents=text,
        border_width=border_width,
        color=color,
        **kwargs,
    )
    self.pages[self.page].annots.append(annotation)
    return annotation</code></pre>
</details>
<div class="desc"><p>Adds add an ink annotation on the page.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>coords</code></strong> :&ensp;<code>tuple</code></dt>
<dd>an iterable of coordinates (pairs of numbers) defining a path</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>textual description</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code></dt>
<dd>the text label that shall be displayed in the title bar of the annotation’s
pop-up window when open and active. This entry shall identify the user who added the annotation.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>tuple</code></dt>
<dd>a tuple of numbers in the range 0.0 to 1.0, representing a colour used for
the title bar of the annotation’s pop-up window. Defaults to yellow.</dd>
<dt><strong><code>border_width</code></strong> :&ensp;<code>float</code></dt>
<dd>thickness of the path stroke.</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.insert_toc_placeholder"><code class="name flex">
<span>def <span class="ident">insert_toc_placeholder</span></span>(<span>self,<br>render_toc_function: Callable,<br>pages: int = 1,<br>allow_extra_pages: bool = False,<br>reset_page_indices: bool = True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L5355-L5404" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@check_page
def insert_toc_placeholder(
    self,
    render_toc_function: Callable,
    pages: int = 1,
    allow_extra_pages: bool = False,
    reset_page_indices: bool = True,
):
    &#34;&#34;&#34;
    Configure Table Of Contents rendering at the end of the document generation,
    and reserve some vertical space right now in order to insert it.
    At least one page break is triggered by this method.

    Args:
        render_toc_function (function): a function that will be invoked to render the ToC.
            This function will receive 2 parameters: `pdf`, an instance of FPDF, and `outline`,
            a list of `fpdf.outline.OutlineSection`.
        pages (int): the number of pages that the Table of Contents will span,
            including the current one that will. As many page breaks as the value of this argument
            will occur immediately after calling this method.
        allow_extra_pages (bool): If set to `True`, allows for an unlimited number of
            extra pages in the ToC, which may cause discrepancies with pre-rendered
            page numbers. For consistent numbering, using page labels to create a
            separate numbering style for the ToC is recommended.
        reset_page_indices (bool): Whether to reset the pages indices after the ToC. Default to True.
    &#34;&#34;&#34;
    if pages &lt; 1:
        raise ValueError(
            f&#34;&#39;pages&#39; parameter must be equal or greater than 1: {pages}&#34;
        )
    if not callable(render_toc_function):
        raise TypeError(
            f&#34;The first argument must be a callable, got: {type(render_toc_function)}&#34;
        )
    if self.toc_placeholder:
        raise FPDFException(
            &#34;A placeholder for the table of contents has already been defined&#34;
            f&#34; on page {self.toc_placeholder.start_page}&#34;
        )
    self.toc_placeholder = ToCPlaceholder(
        render_toc_function,
        self.page,
        self.y,
        self.cur_orientation,
        pages,
        reset_page_indices,
    )
    self._toc_allow_page_insertion = allow_extra_pages
    for _ in range(pages):
        self._perform_page_break()</code></pre>
</details>
<div class="desc"><p>Configure Table Of Contents rendering at the end of the document generation,
and reserve some vertical space right now in order to insert it.
At least one page break is triggered by this method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>render_toc_function</code></strong> :&ensp;<code>function</code></dt>
<dd>a function that will be invoked to render the ToC.
This function will receive 2 parameters: <code>pdf</code>, an instance of FPDF, and <code>outline</code>,
a list of <code><a title="fpdf.outline.OutlineSection" href="outline.html#fpdf.outline.OutlineSection">OutlineSection</a></code>.</dd>
<dt><strong><code>pages</code></strong> :&ensp;<code>int</code></dt>
<dd>the number of pages that the Table of Contents will span,
including the current one that will. As many page breaks as the value of this argument
will occur immediately after calling this method.</dd>
<dt><strong><code>allow_extra_pages</code></strong> :&ensp;<code>bool</code></dt>
<dd>If set to <code>True</code>, allows for an unlimited number of
extra pages in the ToC, which may cause discrepancies with pre-rendered
page numbers. For consistent numbering, using page labels to create a
separate numbering style for the ToC is recommended.</dd>
<dt><strong><code>reset_page_indices</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to reset the pages indices after the ToC. Default to True.</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.interleaved2of5"><code class="name flex">
<span>def <span class="ident">interleaved2of5</span></span>(<span>self, text, x, y, w=1, h=10)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L5127-L5182" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@check_page
@support_deprecated_txt_arg
def interleaved2of5(self, text, x, y, w=1, h=10):
    &#34;&#34;&#34;Barcode I2of5 (numeric), adds a 0 if odd length&#34;&#34;&#34;
    narrow = w / 3
    wide = w

    # wide/narrow codes for the digits
    bar_char = {
        &#34;0&#34;: &#34;nnwwn&#34;,
        &#34;1&#34;: &#34;wnnnw&#34;,
        &#34;2&#34;: &#34;nwnnw&#34;,
        &#34;3&#34;: &#34;wwnnn&#34;,
        &#34;4&#34;: &#34;nnwnw&#34;,
        &#34;5&#34;: &#34;wnwnn&#34;,
        &#34;6&#34;: &#34;nwwnn&#34;,
        &#34;7&#34;: &#34;nnnww&#34;,
        &#34;8&#34;: &#34;wnnwn&#34;,
        &#34;9&#34;: &#34;nwnwn&#34;,
        &#34;A&#34;: &#34;nn&#34;,
        &#34;Z&#34;: &#34;wn&#34;,
    }
    # The caller should do this, or we can&#39;t rotate the thing.
    # self.set_fill_color(0)
    code = text
    # add leading zero if code-length is odd
    if len(code) % 2 != 0:
        code = f&#34;0{code}&#34;

    # add start and stop codes
    code = f&#34;AA{code.lower()}ZA&#34;

    for i in range(0, len(code), 2):
        # choose next pair of digits
        char_bar = code[i]
        char_space = code[i + 1]
        # check whether it is a valid digit
        if char_bar not in bar_char:
            raise RuntimeError(f&#39;Char &#34;{char_bar}&#34; invalid for I25:&#39;)
        if char_space not in bar_char:
            raise RuntimeError(f&#39;Char &#34;{char_space}&#34; invalid for I25: &#39;)

        # create a wide/narrow-seq (first digit=bars, second digit=spaces)
        seq = &#34;&#34;.join(
            f&#34;{cb}{cs}&#34; for cb, cs in zip(bar_char[char_bar], bar_char[char_space])
        )

        for bar_index, char in enumerate(seq):
            # set line_width depending on value
            line_width = narrow if char == &#34;n&#34; else wide

            # draw every second value, the other is represented by space
            if bar_index % 2 == 0:
                self.rect(x, y, line_width, h, &#34;F&#34;)

            x += line_width</code></pre>
</details>
<div class="desc"><p>Barcode I2of5 (numeric), adds a 0 if odd length</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.line"><code class="name flex">
<span>def <span class="ident">line</span></span>(<span>self, x1, y1, x2, y2)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L1479-L1493" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@check_page
def line(self, x1, y1, x2, y2):
    &#34;&#34;&#34;
    Draw a line between two points.

    Args:
        x1 (float): Abscissa of first point
        y1 (float): Ordinate of first point
        x2 (float): Abscissa of second point
        y2 (float): Ordinate of second point
    &#34;&#34;&#34;
    self._out(
        f&#34;{x1 * self.k:.2f} {(self.h - y1) * self.k:.2f} m {x2 * self.k:.2f} &#34;
        f&#34;{(self.h - y2) * self.k:.2f} l S&#34;
    )</code></pre>
</details>
<div class="desc"><p>Draw a line between two points.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x1</code></strong> :&ensp;<code>float</code></dt>
<dd>Abscissa of first point</dd>
<dt><strong><code>y1</code></strong> :&ensp;<code>float</code></dt>
<dd>Ordinate of first point</dd>
<dt><strong><code>x2</code></strong> :&ensp;<code>float</code></dt>
<dd>Abscissa of second point</dd>
<dt><strong><code>y2</code></strong> :&ensp;<code>float</code></dt>
<dd>Ordinate of second point</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.link"><code class="name flex">
<span>def <span class="ident">link</span></span>(<span>self, x, y, w, h, link, alt_text=None, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L2388-L2435" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@check_page
def link(self, x, y, w, h, link, alt_text=None, **kwargs):
    &#34;&#34;&#34;
    Puts a link annotation on a rectangular area of the page.
    Text or image links are generally put via `FPDF.cell`,
    `FPDF.write` or `FPDF.image`,
    but this method can be useful for instance to define a clickable area inside an image.

    Args:
        x (float): horizontal position (from the left) to the left side of the link rectangle
        y (float): vertical position (from the top) to the bottom side of the link rectangle
        w (float): width of the link rectangle
        h (float): height of the link rectangle
        link: either an URL or an integer returned by `FPDF.add_link`, defining an internal link to a page
        alt_text (str): optional textual description of the link, for accessibility purposes
        border_width (int): thickness of an optional black border surrounding the link.
            Not all PDF readers honor this: Acrobat renders it but not Sumatra.
    &#34;&#34;&#34;
    action, dest = None, None
    if link:
        if isinstance(link, str):
            action = URIAction(link)
        else:  # Dest type ending of annotation entry
            assert (
                link in self.links
            ), f&#34;Link with an invalid index: {link} (doc #links={len(self.links)})&#34;
            dest = self.links[link]
            if not dest.page_number:
                raise ValueError(
                    f&#34;Cannot insert link {link} with no page number assigned&#34;
                )
    link_annot = AnnotationDict(
        &#34;Link&#34;,
        x=x * self.k,
        y=self.h_pt - y * self.k,
        width=w * self.k,
        height=h * self.k,
        action=action,
        dest=dest,
        **kwargs,
    )
    self.pages[self.page].annots.append(link_annot)
    if alt_text is not None:
        # Note: the spec indicates that a /StructParent could be added **inside* this /Annot,
        # but tests with Adobe Acrobat Reader reveal that the page /StructParents inserted below
        # is enough to link the marked content in the hierarchy tree with this annotation link.
        self._add_marked_content(struct_type=&#34;/Link&#34;, alt_text=alt_text)
    return link_annot</code></pre>
</details>
<div class="desc"><p>Puts a link annotation on a rectangular area of the page.
Text or image links are generally put via <code><a title="fpdf.fpdf.FPDF.cell" href="#fpdf.fpdf.FPDF.cell">FPDF.cell()</a></code>,
<code><a title="fpdf.fpdf.FPDF.write" href="#fpdf.fpdf.FPDF.write">FPDF.write()</a></code> or <code><a title="fpdf.fpdf.FPDF.image" href="#fpdf.fpdf.FPDF.image">FPDF.image()</a></code>,
but this method can be useful for instance to define a clickable area inside an image.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>horizontal position (from the left) to the left side of the link rectangle</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>vertical position (from the top) to the bottom side of the link rectangle</dd>
<dt><strong><code>w</code></strong> :&ensp;<code>float</code></dt>
<dd>width of the link rectangle</dd>
<dt><strong><code>h</code></strong> :&ensp;<code>float</code></dt>
<dd>height of the link rectangle</dd>
<dt><strong><code>link</code></strong></dt>
<dd>either an URL or an integer returned by <code><a title="fpdf.fpdf.FPDF.add_link" href="#fpdf.fpdf.FPDF.add_link">FPDF.add_link()</a></code>, defining an internal link to a page</dd>
<dt><strong><code>alt_text</code></strong> :&ensp;<code>str</code></dt>
<dd>optional textual description of the link, for accessibility purposes</dd>
<dt><strong><code>border_width</code></strong> :&ensp;<code>int</code></dt>
<dd>thickness of an optional black border surrounding the link.
Not all PDF readers honor this: Acrobat renders it but not Sumatra.</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.ln"><code class="name flex">
<span>def <span class="ident">ln</span></span>(<span>self, h=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L4820-L4839" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@check_page
def ln(self, h=None):
    &#34;&#34;&#34;
    Line Feed.
    The current abscissa goes back to the left margin and the ordinate increases by
    the amount passed as parameter.

    Args:
        h (float): The height of the break.
            By default, the value equals the height of the last printed text line
            (except when written by `.text()`). If no text has been written yet to
            the document, then the current font height is used.
    &#34;&#34;&#34;
    self.x = self.l_margin
    if h is not None:
        self.y += h
    elif self._lasth:
        self.y += self._lasth
    else:
        self.y += self.font_size</code></pre>
</details>
<div class="desc"><p>Line Feed.
The current abscissa goes back to the left margin and the ordinate increases by
the amount passed as parameter.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>h</code></strong> :&ensp;<code>float</code></dt>
<dd>The height of the break.
By default, the value equals the height of the last printed text line
(except when written by <code>.text()</code>). If no text has been written yet to
the document, then the current font height is used.</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.local_context"><code class="name flex">
<span>def <span class="ident">local_context</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L2963-L3024" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@check_page
@contextmanager
def local_context(self, **kwargs):
    &#34;&#34;&#34;
    Creates a local graphics state, which won&#39;t affect the surrounding code.
    This method must be used as a context manager using `with`:

        with pdf.local_context():
            set_some_state()
            draw_some_stuff()

    The affected settings are those controlled by GraphicsStateMixin and drawing.GraphicsStyle:

    * allow_transparency
    * auto_close
    * blend_mode
    * char_vpos
    * char_spacing
    * dash_pattern
    * denom_lift
    * denom_scale
    * draw_color
    * fill_color
    * fill_opacity
    * font_family
    * font_size
    * font_size_pt
    * font_style
    * font_stretching
    * intersection_rule
    * line_width
    * nom_lift
    * nom_scale
    * paint_rule
    * strikethrough
    * stroke_cap_style
    * stroke_join_style
    * stroke_miter_limit
    * stroke_opacity
    * sub_lift
    * sub_scale
    * sup_lift
    * sup_scale
    * text_color
    * text_mode
    * text_shaping
    * underline

    Font size can be specified in document units with `font_size` or in points with `font_size_pt`.

    Args:
        **kwargs: key-values settings to set at the beginning of this context.
    &#34;&#34;&#34;
    if self._in_unbreakable:
        raise FPDFException(
            &#34;cannot create a local context inside an unbreakable() code block&#34;
        )
    self._push_local_stack()
    self._start_local_context(**kwargs)
    yield
    self._end_local_context()
    self._pop_local_stack()</code></pre>
</details>
<div class="desc"><p>Creates a local graphics state, which won't affect the surrounding code.
This method must be used as a context manager using <code>with</code>:</p>
<pre><code>with pdf.local_context():
    set_some_state()
    draw_some_stuff()
</code></pre>
<p>The affected settings are those controlled by GraphicsStateMixin and drawing.GraphicsStyle:</p>
<ul>
<li>allow_transparency</li>
<li>auto_close</li>
<li>blend_mode</li>
<li>char_vpos</li>
<li>char_spacing</li>
<li>dash_pattern</li>
<li>denom_lift</li>
<li>denom_scale</li>
<li>draw_color</li>
<li>fill_color</li>
<li>fill_opacity</li>
<li>font_family</li>
<li>font_size</li>
<li>font_size_pt</li>
<li>font_style</li>
<li>font_stretching</li>
<li>intersection_rule</li>
<li>line_width</li>
<li>nom_lift</li>
<li>nom_scale</li>
<li>paint_rule</li>
<li>strikethrough</li>
<li>stroke_cap_style</li>
<li>stroke_join_style</li>
<li>stroke_miter_limit</li>
<li>stroke_opacity</li>
<li>sub_lift</li>
<li>sub_scale</li>
<li>sup_lift</li>
<li>sup_scale</li>
<li>text_color</li>
<li>text_mode</li>
<li>text_shaping</li>
<li>underline</li>
</ul>
<p>Font size can be specified in document units with <code>font_size</code> or in points with <code>font_size_pt</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>key-values settings to set at the beginning of this context.</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.mirror"><code class="name flex">
<span>def <span class="ident">mirror</span></span>(<span>self, origin, angle)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L2929-L2961" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@check_page
@contextmanager
def mirror(self, origin, angle):
    &#34;&#34;&#34;
    Method to perform a reflection transformation over a given mirror line.
    It must be used as a context-manager using `with`:

        with mirror(origin=(15,15), angle=&#34;SOUTH&#34;):
            pdf.something()

    The mirror transformation affects all elements which are rendered inside the indented
    context (with the exception of clickable areas).

    Args:
        origin (float, Sequence(float, float)): a point on the mirror line
        angle: (fpdf.enums.Angle): the direction of the mirror line
    &#34;&#34;&#34;
    x, y = origin
    try:
        theta = Angle.coerce(angle).value
    except ValueError:
        theta = angle

    a = math.cos(math.radians(theta * 2))
    b = math.sin(math.radians(theta * 2))
    cx, cy = x * self.k, (self.h - y) * self.k

    with self.local_context():
        self._out(
            f&#34;{a:.5f} {b:.5f} {b:.5f} {a*-1:.5f} {cx:.2f} {cy:.2f} cm &#34;
            f&#34;1 0 0 1 -{cx:.2f} -{cy:.2f} cm&#34;
        )
        yield</code></pre>
</details>
<div class="desc"><p>Method to perform a reflection transformation over a given mirror line.
It must be used as a context-manager using <code>with</code>:</p>
<pre><code>with mirror(origin=(15,15), angle="SOUTH"):
    pdf.something()
</code></pre>
<p>The mirror transformation affects all elements which are rendered inside the indented
context (with the exception of clickable areas).</p>
<h2 id="args">Args</h2>
<dl>
<dt>origin (float, Sequence(float, float)): a point on the mirror line</dt>
<dt><strong><code>angle</code></strong></dt>
<dd>(fpdf.enums.Angle): the direction of the mirror line</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.multi_cell"><code class="name flex">
<span>def <span class="ident">multi_cell</span></span>(<span>self,<br>w,<br>h=None,<br>text='',<br>border=0,<br>align=Align.J,<br>fill=False,<br>split_only=False,<br>link='',<br>ln='DEPRECATED',<br>max_line_height=None,<br>markdown=False,<br>print_sh=False,<br>new_x=XPos.RIGHT,<br>new_y=YPos.NEXT,<br>wrapmode: <a title="fpdf.enums.WrapMode" href="enums.html#fpdf.enums.WrapMode">WrapMode</a> = WrapMode.WORD,<br>dry_run=False,<br>output=1,<br>center=False,<br>padding=0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L3973-L4305" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@check_page
@support_deprecated_txt_arg
def multi_cell(
    self,
    w,
    h=None,
    text=&#34;&#34;,
    border=0,
    align=Align.J,
    fill=False,
    split_only=False,  # DEPRECATED
    link=&#34;&#34;,
    ln=&#34;DEPRECATED&#34;,
    max_line_height=None,
    markdown=False,
    print_sh=False,
    new_x=XPos.RIGHT,
    new_y=YPos.NEXT,
    wrapmode: WrapMode = WrapMode.WORD,
    dry_run=False,
    output=MethodReturnValue.PAGE_BREAK,
    center=False,
    padding=0,
):
    &#34;&#34;&#34;
    This method allows printing text with line breaks. They can be automatic
    (breaking at the most recent space or soft-hyphen character) as soon as the text
    reaches the right border of the cell, or explicit (via the `\\n` character).
    As many cells as necessary are stacked, one below the other.
    Text can be aligned, centered or justified. The cell block can be framed and
    the background painted. A cell has an horizontal padding, on the left &amp; right sides,
    defined by the.c_margin property.

    Args:
        w (float): cell width. If 0, they extend up to the right margin of the page.
        h (float): height of a single line of text.  Default value: None, meaning to use the current font size.
        text (str): string to print.
        border: Indicates if borders must be drawn around the cell.
            The value can be either a number (`0`: no border ; `1`: frame)
            or a string containing some or all of the following characters
            (in any order):
            `L`: left ; `T`: top ; `R`: right ; `B`: bottom. Default value: 0.
        align (fpdf.enums.Align, str): Set text alignment inside the cell.
            Possible values are:
            `J`: justify (default value); `L` or empty string: left align;
            `C`: center; `X`: center around current x position; `R`: right align
        fill (bool): Indicates if the cell background must be painted (`True`)
            or transparent (`False`). Default value: False.
        split_only (bool): **DEPRECATED since 2.7.4**:
            Use `dry_run=True` and `output=(&#34;LINES&#34;,)` instead.
        link (str): optional link to add on the cell, internal
            (identifier returned by `add_link`) or external URL.
        new_x (fpdf.enums.XPos, str): New current position in x after the call. Default: RIGHT
        new_y (fpdf.enums.YPos, str): New current position in y after the call. Default: NEXT
        ln (int): **DEPRECATED since 2.5.1**: Use `new_x` and `new_y` instead.
        max_line_height (float): optional maximum height of each sub-cell generated
        markdown (bool): enable minimal markdown-like markup to render part
            of text as bold / italics / strikethrough / underlined.
            Supports `\\` as escape character. Default to False.
        print_sh (bool): Treat a soft-hyphen (\\u00ad) as a normal printable
            character, instead of a line breaking opportunity. Default value: False
        wrapmode (fpdf.enums.WrapMode): &#34;WORD&#34; for word based line wrapping (default),
            &#34;CHAR&#34; for character based line wrapping.
        dry_run (bool): if `True`, does not output anything in the document.
            Can be useful when combined with `output`.
        output (fpdf.enums.MethodReturnValue): defines what this method returns.
            If several enum values are joined, the result will be a tuple.
        txt (str): [**DEPRECATED since v2.7.6**] string to print.
        center (bool): center the cell horizontally on the page.
        padding (float or Sequence): padding to apply around the text. Default value: 0.
            When one value is specified, it applies the same padding to all four sides.
            When two values are specified, the first padding applies to the top and bottom, the second to
            the left and right. When three values are specified, the first padding applies to the top,
            the second to the right and left, the third to the bottom. When four values are specified,
            the paddings apply to the top, right, bottom, and left in that order (clockwise)
            If padding for left or right ends up being non-zero then respective c_margin is ignored.

    Center overrides values for horizontal padding

    Using `new_x=XPos.RIGHT, new_y=XPos.TOP, maximum height=pdf.font_size` is
    useful to build tables with multiline text in cells.

    Returns: a single value or a tuple, depending on the `output` parameter value
    &#34;&#34;&#34;

    padding = Padding.new(padding)
    wrapmode = WrapMode.coerce(wrapmode)

    if split_only:
        warnings.warn(
            (
                &#39;The parameter &#34;split_only&#34; is deprecated since v2.7.4.&#39;
                &#39; Use instead dry_run=True and output=&#34;LINES&#34;.&#39;
            ),
            DeprecationWarning,
            stacklevel=get_stack_level(),
        )
    if dry_run or split_only:
        with self._disable_writing():
            return self.multi_cell(
                w=w,
                h=h,
                text=text,
                border=border,
                align=align,
                fill=fill,
                link=link,
                ln=ln,
                max_line_height=max_line_height,
                markdown=markdown,
                print_sh=print_sh,
                new_x=new_x,
                new_y=new_y,
                wrapmode=wrapmode,
                dry_run=False,
                split_only=False,
                output=MethodReturnValue.LINES if split_only else output,
                center=center,
                padding=padding,
            )
    if not self.font_family:
        raise FPDFException(&#34;No font set, you need to call set_font() beforehand&#34;)
    if isinstance(w, str) or isinstance(h, str):
        raise ValueError(
            &#34;Parameter &#39;w&#39; and &#39;h&#39; must be numbers, not strings.&#34;
            &#34; You can omit them by passing string content with text=&#34;
        )
    new_x = XPos.coerce(new_x)
    new_y = YPos.coerce(new_y)
    if ln != &#34;DEPRECATED&#34;:
        # For backwards compatibility, if &#34;ln&#34; is used we overwrite &#34;new_[xy]&#34;.
        if ln == 0:
            new_x = XPos.RIGHT
            new_y = YPos.NEXT
        elif ln == 1:
            new_x = XPos.LMARGIN
            new_y = YPos.NEXT
        elif ln == 2:
            new_x = XPos.LEFT
            new_y = YPos.NEXT
        elif ln == 3:
            new_x = XPos.RIGHT
            new_y = YPos.TOP
        else:
            raise ValueError(
                f&#39;Invalid value for parameter &#34;ln&#34; ({ln}),&#39;
                &#34; must be an int between 0 and 3.&#34;
            )
        warnings.warn(
            (
                &#39;The parameter &#34;ln&#34; is deprecated since v2.5.2.&#39;
                f&#34; Instead of ln={ln} use new_x=XPos.{new_x.name}, new_y=YPos.{new_y.name}.&#34;
            ),
            DeprecationWarning,
            stacklevel=get_stack_level(),
        )
    align = Align.coerce(align)

    page_break_triggered = False

    if h is None:
        h = self.font_size

    # If width is 0, set width to available width between margins
    if w == 0:
        w = self.w - self.r_margin - self.x

    # Store the starting position before applying padding
    prev_x, prev_y = self.x, self.y

    # Apply padding to contents
    # decrease maximum allowed width by padding
    # shift the starting point by padding
    maximum_allowed_width = w = w - padding.right - padding.left
    clearance_margins = []
    # If we don&#39;t have padding on either side, we need a clearance margin.
    if not padding.left:
        clearance_margins.append(self.c_margin)
    if not padding.right:
        clearance_margins.append(self.c_margin)
    if align != Align.X:
        self.x += padding.left
    self.y += padding.top

    # Center overrides padding
    if center:
        self.x = (
            self.w / 2 if align == Align.X else self.l_margin + (self.epw - w) / 2
        )
        prev_x = self.x

    # Calculate text length
    text = self.normalize_text(text)
    normalized_string = text.replace(&#34;\r&#34;, &#34;&#34;)
    styled_text_fragments = (
        self._preload_bidirectional_text(normalized_string, markdown)
        if self.text_shaping
        else self._preload_font_styles(normalized_string, markdown)
    )

    prev_current_font = self.current_font
    prev_font_style = self.font_style
    prev_underline = self.underline
    total_height = 0

    text_lines = []
    multi_line_break = MultiLineBreak(
        styled_text_fragments,
        maximum_allowed_width,
        clearance_margins,
        align=align,
        print_sh=print_sh,
        wrapmode=wrapmode,
    )
    text_line = multi_line_break.get_line()
    while (text_line) is not None:
        text_lines.append(text_line)
        text_line = multi_line_break.get_line()

    if not text_lines:  # ensure we display at least one cell - cf. issue #349
        text_lines = [
            TextLine(
                &#34;&#34;,
                text_width=0,
                number_of_spaces=0,
                align=align,
                height=h,
                max_width=w,
                trailing_nl=False,
            )
        ]

    if max_line_height is None or len(text_lines) == 1:
        line_height = h
    else:
        line_height = min(h, max_line_height)

    box_required = fill or border
    page_break_triggered = False

    for text_line_index, text_line in enumerate(text_lines):
        start_of_new_page = self._perform_page_break_if_need_be(h + padding.bottom)
        if start_of_new_page:
            page_break_triggered = True
            self.y += padding.top

        if box_required and (text_line_index == 0 or start_of_new_page):
            # estimate how many cells can fit on this page
            top_gap = self.y  # Top padding has already been added
            bottom_gap = padding.bottom + self.b_margin
            lines_before_break = int((self.h - top_gap - bottom_gap) // line_height)
            # check how many cells should be rendered
            num_lines = min(lines_before_break, len(text_lines) - text_line_index)
            box_height = max(
                h - text_line_index * line_height, num_lines * line_height
            )
            # render the box
            x = self.x - (w / 2 if align == Align.X else 0)
            draw_box_borders(
                self,
                x - padding.left,
                self.y - padding.top,
                x + w + padding.right,
                self.y + box_height + padding.bottom,
                border,
                self.fill_color if fill else None,
            )
        is_last_line = text_line_index == len(text_lines) - 1
        self._render_styled_text_line(
            text_line,
            h=line_height,
            new_x=new_x if is_last_line else XPos.LEFT,
            new_y=new_y if is_last_line else YPos.NEXT,
            border=0,  # already rendered
            fill=False,  # already rendered
            link=link,
            padding=Padding(0, padding.right, 0, padding.left),
            prevent_font_change=markdown,
        )
        total_height += line_height
        if not is_last_line and align == Align.X:
            # prevent cumulative shift to the left
            self.x = prev_x

    if total_height &lt; h:
        # Move to the bottom of the multi_cell
        if new_y == YPos.NEXT:
            self.y += h - total_height
        total_height = h

    if page_break_triggered and new_y == YPos.TOP:
        # When a page jump is performed and the requested y is TOP,
        # pretend we started at the top of the text block on the new page.
        # cf. test_multi_cell_table_with_automatic_page_break
        prev_y = self.y

    last_line = text_lines[-1]
    if last_line and last_line.trailing_nl and new_y in (YPos.LAST, YPos.NEXT):
        # The line renderer can&#39;t handle trailing newlines in the text.
        self.ln()

    if new_y == YPos.TOP:  # We may have jumped a few lines -&gt; reset
        self.y = prev_y
    elif new_y == YPos.NEXT:  # move down by bottom padding
        self.y += padding.bottom

    if markdown:
        self.font_style = prev_font_style
        self.current_font = prev_current_font
        self.underline = prev_underline

    if new_x == XPos.RIGHT:  # move right by right padding to align outer RHS edge
        self.x += padding.right
    elif new_x == XPos.LEFT:  # move left by left padding to align outer LHS edge
        self.x -= padding.left

    output = MethodReturnValue.coerce(output)
    return_value = ()
    if output &amp; MethodReturnValue.PAGE_BREAK:
        return_value += (page_break_triggered,)
    if output &amp; MethodReturnValue.LINES:
        output_lines = []
        for text_line in text_lines:
            characters = []
            for frag in text_line.fragments:
                characters.extend(frag.characters)
            output_lines.append(&#34;&#34;.join(characters))
        return_value += (output_lines,)
    if output &amp; MethodReturnValue.HEIGHT:
        return_value += (total_height + padding.top + padding.bottom,)
    if len(return_value) == 1:
        return return_value[0]
    return return_value</code></pre>
</details>
<div class="desc"><p>This method allows printing text with line breaks. They can be automatic
(breaking at the most recent space or soft-hyphen character) as soon as the text
reaches the right border of the cell, or explicit (via the <code>\n</code> character).
As many cells as necessary are stacked, one below the other.
Text can be aligned, centered or justified. The cell block can be framed and
the background painted. A cell has an horizontal padding, on the left &amp; right sides,
defined by the.c_margin property.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>w</code></strong> :&ensp;<code>float</code></dt>
<dd>cell width. If 0, they extend up to the right margin of the page.</dd>
<dt><strong><code>h</code></strong> :&ensp;<code>float</code></dt>
<dd>height of a single line of text.
Default value: None, meaning to use the current font size.</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>string to print.</dd>
<dt><strong><code>border</code></strong></dt>
<dd>Indicates if borders must be drawn around the cell.
The value can be either a number (<code>0</code>: no border ; <code>1</code>: frame)
or a string containing some or all of the following characters
(in any order):
<code>L</code>: left ; <code>T</code>: top ; <code>R</code>: right ; <code>B</code>: bottom. Default value: 0.</dd>
<dt><strong><code>align</code></strong> :&ensp;<code><a title="fpdf.enums.Align" href="enums.html#fpdf.enums.Align">Align</a>, str</code></dt>
<dd>Set text alignment inside the cell.
Possible values are:
<code>J</code>: justify (default value); <code>L</code> or empty string: left align;
<code>C</code>: center; <code>X</code>: center around current x position; <code>R</code>: right align</dd>
<dt><strong><code>fill</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates if the cell background must be painted (<code>True</code>)
or transparent (<code>False</code>). Default value: False.</dd>
<dt><strong><code>split_only</code></strong> :&ensp;<code>bool</code></dt>
<dd><strong>DEPRECATED since 2.7.4</strong>:
Use <code>dry_run=True</code> and <code>output=("LINES",)</code> instead.</dd>
<dt><strong><code>link</code></strong> :&ensp;<code>str</code></dt>
<dd>optional link to add on the cell, internal
(identifier returned by <code>add_link</code>) or external URL.</dd>
<dt><strong><code>new_x</code></strong> :&ensp;<code><a title="fpdf.enums.XPos" href="enums.html#fpdf.enums.XPos">XPos</a>, str</code></dt>
<dd>New current position in x after the call. Default: RIGHT</dd>
<dt><strong><code>new_y</code></strong> :&ensp;<code><a title="fpdf.enums.YPos" href="enums.html#fpdf.enums.YPos">YPos</a>, str</code></dt>
<dd>New current position in y after the call. Default: NEXT</dd>
<dt><strong><code>ln</code></strong> :&ensp;<code>int</code></dt>
<dd><strong>DEPRECATED since 2.5.1</strong>: Use <code>new_x</code> and <code>new_y</code> instead.</dd>
<dt><strong><code>max_line_height</code></strong> :&ensp;<code>float</code></dt>
<dd>optional maximum height of each sub-cell generated</dd>
<dt><strong><code>markdown</code></strong> :&ensp;<code>bool</code></dt>
<dd>enable minimal markdown-like markup to render part
of text as bold / italics / strikethrough / underlined.
Supports <code>\</code> as escape character. Default to False.</dd>
<dt><strong><code>print_sh</code></strong> :&ensp;<code>bool</code></dt>
<dd>Treat a soft-hyphen (\u00ad) as a normal printable
character, instead of a line breaking opportunity. Default value: False</dd>
<dt><strong><code>wrapmode</code></strong> :&ensp;<code><a title="fpdf.enums.WrapMode" href="enums.html#fpdf.enums.WrapMode">WrapMode</a></code></dt>
<dd>"WORD" for word based line wrapping (default),
"CHAR" for character based line wrapping.</dd>
<dt><strong><code>dry_run</code></strong> :&ensp;<code>bool</code></dt>
<dd>if <code>True</code>, does not output anything in the document.
Can be useful when combined with <code>output</code>.</dd>
<dt><strong><code>output</code></strong> :&ensp;<code><a title="fpdf.enums.MethodReturnValue" href="enums.html#fpdf.enums.MethodReturnValue">MethodReturnValue</a></code></dt>
<dd>defines what this method returns.
If several enum values are joined, the result will be a tuple.</dd>
<dt><strong><code>txt</code></strong> :&ensp;<code>str</code></dt>
<dd>[<strong>DEPRECATED since v2.7.6</strong>] string to print.</dd>
<dt><strong><code>center</code></strong> :&ensp;<code>bool</code></dt>
<dd>center the cell horizontally on the page.</dd>
<dt><strong><code>padding</code></strong> :&ensp;<code>float</code> or <code>Sequence</code></dt>
<dd>padding to apply around the text. Default value: 0.
When one value is specified, it applies the same padding to all four sides.
When two values are specified, the first padding applies to the top and bottom, the second to
the left and right. When three values are specified, the first padding applies to the top,
the second to the right and left, the third to the bottom. When four values are specified,
the paddings apply to the top, right, bottom, and left in that order (clockwise)
If padding for left or right ends up being non-zero then respective c_margin is ignored.</dd>
</dl>
<p>Center overrides values for horizontal padding</p>
<p>Using <code>new_x=XPos.RIGHT, new_y=XPos.TOP, maximum height=pdf.font_size</code> is
useful to build tables with multiline text in cells.</p>
<p>Returns: a single value or a tuple, depending on the <code>output</code> parameter value</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.new_path"><code class="name flex">
<span>def <span class="ident">new_path</span></span>(<span>self, x=0, y=0, paint_rule=PathPaintRule.AUTO, debug_stream=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L1407-L1427" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@contextmanager
def new_path(self, x=0, y=0, paint_rule=PathPaintRule.AUTO, debug_stream=None):
    &#34;&#34;&#34;
    Create a path for appending lines and curves to.

    Args:
        x (float): Abscissa of the path starting point
        y (float): Ordinate of the path starting point
        paint_rule (PathPaintRule): Optional choice of how the path should
            be painted. The default (AUTO) automatically selects stroke/fill based
            on the path style settings.
        debug_stream (TextIO): print a pretty tree of all items to be rendered
            to the provided stream. To store the output in a string, use
            `io.StringIO`.

    &#34;&#34;&#34;
    with self.drawing_context(debug_stream=debug_stream) as ctxt:
        path = PaintedPath(x=x, y=y)
        path.style.paint_rule = paint_rule
        yield path
        ctxt.add_item(path)</code></pre>
</details>
<div class="desc"><p>Create a path for appending lines and curves to.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>Abscissa of the path starting point</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>Ordinate of the path starting point</dd>
<dt><strong><code>paint_rule</code></strong> :&ensp;<code>PathPaintRule</code></dt>
<dd>Optional choice of how the path should
be painted. The default (AUTO) automatically selects stroke/fill based
on the path style settings.</dd>
<dt><strong><code>debug_stream</code></strong> :&ensp;<code>TextIO</code></dt>
<dd>print a pretty tree of all items to be rendered
to the provided stream. To store the output in a string, use
<code>io.StringIO</code>.</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.normalize_text"><code class="name flex">
<span>def <span class="ident">normalize_text</span></span>(<span>self, text)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L4886-L4899" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def normalize_text(self, text):
    &#34;&#34;&#34;Check that text input is in the correct format/encoding&#34;&#34;&#34;
    # - for TTF unicode fonts: unicode object (utf8 encoding)
    # - for built-in fonts: string instances (encoding: latin-1, cp1252)
    if not self.is_ttf_font and self.core_fonts_encoding:
        try:
            return text.encode(self.core_fonts_encoding).decode(&#34;latin-1&#34;)
        except UnicodeEncodeError as error:
            raise FPDFUnicodeEncodingException(
                text_index=error.start,
                character=text[error.start],
                font_name=self.font_family + self.font_style,
            ) from error
    return text</code></pre>
</details>
<div class="desc"><p>Check that text input is in the correct format/encoding</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.offset_rendering"><code class="name flex">
<span>def <span class="ident">offset_rendering</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L5339-L5353" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@contextmanager
def offset_rendering(self):
    &#34;&#34;&#34;
    All rendering performed in this context is made on a dummy FPDF object.
    This allows to test the results of some operations on the global layout
    before performing them &#34;for real&#34;.
    &#34;&#34;&#34;
    prev_page, prev_y = self.page, self.y
    recorder = FPDFRecorder(self, accept_page_break=False)
    recorder.page_break_triggered = False
    yield recorder
    y_scroll = recorder.y - prev_y + (recorder.page - prev_page) * self.eph
    if prev_y + y_scroll &gt; self.page_break_trigger or recorder.page &gt; prev_page:
        recorder.page_break_triggered = True
    recorder.rewind()</code></pre>
</details>
<div class="desc"><p>All rendering performed in this context is made on a dummy FPDF object.
This allows to test the results of some operations on the global layout
before performing them "for real".</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.output"><code class="name flex">
<span>def <span class="ident">output</span></span>(<span>self,<br>name='',<br>dest='',<br>linearize=False,<br>output_producer_class=fpdf.output.OutputProducer)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L5623-L5682" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def output(
    self, name=&#34;&#34;, dest=&#34;&#34;, linearize=False, output_producer_class=OutputProducer
):
    &#34;&#34;&#34;
    Output PDF to some destination.
    The method first calls [close](close.md) if necessary to terminate the document.
    After calling this method, content cannot be added to the document anymore.

    By default the bytearray buffer is returned.
    If a `name` is given, the PDF is written to a new file.

    Args:
        name (str): optional File object or file path where to save the PDF under
        dest (str): [**DEPRECATED since 2.3.0**] unused, will be removed in a later version
        output_producer_class (class): use a custom class for PDF file generation
    &#34;&#34;&#34;
    if dest:
        warnings.warn(
            (
                &#39;&#34;dest&#34; parameter is deprecated since v2.2.0, &#39;
                &#34;unused and will soon be removed&#34;
            ),
            DeprecationWarning,
            stacklevel=get_stack_level(),
        )
    # Clear cache of cached functions to free up memory after output
    get_unicode_script.cache_clear()
    # Finish document if necessary:
    if not self.buffer:
        if self.page == 0:
            self.add_page()
        # Generating final page footer:
        self._render_footer()
        # Generating .buffer based on .pages:
        if self.toc_placeholder:
            self._insert_table_of_contents()
        if self.str_alias_nb_pages:
            for page in self.pages.values():
                for substitution_item in page.get_text_substitutions():
                    page.contents = page.contents.replace(
                        substitution_item.get_placeholder_string().encode(
                            &#34;latin-1&#34;
                        ),
                        substitution_item.render_text_substitution(
                            str(self.pages_count)
                        ).encode(&#34;latin-1&#34;),
                    )
        if linearize:
            output_producer_class = LinearizedOutputProducer
        output_producer = output_producer_class(self)
        self.buffer = output_producer.bufferize()
    if name:
        if isinstance(name, os.PathLike):
            name.write_bytes(self.buffer)
        elif isinstance(name, str):
            Path(name).write_bytes(self.buffer)
        else:
            name.write(self.buffer)
        return None
    return self.buffer</code></pre>
</details>
<div class="desc"><p>Output PDF to some destination.
The method first calls <a href="close.md">close</a> if necessary to terminate the document.
After calling this method, content cannot be added to the document anymore.</p>
<p>By default the bytearray buffer is returned.
If a <code>name</code> is given, the PDF is written to a new file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>optional File object or file path where to save the PDF under</dd>
<dt><strong><code>dest</code></strong> :&ensp;<code>str</code></dt>
<dd>[<strong>DEPRECATED since 2.3.0</strong>] unused, will be removed in a later version</dd>
<dt><strong><code>output_producer_class</code></strong> :&ensp;<code>class</code></dt>
<dd>use a custom class for PDF file generation</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.page_no"><code class="name flex">
<span>def <span class="ident">page_no</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L1186-L1188" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def page_no(self):
    &#34;&#34;&#34;Get the current page number&#34;&#34;&#34;
    return self.page</code></pre>
</details>
<div class="desc"><p>Get the current page number</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.polygon"><code class="name flex">
<span>def <span class="ident">polygon</span></span>(<span>self, point_list, fill=False, style=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L1538-L1552" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@check_page
def polygon(self, point_list, fill=False, style=None):
    &#34;&#34;&#34;
    Outputs a polygon defined by three or more points.

    Args:
        point_list (list of tuples): List of coordinates defining the polygon to draw
        fill (bool): [**DEPRECATED since v2.5.4**] Use `style=&#34;F&#34;` or `style=&#34;DF&#34;` instead
        style (fpdf.enums.RenderStyle, str): Optional style of rendering. Possible values are:

        * `D` or None: draw border. This is the default value.
        * `F`: fill
        * `DF` or `FD`: draw and fill
    &#34;&#34;&#34;
    self.polyline(point_list, fill=fill, polygon=True, style=style)</code></pre>
</details>
<div class="desc"><p>Outputs a polygon defined by three or more points.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>point_list</code></strong> :&ensp;<code>list</code> of <code>tuples</code></dt>
<dd>List of coordinates defining the polygon to draw</dd>
<dt><strong><code>fill</code></strong> :&ensp;<code>bool</code></dt>
<dd>[<strong>DEPRECATED since v2.5.4</strong>] Use <code>style="F"</code> or <code>style="DF"</code> instead</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.enums.RenderStyle" href="enums.html#fpdf.enums.RenderStyle">RenderStyle</a>, str</code></dt>
<dd>Optional style of rendering. Possible values are:</dd>
</dl>
<ul>
<li><code>D</code> or None: draw border. This is the default value.</li>
<li><code>F</code>: fill</li>
<li><code>DF</code> or <code>FD</code>: draw and fill</li>
</ul></div>
</dd>
<dt id="fpdf.fpdf.FPDF.polyline"><code class="name flex">
<span>def <span class="ident">polyline</span></span>(<span>self, point_list, fill=False, polygon=False, style=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L1495-L1536" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@check_page
def polyline(self, point_list, fill=False, polygon=False, style=None):
    &#34;&#34;&#34;
    Draws lines between two or more points.

    Args:
        point_list (list of tuples): List of Abscissa and Ordinate of
                                    segments that should be drawn
        fill (bool): [**DEPRECATED since v2.5.4**] Use `style=&#34;F&#34;` or `style=&#34;DF&#34;` instead
        polygon (bool): If true, close path before stroking, to fill the inside of the polyline
        style (fpdf.enums.RenderStyle, str): Optional style of rendering. Possible values are:

        * `D` or None: draw border. This is the default value.
        * `F`: fill
        * `DF` or `FD`: draw and fill
    &#34;&#34;&#34;
    if fill:
        warnings.warn(
            (
                &#39;&#34;fill&#34; parameter is deprecated since v2.5.4, &#39;
                &#39;use style=&#34;F&#34; or style=&#34;DF&#34; instead&#39;
            ),
            DeprecationWarning,
            stacklevel=get_stack_level(),
        )
    if fill and style is None:
        style = RenderStyle.DF
    else:
        style = RenderStyle.coerce(style)
        if fill and style == RenderStyle.D:
            raise ValueError(
                f&#34;Conflicting values provided: fill={fill} &amp; style={style}&#34;
            )
    operator = &#34;m&#34;
    for point in point_list:
        self._out(
            f&#34;{point[0] * self.k:.2f} {(self.h - point[1]) * self.k:.2f} {operator}&#34;
        )
        operator = &#34;l&#34;
    if polygon:
        self._out(&#34; h&#34;)
    self._out(f&#34; {style.operator}&#34;)</code></pre>
</details>
<div class="desc"><p>Draws lines between two or more points.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>point_list</code></strong> :&ensp;<code>list</code> of <code>tuples</code></dt>
<dd>List of Abscissa and Ordinate of
segments that should be drawn</dd>
<dt><strong><code>fill</code></strong> :&ensp;<code>bool</code></dt>
<dd>[<strong>DEPRECATED since v2.5.4</strong>] Use <code>style="F"</code> or <code>style="DF"</code> instead</dd>
<dt><strong><code>polygon</code></strong> :&ensp;<code>bool</code></dt>
<dd>If true, close path before stroking, to fill the inside of the polyline</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.enums.RenderStyle" href="enums.html#fpdf.enums.RenderStyle">RenderStyle</a>, str</code></dt>
<dd>Optional style of rendering. Possible values are:</dd>
</dl>
<ul>
<li><code>D</code> or None: draw border. This is the default value.</li>
<li><code>F</code>: fill</li>
<li><code>DF</code> or <code>FD</code>: draw and fill</li>
</ul></div>
</dd>
<dt id="fpdf.fpdf.FPDF.preload_image"><code class="name flex">
<span>def <span class="ident">preload_image</span></span>(<span>self, name, dims=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L4773-L4789" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def preload_image(self, name, dims=None):
    &#34;&#34;&#34;
    Read an image and load it into memory.

    .. deprecated:: 2.7.7
        Use `fpdf.image_parsing.preload_image` instead.
    &#34;&#34;&#34;
    warnings.warn(
        (
            &#34;FPDF.preload_image() is deprecated since v2.7.7 &#34;
            &#34;and will be removed in a future release. &#34;
            &#34;Use `fpdf.image_parsing.preload_image` instead.&#34;
        ),
        DeprecationWarning,
        stacklevel=get_stack_level(),
    )
    return preload_image(self.image_cache, name, dims)</code></pre>
</details>
<div class="desc"><p>Read an image and load it into memory.</p>
<div class="admonition deprecated">
<p class="admonition-title">Deprecated since version:&ensp;2.7.7</p>
<p>Use <code><a title="fpdf.image_parsing.preload_image" href="image_parsing.html#fpdf.image_parsing.preload_image">preload_image()</a></code> instead.</p>
</div></div>
</dd>
<dt id="fpdf.fpdf.FPDF.rect"><code class="name flex">
<span>def <span class="ident">rect</span></span>(<span>self, x, y, w, h, style=None, round_corners=False, corner_radius=0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L1583-L1620" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@check_page
def rect(self, x, y, w, h, style=None, round_corners=False, corner_radius=0):
    &#34;&#34;&#34;
    Outputs a rectangle.
    It can be drawn (border only), filled (with no border) or both.

    Args:
        x (float): Abscissa of upper-left bounding box.
        y (float): Ordinate of upper-left bounding box.
        w (float): Width.
        h (float): Height.
        style (fpdf.enums.RenderStyle, str): Optional style of rendering. Possible values are:

        * `D` or empty string: draw border. This is the default value.
        * `F`: fill
        * `DF` or `FD`: draw and fill

        round_corners (tuple of str, tuple of fpdf.enums.Corner, bool): Optional draw a rectangle with round corners.
        Possible values are:

        *`TOP_LEFT`: a rectangle with round top left corner
        *`TOP_RIGHT`: a rectangle with round top right corner
        *`BOTTOM_LEFT`: a rectangle with round bottom left corner
        *`BOTTOM_RIGHT`: a rectangle with round bottom right corner
        *`True`: a rectangle with all round corners
        *`False`: a rectangle with no round corners

        corner_radius: Optional radius of the corners
    &#34;&#34;&#34;

    style = RenderStyle.coerce(style)
    if round_corners is not False:
        self._draw_rounded_rect(x, y, w, h, style, round_corners, corner_radius)
    else:
        self._out(
            f&#34;{x * self.k:.2f} {(self.h - y) * self.k:.2f} {w * self.k:.2f} &#34;
            f&#34;{-h * self.k:.2f} re {style.operator}&#34;
        )</code></pre>
</details>
<div class="desc"><p>Outputs a rectangle.
It can be drawn (border only), filled (with no border) or both.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>Abscissa of upper-left bounding box.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>Ordinate of upper-left bounding box.</dd>
<dt><strong><code>w</code></strong> :&ensp;<code>float</code></dt>
<dd>Width.</dd>
<dt><strong><code>h</code></strong> :&ensp;<code>float</code></dt>
<dd>Height.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.enums.RenderStyle" href="enums.html#fpdf.enums.RenderStyle">RenderStyle</a>, str</code></dt>
<dd>Optional style of rendering. Possible values are:</dd>
</dl>
<ul>
<li><code>D</code> or empty string: draw border. This is the default value.</li>
<li><code>F</code>: fill</li>
<li><code>DF</code> or <code>FD</code>: draw and fill</li>
</ul>
<dl>
<dt><strong><code>round_corners</code></strong> :&ensp;<code>tuple</code> of <code>str, tuple</code> of <code><a title="fpdf.enums.Corner" href="enums.html#fpdf.enums.Corner">Corner</a>, bool</code></dt>
<dd>Optional draw a rectangle with round corners.</dd>
</dl>
<p>Possible values are:</p>
<p><em><code>TOP_LEFT</code>: a rectangle with round top left corner
</em><code>TOP_RIGHT</code>: a rectangle with round top right corner
<em><code>BOTTOM_LEFT</code>: a rectangle with round bottom left corner
</em><code>BOTTOM_RIGHT</code>: a rectangle with round bottom right corner
<em><code>True</code>: a rectangle with all round corners
</em><code>False</code>: a rectangle with no round corners</p>
<dl>
<dt><strong><code>corner_radius</code></strong></dt>
<dd>Optional radius of the corners</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.rect_clip"><code class="name flex">
<span>def <span class="ident">rect_clip</span></span>(<span>self, x, y, w, h)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L5254-L5274" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@check_page
@contextmanager
def rect_clip(self, x, y, w, h):
    &#34;&#34;&#34;
    Context manager that defines a rectangular crop zone,
    useful to render only part of an image.

    Args:
        x (float): abscissa of the clipping region top left corner
        y (float): ordinate of the clipping region top left corner
        w (float): width of the clipping region
        h (float): height of the clipping region
    &#34;&#34;&#34;
    self._out(
        (
            f&#34;q {x * self.k:.2f} {(self.h - y - h) * self.k:.2f} {w * self.k:.2f} &#34;
            f&#34;{h * self.k:.2f} re W n&#34;
        )
    )
    yield
    self._out(&#34;Q&#34;)</code></pre>
</details>
<div class="desc"><p>Context manager that defines a rectangular crop zone,
useful to render only part of an image.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>abscissa of the clipping region top left corner</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>ordinate of the clipping region top left corner</dd>
<dt><strong><code>w</code></strong> :&ensp;<code>float</code></dt>
<dd>width of the clipping region</dd>
<dt><strong><code>h</code></strong> :&ensp;<code>float</code></dt>
<dd>height of the clipping region</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.regular_polygon"><code class="name flex">
<span>def <span class="ident">regular_polygon</span></span>(<span>self, x, y, numSides, polyWidth, rotateDegrees=0, style=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L1770-L1804" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@check_page
def regular_polygon(self, x, y, numSides, polyWidth, rotateDegrees=0, style=None):
    &#34;&#34;&#34;
    Outputs a regular polygon with n sides
    It can be rotated
    Style can also be applied (fill, border...)

    Args:
        x (float): Abscissa of upper-left bounding box.
        y (float): Ordinate of upper-left bounding box.
        numSides (int): Number of sides for polygon.
        polyWidth (float): Width of the polygon.
        rotateDegrees (float): Optional degree amount to rotate polygon.
        style (fpdf.enums.RenderStyle, str): Optional style of rendering. Possible values are:

        * `D` or None: draw border. This is the default value.
        * `F`: fill
        * `DF` or `FD`: draw and fill
    &#34;&#34;&#34;
    radius = polyWidth / 2
    centerX = x + radius
    centerY = y - radius
    # center point is (centerX, centerY)
    points = []
    for i in range(1, numSides + 1):
        point = centerX + radius * math.cos(
            math.radians((360 / numSides) * i) + math.radians(rotateDegrees)
        ), centerY + radius * math.sin(
            math.radians((360 / numSides) * i) + math.radians(rotateDegrees)
        )
        points.append(point)
    # creates list of touples containing cordinate points of vertices

    self.polygon(points, style=style)
    # passes points through polygon function</code></pre>
</details>
<div class="desc"><p>Outputs a regular polygon with n sides
It can be rotated
Style can also be applied (fill, border&hellip;)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>Abscissa of upper-left bounding box.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>Ordinate of upper-left bounding box.</dd>
<dt><strong><code>numSides</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of sides for polygon.</dd>
<dt><strong><code>polyWidth</code></strong> :&ensp;<code>float</code></dt>
<dd>Width of the polygon.</dd>
<dt><strong><code>rotateDegrees</code></strong> :&ensp;<code>float</code></dt>
<dd>Optional degree amount to rotate polygon.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.enums.RenderStyle" href="enums.html#fpdf.enums.RenderStyle">RenderStyle</a>, str</code></dt>
<dd>Optional style of rendering. Possible values are:</dd>
</dl>
<ul>
<li><code>D</code> or None: draw border. This is the default value.</li>
<li><code>F</code>: fill</li>
<li><code>DF</code> or <code>FD</code>: draw and fill</li>
</ul></div>
</dd>
<dt id="fpdf.fpdf.FPDF.rotate"><code class="name flex">
<span>def <span class="ident">rotate</span></span>(<span>self, angle, x=None, y=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L2819-L2852" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@check_page
def rotate(self, angle, x=None, y=None):
    &#34;&#34;&#34;
    .. deprecated:: 2.1.0
        Use `FPDF.rotation()` instead.
    &#34;&#34;&#34;
    warnings.warn(
        (
            &#34;rotate() can produces malformed PDFs and is deprecated since v2.1.0. &#34;
            &#34;It will be removed in a future release. &#34;
            &#34;Use the rotation() context manager instead.&#34;
        ),
        DeprecationWarning,
        stacklevel=get_stack_level(),
    )
    if x is None:
        x = self.x
    if y is None:
        y = self.y

    if self._angle != 0:
        self._out(&#34;Q&#34;)
    self._angle = angle
    if angle != 0:
        angle *= math.pi / 180
        c = math.cos(angle)
        s = math.sin(angle)
        cx = x * self.k
        cy = (self.h - y) * self.k
        s = (
            f&#34;q {c:.5F} {s:.5F} {-s:.5F} {c:.5F} {cx:.2F} {cy:.2F} cm &#34;
            f&#34;1 0 0 1 {-cx:.2F} {-cy:.2F} cm&#34;
        )
        self._out(s)</code></pre>
</details>
<div class="desc"><div class="admonition deprecated">
<p class="admonition-title">Deprecated since version:&ensp;2.1.0</p>
<p>Use <code><a title="fpdf.fpdf.FPDF.rotation" href="#fpdf.fpdf.FPDF.rotation">FPDF.rotation()</a></code> instead.</p>
</div></div>
</dd>
<dt id="fpdf.fpdf.FPDF.rotation"><code class="name flex">
<span>def <span class="ident">rotation</span></span>(<span>self, angle, x=None, y=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L2854-L2893" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@check_page
@contextmanager
def rotation(self, angle, x=None, y=None):
    &#34;&#34;&#34;
    Method to perform a rotation around a given center.
    It must be used as a context-manager using `with`:

        with rotation(angle=90, x=x, y=y):
            pdf.something()

    The rotation affects all elements which are printed inside the indented
    context (with the exception of clickable areas).

    Args:
        angle (float): angle in degrees
        x (float): abscissa of the center of the rotation
        y (float): ordinate of the center of the rotation

    Notes
    -----

    Only the rendering is altered. The `FPDF.get_x()` and `FPDF.get_y()` methods are
    not affected, nor the automatic page break mechanism.
    The rotation also establishes a local graphics state, so that any
    graphics state settings changed within will not affect the operations
    invoked after it has finished.
    &#34;&#34;&#34;
    if x is None:
        x = self.x
    if y is None:
        y = self.y
    angle *= math.pi / 180
    c, s = math.cos(angle), math.sin(angle)
    cx, cy = x * self.k, (self.h - y) * self.k
    with self.local_context():
        self._out(
            f&#34;{c:.5F} {s:.5F} {-s:.5F} {c:.5F} {cx:.2F} {cy:.2F} cm &#34;
            f&#34;1 0 0 1 {-cx:.2F} {-cy:.2F} cm&#34;
        )
        yield</code></pre>
</details>
<div class="desc"><p>Method to perform a rotation around a given center.
It must be used as a context-manager using <code>with</code>:</p>
<pre><code>with rotation(angle=90, x=x, y=y):
    pdf.something()
</code></pre>
<p>The rotation affects all elements which are printed inside the indented
context (with the exception of clickable areas).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code></dt>
<dd>angle in degrees</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>abscissa of the center of the rotation</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>ordinate of the center of the rotation</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Only the rendering is altered. The <code><a title="fpdf.fpdf.FPDF.get_x" href="#fpdf.fpdf.FPDF.get_x">FPDF.get_x()</a></code> and <code><a title="fpdf.fpdf.FPDF.get_y" href="#fpdf.fpdf.FPDF.get_y">FPDF.get_y()</a></code> methods are
not affected, nor the automatic page break mechanism.
The rotation also establishes a local graphics state, so that any
graphics state settings changed within will not affect the operations
invoked after it has finished.</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.round_clip"><code class="name flex">
<span>def <span class="ident">round_clip</span></span>(<span>self, x, y, r)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L5294-L5307" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@check_page
@contextmanager
def round_clip(self, x, y, r):
    &#34;&#34;&#34;
    Context manager that defines a circular crop zone,
    useful to render only part of an image.

    Args:
        x (float): abscissa of the clipping region top left corner
        y (float): ordinate of the clipping region top left corner
        r (float): radius of the clipping region
    &#34;&#34;&#34;
    with self.elliptic_clip(x, y, r, r):
        yield</code></pre>
</details>
<div class="desc"><p>Context manager that defines a circular crop zone,
useful to render only part of an image.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>abscissa of the clipping region top left corner</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>ordinate of the clipping region top left corner</dd>
<dt><strong><code>r</code></strong> :&ensp;<code>float</code></dt>
<dd>radius of the clipping region</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.set_author"><code class="name flex">
<span>def <span class="ident">set_author</span></span>(<span>self, author)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L807-L814" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def set_author(self, author):
    &#34;&#34;&#34;
    Defines the author of the document.

    Args:
        author(str): the name of the author
    &#34;&#34;&#34;
    self.author = author</code></pre>
</details>
<div class="desc"><p>Defines the author of the document.</p>
<h2 id="args">Args</h2>
<p>author(str): the name of the author</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.set_auto_page_break"><code class="name flex">
<span>def <span class="ident">set_auto_page_break</span></span>(<span>self, auto, margin=0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L605-L617" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def set_auto_page_break(self, auto, margin=0):
    &#34;&#34;&#34;
    Set auto page break mode and triggering bottom margin.
    By default, the mode is on and the bottom margin is 2 cm.

    Args:
        auto (bool): enable or disable this mode
        margin (float): optional bottom margin (distance from the bottom of the page)
            in the unit specified to FPDF constructor
    &#34;&#34;&#34;
    self.auto_page_break = auto
    self.b_margin = margin
    self.page_break_trigger = self.h - self.b_margin</code></pre>
</details>
<div class="desc"><p>Set auto page break mode and triggering bottom margin.
By default, the mode is on and the bottom margin is 2 cm.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>auto</code></strong> :&ensp;<code>bool</code></dt>
<dd>enable or disable this mode</dd>
<dt><strong><code>margin</code></strong> :&ensp;<code>float</code></dt>
<dd>optional bottom margin (distance from the bottom of the page)
in the unit specified to FPDF constructor</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.set_char_spacing"><code class="name flex">
<span>def <span class="ident">set_char_spacing</span></span>(<span>self, spacing)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L2278-L2292" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def set_char_spacing(self, spacing):
    &#34;&#34;&#34;
    Sets horizontal character spacing.
    A positive value increases the space between characters, a negative value
    reduces it (which may result in glyph overlap).
    By default, no spacing is set (which is equivalent to a value of 0).

    Args:
        spacing (float): horizontal spacing in document units
    &#34;&#34;&#34;
    if self.char_spacing == spacing:
        return
    self.char_spacing = spacing
    if self.page &gt; 0:
        self._out(f&#34;BT {spacing:.2f} Tc ET&#34;)</code></pre>
</details>
<div class="desc"><p>Sets horizontal character spacing.
A positive value increases the space between characters, a negative value
reduces it (which may result in glyph overlap).
By default, no spacing is set (which is equivalent to a value of 0).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>spacing</code></strong> :&ensp;<code>float</code></dt>
<dd>horizontal spacing in document units</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.set_compression"><code class="name flex">
<span>def <span class="ident">set_compression</span></span>(<span>self, compress)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L755-L768" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def set_compression(self, compress):
    &#34;&#34;&#34;
    Activates or deactivates page compression.

    When activated, the internal representation of each page is compressed
    using the zlib/deflate method (FlateDecode), which leads to a compression ratio
    of about 2 for the resulting document.

    Page compression is enabled by default.

    Args:
        compress (bool): indicates if compression should be enabled
    &#34;&#34;&#34;
    self.compress = compress</code></pre>
</details>
<div class="desc"><p>Activates or deactivates page compression.</p>
<p>When activated, the internal representation of each page is compressed
using the zlib/deflate method (FlateDecode), which leads to a compression ratio
of about 2 for the resulting document.</p>
<p>Page compression is enabled by default.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>compress</code></strong> :&ensp;<code>bool</code></dt>
<dd>indicates if compression should be enabled</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.set_creation_date"><code class="name flex">
<span>def <span class="ident">set_creation_date</span></span>(<span>self, date=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L839-L849" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def set_creation_date(self, date=None):
    &#34;&#34;&#34;Sets Creation of Date time, or current time if None given.&#34;&#34;&#34;
    if self._sign_key:
        raise FPDFException(
            &#34;.set_creation_date() must always be called before .sign*() methods&#34;
        )
    if not isinstance(date, datetime):
        raise TypeError(f&#34;date should be a datetime but is a {type(date)}&#34;)
    if not date.tzinfo:
        date = date.astimezone()
    self.creation_date = date</code></pre>
</details>
<div class="desc"><p>Sets Creation of Date time, or current time if None given.</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.set_creator"><code class="name flex">
<span>def <span class="ident">set_creator</span></span>(<span>self, creator)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L825-L833" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def set_creator(self, creator):
    &#34;&#34;&#34;
    Defines the creator of the document.
    This is typically the name of the application that generates the PDF.

    Args:
        creator (str): name of the PDF creator
    &#34;&#34;&#34;
    self.creator = creator</code></pre>
</details>
<div class="desc"><p>Defines the creator of the document.
This is typically the name of the application that generates the PDF.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>creator</code></strong> :&ensp;<code>str</code></dt>
<dd>name of the PDF creator</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.set_dash_pattern"><code class="name flex">
<span>def <span class="ident">set_dash_pattern</span></span>(<span>self, dash=0, gap=0, phase=0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L1442-L1467" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def set_dash_pattern(self, dash=0, gap=0, phase=0):
    &#34;&#34;&#34;
    Set the current dash pattern for lines and curves.

    Args:
        dash (float): The length of the dashes in current units.

        gap (float): The length of the gaps between dashes in current units.
            If omitted, the dash length will be used.

        phase (float): Where in the sequence to start drawing.

    Omitting &#39;dash&#39; (= 0) resets the pattern to a solid line.
    &#34;&#34;&#34;
    if not (isinstance(dash, (int, float)) and dash &gt;= 0):
        raise ValueError(&#34;Dash length must be zero or a positive number.&#34;)
    if not (isinstance(gap, (int, float)) and gap &gt;= 0):
        raise ValueError(&#34;gap length must be zero or a positive number.&#34;)
    if not (isinstance(phase, (int, float)) and phase &gt;= 0):
        raise ValueError(&#34;Phase must be zero or a positive number.&#34;)

    pattern = dict(dash=dash, gap=gap, phase=phase)

    if pattern != self.dash_pattern:
        self.dash_pattern = pattern
        self._write_dash_pattern(dash, gap, phase)</code></pre>
</details>
<div class="desc"><p>Set the current dash pattern for lines and curves.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dash</code></strong> :&ensp;<code>float</code></dt>
<dd>The length of the dashes in current units.</dd>
<dt><strong><code>gap</code></strong> :&ensp;<code>float</code></dt>
<dd>The length of the gaps between dashes in current units.
If omitted, the dash length will be used.</dd>
<dt><strong><code>phase</code></strong> :&ensp;<code>float</code></dt>
<dd>Where in the sequence to start drawing.</dd>
</dl>
<p>Omitting 'dash' (= 0) resets the pattern to a solid line.</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.set_display_mode"><code class="name flex">
<span>def <span class="ident">set_display_mode</span></span>(<span>self, zoom, layout='continuous')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L642-L664" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def set_display_mode(self, zoom, layout=&#34;continuous&#34;):
    &#34;&#34;&#34;
    Defines the way the document is to be displayed by the viewer.

    It allows to set the zoom level: pages can be displayed entirely on screen,
    occupy the full width of the window, use the real size,
    be scaled by a specific zooming factor or use the viewer default (configured in its Preferences menu).

    The page layout can also be specified: single page at a time, continuous display, two columns or viewer default.

    Args:
        zoom: either &#34;fullpage&#34;, &#34;fullwidth&#34;, &#34;real&#34;, &#34;default&#34;,
            or a number indicating the zooming factor to use, interpreted as a percentage.
            The zoom level set by default is &#34;default&#34;.
        layout (fpdf.enums.PageLayout, str): allowed layout aliases are &#34;single&#34;, &#34;continuous&#34;, &#34;two&#34; or &#34;default&#34;,
            meaning to use the viewer default mode.
            The layout set by default is &#34;continuous&#34;.
    &#34;&#34;&#34;
    if zoom in ZOOM_CONFIGS or not isinstance(zoom, str):
        self.zoom_mode = zoom
    elif zoom != &#34;default&#34;:
        raise FPDFException(f&#34;Incorrect zoom display mode: {zoom}&#34;)
    self.page_layout = LAYOUT_ALIASES.get(layout, layout)</code></pre>
</details>
<div class="desc"><p>Defines the way the document is to be displayed by the viewer.</p>
<p>It allows to set the zoom level: pages can be displayed entirely on screen,
occupy the full width of the window, use the real size,
be scaled by a specific zooming factor or use the viewer default (configured in its Preferences menu).</p>
<p>The page layout can also be specified: single page at a time, continuous display, two columns or viewer default.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>zoom</code></strong></dt>
<dd>either "fullpage", "fullwidth", "real", "default",
or a number indicating the zooming factor to use, interpreted as a percentage.
The zoom level set by default is "default".</dd>
<dt><strong><code>layout</code></strong> :&ensp;<code><a title="fpdf.enums.PageLayout" href="enums.html#fpdf.enums.PageLayout">PageLayout</a>, str</code></dt>
<dd>allowed layout aliases are "single", "continuous", "two" or "default",
meaning to use the viewer default mode.
The layout set by default is "continuous".</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.set_doc_option"><code class="name flex">
<span>def <span class="ident">set_doc_option</span></span>(<span>self, opt, value)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L860-L882" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def set_doc_option(self, opt, value):
    &#34;&#34;&#34;
    Defines a document option.

    Args:
        opt (str): name of the option to set
        value (str) option value

    .. deprecated:: 2.4.0
        Simply set the `FPDF.core_fonts_encoding` property as a replacement.
    &#34;&#34;&#34;
    warnings.warn(
        (
            &#34;set_doc_option() is deprecated since v2.4.0 &#34;
            &#34;and will be removed in a future release. &#34;
            &#34;Simply set the `.core_fonts_encoding` property as a replacement.&#34;
        ),
        DeprecationWarning,
        stacklevel=get_stack_level(),
    )
    if opt != &#34;core_fonts_encoding&#34;:
        raise FPDFException(f&#39;Unknown document option &#34;{opt}&#34;&#39;)
    self.core_fonts_encoding = value</code></pre>
</details>
<div class="desc"><p>Defines a document option.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>opt</code></strong> :&ensp;<code>str</code></dt>
<dd>name of the option to set</dd>
</dl>
<p>value (str) option value</p>
<div class="admonition deprecated">
<p class="admonition-title">Deprecated since version:&ensp;2.4.0</p>
<p>Simply set the <code><a title="fpdf.fpdf.FPDF.core_fonts_encoding" href="#fpdf.fpdf.FPDF.core_fonts_encoding">FPDF.core_fonts_encoding</a></code> property as a replacement.</p>
</div></div>
</dd>
<dt id="fpdf.fpdf.FPDF.set_draw_color"><code class="name flex">
<span>def <span class="ident">set_draw_color</span></span>(<span>self, r, g=-1, b=-1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L1198-L1215" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def set_draw_color(self, r, g=-1, b=-1):
    &#34;&#34;&#34;
    Defines the color used for all stroking operations (lines, rectangles and cell borders).
    Accepts either a single greyscale value, 3 values as RGB components, a single `#abc` or `#abcdef` hexadecimal color string,
    or an instance of `fpdf.drawing.DeviceCMYK`, `fpdf.drawing.DeviceRGB` or `fpdf.drawing.DeviceGray`.
    The method can be called before the first page is created and the value is retained from page to page.

    Args:
        r (int, tuple, fpdf.drawing.DeviceGray, fpdf.drawing.DeviceRGB): if `g` and `b` are given, this indicates the red component.
            Else, this indicates the grey level. The value must be between 0 and 255.
        g (int): green component (between 0 and 255)
        b (int): blue component (between 0 and 255)
    &#34;&#34;&#34;
    draw_color = convert_to_device_color(r, g, b)
    if draw_color != self.draw_color:
        self.draw_color = draw_color
        if self.page &gt; 0:
            self._out(self.draw_color.serialize().upper())</code></pre>
</details>
<div class="desc"><p>Defines the color used for all stroking operations (lines, rectangles and cell borders).
Accepts either a single greyscale value, 3 values as RGB components, a single <code>#abc</code> or <code>#abcdef</code> hexadecimal color string,
or an instance of <code><a title="fpdf.drawing.DeviceCMYK" href="drawing.html#fpdf.drawing.DeviceCMYK">DeviceCMYK</a></code>, <code><a title="fpdf.drawing.DeviceRGB" href="drawing.html#fpdf.drawing.DeviceRGB">DeviceRGB</a></code> or <code><a title="fpdf.drawing.DeviceGray" href="drawing.html#fpdf.drawing.DeviceGray">DeviceGray</a></code>.
The method can be called before the first page is created and the value is retained from page to page.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>r</code></strong> :&ensp;<code>int, tuple, <a title="fpdf.drawing.DeviceGray" href="drawing.html#fpdf.drawing.DeviceGray">DeviceGray</a>, <a title="fpdf.drawing.DeviceRGB" href="drawing.html#fpdf.drawing.DeviceRGB">DeviceRGB</a></code></dt>
<dd>if <code>g</code> and <code>b</code> are given, this indicates the red component.
Else, this indicates the grey level. The value must be between 0 and 255.</dd>
<dt><strong><code>g</code></strong> :&ensp;<code>int</code></dt>
<dd>green component (between 0 and 255)</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>int</code></dt>
<dd>blue component (between 0 and 255)</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.set_encryption"><code class="name flex">
<span>def <span class="ident">set_encryption</span></span>(<span>self,<br>owner_password,<br>user_password=None,<br>encryption_method=EncryptionMethod.RC4,<br>permissions=3900,<br>encrypt_metadata=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L388-L419" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def set_encryption(
    self,
    owner_password,
    user_password=None,
    encryption_method=EncryptionMethod.RC4,
    permissions=AccessPermission.all(),
    encrypt_metadata=False,
):
    &#34;&#34;&#34;
    Activate encryption of the document content.

    Args:
        owner_password (str): mandatory. The owner password allows to perform any change on the document,
            including removing all encryption and access permissions.
        user_password (str): optional. If a user password is set, the content of the document will be encrypted
            and a password prompt displayed when a user opens the document.
            The document will only be displayed after either the user or owner password is entered.
        encryption_method (fpdf.enums.EncryptionMethod, str): algorithm to be used to encrypt the document.
            Defaults to RC4.
        permissions (fpdf.enums.AccessPermission): specify access permissions granted
            when the document is opened with user access. Defaults to ALL.
        encrypt_metadata (bool): whether to also encrypt document metadata (author, creation date, etc.).
            Defaults to False.
    &#34;&#34;&#34;
    self._security_handler = StandardSecurityHandler(
        self,
        owner_password=owner_password,
        user_password=user_password,
        permission=permissions,
        encryption_method=encryption_method,
        encrypt_metadata=encrypt_metadata,
    )</code></pre>
</details>
<div class="desc"><p>Activate encryption of the document content.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>owner_password</code></strong> :&ensp;<code>str</code></dt>
<dd>mandatory. The owner password allows to perform any change on the document,
including removing all encryption and access permissions.</dd>
<dt><strong><code>user_password</code></strong> :&ensp;<code>str</code></dt>
<dd>optional. If a user password is set, the content of the document will be encrypted
and a password prompt displayed when a user opens the document.
The document will only be displayed after either the user or owner password is entered.</dd>
<dt><strong><code>encryption_method</code></strong> :&ensp;<code><a title="fpdf.enums.EncryptionMethod" href="enums.html#fpdf.enums.EncryptionMethod">EncryptionMethod</a>, str</code></dt>
<dd>algorithm to be used to encrypt the document.
Defaults to RC4.</dd>
<dt><strong><code>permissions</code></strong> :&ensp;<code><a title="fpdf.enums.AccessPermission" href="enums.html#fpdf.enums.AccessPermission">AccessPermission</a></code></dt>
<dd>specify access permissions granted
when the document is opened with user access. Defaults to ALL.</dd>
<dt><strong><code>encrypt_metadata</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether to also encrypt document metadata (author, creation date, etc.).
Defaults to False.</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.set_fallback_fonts"><code class="name flex">
<span>def <span class="ident">set_fallback_fonts</span></span>(<span>self, fallback_fonts, exact_match=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L2308-L2334" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def set_fallback_fonts(self, fallback_fonts, exact_match=True):
    &#34;&#34;&#34;
    Allows you to specify a list of fonts to be used if any character is not available on the font currently set.
    Detailed documentation: https://py-pdf.github.io/fpdf2/Unicode.html#fallback-fonts

    Args:
        fallback_fonts: sequence of fallback font IDs
        exact_match (bool): when a glyph cannot be rendered uing the current font,
            fpdf2 will look for a fallback font matching the current character emphasis (bold/italics).
            If it does not find such matching font, and `exact_match` is True, no fallback font will be used.
            If it does not find such matching font, and `exact_match` is False, a fallback font will still be used.
            To get even more control over this logic, you can also override `FPDF.get_fallback_font()`
    &#34;&#34;&#34;
    fallback_font_ids = []
    for fallback_font in fallback_fonts:
        found = False
        for fontkey in self.fonts:
            # will add all font styles on the same family
            if fontkey.replace(&#34;B&#34;, &#34;&#34;).replace(&#34;I&#34;, &#34;&#34;) == fallback_font.lower():
                fallback_font_ids.append(fontkey)
                found = True
        if not found:
            raise FPDFException(
                f&#34;Undefined fallback font: {fallback_font} - Use FPDF.add_font() beforehand&#34;
            )
    self._fallback_font_ids = tuple(fallback_font_ids)
    self._fallback_font_exact_match = exact_match</code></pre>
</details>
<div class="desc"><p>Allows you to specify a list of fonts to be used if any character is not available on the font currently set.
Detailed documentation: <a href="https://py-pdf.github.io/fpdf2/Unicode.html#fallback-fonts">https://py-pdf.github.io/fpdf2/Unicode.html#fallback-fonts</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fallback_fonts</code></strong></dt>
<dd>sequence of fallback font IDs</dd>
<dt><strong><code>exact_match</code></strong> :&ensp;<code>bool</code></dt>
<dd>when a glyph cannot be rendered uing the current font,
fpdf2 will look for a fallback font matching the current character emphasis (bold/italics).
If it does not find such matching font, and <code>exact_match</code> is True, no fallback font will be used.
If it does not find such matching font, and <code>exact_match</code> is False, a fallback font will still be used.
To get even more control over this logic, you can also override <code><a title="fpdf.fpdf.FPDF.get_fallback_font" href="#fpdf.fpdf.FPDF.get_fallback_font">FPDF.get_fallback_font()</a></code></dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.set_fill_color"><code class="name flex">
<span>def <span class="ident">set_fill_color</span></span>(<span>self, r, g=-1, b=-1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L1217-L1234" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def set_fill_color(self, r, g=-1, b=-1):
    &#34;&#34;&#34;
    Defines the color used for all filling operations (filled rectangles and cell backgrounds).
    Accepts either a single greyscale value, 3 values as RGB components, a single `#abc` or `#abcdef` hexadecimal color string,
    or an instance of `fpdf.drawing.DeviceCMYK`, `fpdf.drawing.DeviceRGB` or `fpdf.drawing.DeviceGray`.
    The method can be called before the first page is created and the value is retained from page to page.

    Args:
        r (int, tuple, fpdf.drawing.DeviceGray, fpdf.drawing.DeviceRGB): if `g` and `b` are given, this indicates the red component.
            Else, this indicates the grey level. The value must be between 0 and 255.
        g (int): green component (between 0 and 255)
        b (int): blue component (between 0 and 255)
    &#34;&#34;&#34;
    fill_color = convert_to_device_color(r, g, b)
    if fill_color != self.fill_color:
        self.fill_color = fill_color
        if self.page &gt; 0:
            self._out(self.fill_color.serialize().lower())</code></pre>
</details>
<div class="desc"><p>Defines the color used for all filling operations (filled rectangles and cell backgrounds).
Accepts either a single greyscale value, 3 values as RGB components, a single <code>#abc</code> or <code>#abcdef</code> hexadecimal color string,
or an instance of <code><a title="fpdf.drawing.DeviceCMYK" href="drawing.html#fpdf.drawing.DeviceCMYK">DeviceCMYK</a></code>, <code><a title="fpdf.drawing.DeviceRGB" href="drawing.html#fpdf.drawing.DeviceRGB">DeviceRGB</a></code> or <code><a title="fpdf.drawing.DeviceGray" href="drawing.html#fpdf.drawing.DeviceGray">DeviceGray</a></code>.
The method can be called before the first page is created and the value is retained from page to page.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>r</code></strong> :&ensp;<code>int, tuple, <a title="fpdf.drawing.DeviceGray" href="drawing.html#fpdf.drawing.DeviceGray">DeviceGray</a>, <a title="fpdf.drawing.DeviceRGB" href="drawing.html#fpdf.drawing.DeviceRGB">DeviceRGB</a></code></dt>
<dd>if <code>g</code> and <code>b</code> are given, this indicates the red component.
Else, this indicates the grey level. The value must be between 0 and 255.</dd>
<dt><strong><code>g</code></strong> :&ensp;<code>int</code></dt>
<dd>green component (between 0 and 255)</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>int</code></dt>
<dd>blue component (between 0 and 255)</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.set_font"><code class="name flex">
<span>def <span class="ident">set_font</span></span>(<span>self,<br>family=None,<br>style: str | <a title="fpdf.enums.TextEmphasis" href="enums.html#fpdf.enums.TextEmphasis">TextEmphasis</a> = '',<br>size=0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L2161-L2252" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def set_font(self, family=None, style: Union[str, TextEmphasis] = &#34;&#34;, size=0):
    &#34;&#34;&#34;
    Sets the font used to print character strings.
    It is mandatory to call this method at least once before printing text.

    Default encoding is not specified, but all text writing methods accept only
    unicode for external fonts and one byte encoding for standard.

    Standard fonts use `Latin-1` encoding by default, but Windows
    encoding `cp1252` (Western Europe) can be used with
    `self.core_fonts_encoding = encoding`.

    The font specified is retained from page to page.
    The method can be called before the first page is created.

    Args:
        family (str): name of a font added with `FPDF.add_font`,
            or name of one of the 14 standard &#34;PostScript&#34; fonts:
            Courier (fixed-width), Helvetica (sans serif), Times (serif),
            Symbol (symbolic) or ZapfDingbats (symbolic)
            If an empty string is provided, the current family is retained.
        style (str, fpdf.enums.TextEmphasis): empty string (by default) or a combination
            of one or several letters among B (bold), I (italic), S (strikethrough) and U (underline).
            Bold and italic styles do not apply to Symbol and ZapfDingbats fonts.
        size (float): in points. The default value is the current size.
    &#34;&#34;&#34;
    if not family:
        family = self.font_family

    family = family.lower()
    if isinstance(style, TextEmphasis):
        style = style.style
    style = &#34;&#34;.join(sorted(style.upper()))
    if any(letter not in &#34;BISU&#34; for letter in style):
        raise ValueError(
            f&#34;Unknown style provided (only B/I/S/U letters are allowed): {style}&#34;
        )
    if &#34;U&#34; in style:
        self.underline = True
        style = style.replace(&#34;U&#34;, &#34;&#34;)
    else:
        self.underline = False
    if &#34;S&#34; in style:
        self.strikethrough = True
        style = style.replace(&#34;S&#34;, &#34;&#34;)
    else:
        self.strikethrough = False

    if family in self.font_aliases and family + style not in self.fonts:
        warnings.warn(
            f&#34;Substituting font {family} by core font {self.font_aliases[family]}&#34;
            &#34; - This is deprecated since v2.7.8, and will soon be removed&#34;,
            DeprecationWarning,
            stacklevel=get_stack_level(),
        )
        family = self.font_aliases[family]
    elif family in (&#34;symbol&#34;, &#34;zapfdingbats&#34;) and style:
        warnings.warn(
            f&#34;Built-in font {family} only has a single &#39;style&#39; &#34;
            &#34;and can&#39;t be bold or italic&#34;,
            stacklevel=get_stack_level(),
        )
        style = &#34;&#34;

    if not size:
        size = self.font_size_pt

    # Test if font is already selected
    if (
        self.font_family == family
        and self.font_style == style
        and isclose(self.font_size_pt, size)
    ):
        return

    # Test if used for the first time
    fontkey = family + style
    if fontkey not in self.fonts:
        if fontkey not in CORE_FONTS:
            raise FPDFException(
                f&#34;Undefined font: {fontkey} - &#34;
                f&#34;Use built-in fonts or FPDF.add_font() beforehand&#34;
            )
        # If it&#39;s one of the core fonts, add it to self.fonts
        self.fonts[fontkey] = CoreFont(self, fontkey, style)

    # Select it
    self.font_family = family
    self.font_style = style
    self.font_size_pt = size
    self.current_font = self.fonts[fontkey]
    self.current_font_is_set_on_page = False</code></pre>
</details>
<div class="desc"><p>Sets the font used to print character strings.
It is mandatory to call this method at least once before printing text.</p>
<p>Default encoding is not specified, but all text writing methods accept only
unicode for external fonts and one byte encoding for standard.</p>
<p>Standard fonts use <code>Latin-1</code> encoding by default, but Windows
encoding <code>cp1252</code> (Western Europe) can be used with
<code>self.core_fonts_encoding = encoding</code>.</p>
<p>The font specified is retained from page to page.
The method can be called before the first page is created.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>family</code></strong> :&ensp;<code>str</code></dt>
<dd>name of a font added with <code><a title="fpdf.fpdf.FPDF.add_font" href="#fpdf.fpdf.FPDF.add_font">FPDF.add_font()</a></code>,
or name of one of the 14 standard "PostScript" fonts:
Courier (fixed-width), Helvetica (sans serif), Times (serif),
Symbol (symbolic) or ZapfDingbats (symbolic)
If an empty string is provided, the current family is retained.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code>str, <a title="fpdf.enums.TextEmphasis" href="enums.html#fpdf.enums.TextEmphasis">TextEmphasis</a></code></dt>
<dd>empty string (by default) or a combination
of one or several letters among B (bold), I (italic), S (strikethrough) and U (underline).
Bold and italic styles do not apply to Symbol and ZapfDingbats fonts.</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>float</code></dt>
<dd>in points. The default value is the current size.</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.set_font_size"><code class="name flex">
<span>def <span class="ident">set_font_size</span></span>(<span>self, size)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L2254-L2264" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def set_font_size(self, size):
    &#34;&#34;&#34;
    Configure the font size in points

    Args:
        size (float): font size in points
    &#34;&#34;&#34;
    if isclose(self.font_size_pt, size):
        return
    self.font_size_pt = size
    self.current_font_is_set_on_page = False</code></pre>
</details>
<div class="desc"><p>Configure the font size in points</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>size</code></strong> :&ensp;<code>float</code></dt>
<dd>font size in points</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.set_image_filter"><code class="name flex">
<span>def <span class="ident">set_image_filter</span></span>(<span>self, image_filter)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L884-L901" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def set_image_filter(self, image_filter):
    &#34;&#34;&#34;
    Args:
        image_filter (str): name of a the image filter to use
            when embedding images in the document, or &#34;AUTO&#34;,
            meaning to use the best image filter given the images provided.
            Allowed values: `FlateDecode` (lossless zlib/deflate compression),
            `DCTDecode` (lossy compression with JPEG)
            and `JPXDecode` (lossy compression with JPEG2000).
    &#34;&#34;&#34;
    if image_filter not in SUPPORTED_IMAGE_FILTERS:
        raise ValueError(
            f&#34;&#39;{image_filter}&#39; is not a supported image filter&#34;
            f&#34; - Allowed values: {&#39;&#39;.join(SUPPORTED_IMAGE_FILTERS)}&#34;
        )
    self.image_cache.image_filter = image_filter
    if image_filter == &#34;JPXDecode&#34;:
        self._set_min_pdf_version(&#34;1.5&#34;)</code></pre>
</details>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>image_filter</code></strong> :&ensp;<code>str</code></dt>
<dd>name of a the image filter to use
when embedding images in the document, or "AUTO",
meaning to use the best image filter given the images provided.
Allowed values: <code>FlateDecode</code> (lossless zlib/deflate compression),
<code>DCTDecode</code> (lossy compression with JPEG)
and <code>JPXDecode</code> (lossy compression with JPEG2000).</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.set_keywords"><code class="name flex">
<span>def <span class="ident">set_keywords</span></span>(<span>self, keywords)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L816-L823" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def set_keywords(self, keywords):
    &#34;&#34;&#34;
    Associate keywords with the document

    Args:
        keywords (str): a space-separated list of words
    &#34;&#34;&#34;
    self.keywords = keywords</code></pre>
</details>
<div class="desc"><p>Associate keywords with the document</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>keywords</code></strong> :&ensp;<code>str</code></dt>
<dd>a space-separated list of words</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.set_lang"><code class="name flex">
<span>def <span class="ident">set_lang</span></span>(<span>self, lang)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L784-L796" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def set_lang(self, lang):
    &#34;&#34;&#34;
    A language identifier specifying the natural language for all text in the document
    except where overridden by language specifications for structure elements or marked content.
    A language identifier can either be the empty text string, to indicate that the language is unknown,
    or a Language-Tag as defined in RFC 3066, &#34;Tags for the Identification of Languages&#34;.

    Args:
        lang (str): the document main language
    &#34;&#34;&#34;
    self.lang = lang
    if lang:
        self._set_min_pdf_version(&#34;1.4&#34;)</code></pre>
</details>
<div class="desc"><p>A language identifier specifying the natural language for all text in the document
except where overridden by language specifications for structure elements or marked content.
A language identifier can either be the empty text string, to indicate that the language is unknown,
or a Language-Tag as defined in RFC 3066, "Tags for the Identification of Languages".</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>lang</code></strong> :&ensp;<code>str</code></dt>
<dd>the document main language</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.set_left_margin"><code class="name flex">
<span>def <span class="ident">set_left_margin</span></span>(<span>self, margin)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L575-L585" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def set_left_margin(self, margin):
    &#34;&#34;&#34;
    Sets the document left margin.
    Also sets the current FPDF.x on the page to this minimum horizontal position.

    Args:
        margin (float): margin in the unit specified to FPDF constructor
    &#34;&#34;&#34;
    if self.x &lt; margin or self.x == self.l_margin:
        self.x = margin
    self.l_margin = margin</code></pre>
</details>
<div class="desc"><p>Sets the document left margin.
Also sets the current FPDF.x on the page to this minimum horizontal position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>margin</code></strong> :&ensp;<code>float</code></dt>
<dd>margin in the unit specified to FPDF constructor</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.set_line_width"><code class="name flex">
<span>def <span class="ident">set_line_width</span></span>(<span>self, width)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L1271-L1283" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def set_line_width(self, width):
    &#34;&#34;&#34;
    Defines the line width of all stroking operations (lines, rectangles and cell borders).
    By default, the value equals 0.2 mm.
    The method can be called before the first page is created and the value is retained from page to page.

    Args:
        width (float): the width in user unit
    &#34;&#34;&#34;
    if width != self.line_width:
        self.line_width = width
        if self.page &gt; 0:
            self._out(f&#34;{width * self.k:.2f} w&#34;)</code></pre>
</details>
<div class="desc"><p>Defines the line width of all stroking operations (lines, rectangles and cell borders).
By default, the value equals 0.2 mm.
The method can be called before the first page is created and the value is retained from page to page.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>width</code></strong> :&ensp;<code>float</code></dt>
<dd>the width in user unit</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.set_link"><code class="name flex">
<span>def <span class="ident">set_link</span></span>(<span>self, link, y=0, x=0, page=-1, zoom='null')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L2364-L2386" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def set_link(self, link, y=0, x=0, page=-1, zoom=&#34;null&#34;):
    &#34;&#34;&#34;
    Defines the page and position a link points to.

    Args:
        link (int): a link identifier returned by `FPDF.add_link()`.
        y (float): optional ordinate of target position.
            The default value is 0 (top of page).
        x (float): optional abscissa of target position.
            The default value is 0 (top of page).
        page (int): optional number of target page.
            -1 indicates the current page, which is the default value.
        zoom (float): optional new zoom level after following the link.
            Currently ignored by Sumatra PDF Reader, but observed by Adobe Acrobat reader.
    &#34;&#34;&#34;
    # We must take care to update the existing DestinationXYZ,
    # and NOT re-assign self.links[link] to a new instance,
    # as a reference to self.links[link] is kept in self.pages[].annots:
    link = self.links[link]
    link.page_number = self.page if page == -1 else page
    link.top = self.h_pt - y * self.k
    link.left = x * self.k
    link.zoom = zoom</code></pre>
</details>
<div class="desc"><p>Defines the page and position a link points to.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>link</code></strong> :&ensp;<code>int</code></dt>
<dd>a link identifier returned by <code><a title="fpdf.fpdf.FPDF.add_link" href="#fpdf.fpdf.FPDF.add_link">FPDF.add_link()</a></code>.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>optional ordinate of target position.
The default value is 0 (top of page).</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>optional abscissa of target position.
The default value is 0 (top of page).</dd>
<dt><strong><code>page</code></strong> :&ensp;<code>int</code></dt>
<dd>optional number of target page.
-1 indicates the current page, which is the default value.</dd>
<dt><strong><code>zoom</code></strong> :&ensp;<code>float</code></dt>
<dd>optional new zoom level after following the link.
Currently ignored by Sumatra PDF Reader, but observed by Adobe Acrobat reader.</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.set_margin"><code class="name flex">
<span>def <span class="ident">set_margin</span></span>(<span>self, margin)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L546-L554" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def set_margin(self, margin):
    &#34;&#34;&#34;
    Sets the document right, left, top &amp; bottom margins to the same value.

    Args:
        margin (float): margin in the unit specified to FPDF constructor
    &#34;&#34;&#34;
    self.set_margins(margin, margin)
    self.set_auto_page_break(self.auto_page_break, margin)</code></pre>
</details>
<div class="desc"><p>Sets the document right, left, top &amp; bottom margins to the same value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>margin</code></strong> :&ensp;<code>float</code></dt>
<dd>margin in the unit specified to FPDF constructor</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.set_margins"><code class="name flex">
<span>def <span class="ident">set_margins</span></span>(<span>self, left, top, right=-1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L556-L573" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def set_margins(self, left, top, right=-1):
    &#34;&#34;&#34;
    Sets the document left, top &amp; optionally right margins to the same value.
    By default, they equal 1 cm.
    Also sets the current FPDF.y on the page to this minimum vertical position.

    Args:
        left (float): left margin in the unit specified to FPDF constructor
        top (float): top margin in the unit specified to FPDF constructor
        right (float): optional right margin in the unit specified to FPDF constructor
    &#34;&#34;&#34;
    self.set_left_margin(left)
    if self.y &lt; top or self.y == self.t_margin:
        self.y = top
    self.t_margin = top
    if right == -1:
        right = left
    self.r_margin = right</code></pre>
</details>
<div class="desc"><p>Sets the document left, top &amp; optionally right margins to the same value.
By default, they equal 1 cm.
Also sets the current FPDF.y on the page to this minimum vertical position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>left</code></strong> :&ensp;<code>float</code></dt>
<dd>left margin in the unit specified to FPDF constructor</dd>
<dt><strong><code>top</code></strong> :&ensp;<code>float</code></dt>
<dd>top margin in the unit specified to FPDF constructor</dd>
<dt><strong><code>right</code></strong> :&ensp;<code>float</code></dt>
<dd>optional right margin in the unit specified to FPDF constructor</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.set_page_background"><code class="name flex">
<span>def <span class="ident">set_page_background</span></span>(<span>self, background)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L1285-L1307" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def set_page_background(self, background):
    &#34;&#34;&#34;
    Sets a background color or image to be drawn every time `FPDF.add_page()` is called, or removes a previously set background.
    The method can be called before the first page is created and the value is retained from page to page.

    Args:
        background: either a string representing a file path or URL to an image,
            an io.BytesIO containing an image as bytes, an instance of `PIL.Image.Image`, drawing.DeviceRGB
            or a RGB tuple representing a color to fill the background with or `None` to remove the background
    &#34;&#34;&#34;

    if isinstance(
        background, (str, io.BytesIO, Image, DeviceRGB, tuple, type(None))
    ):
        if isinstance(background, DeviceRGB):
            self.page_background = background.colors255
        else:
            self.page_background = background
    else:
        raise TypeError(
            f&#34;&#34;&#34;background must be of type str, io.BytesIO, PIL.Image.Image, drawing.DeviceRGB, tuple or None
    got: {type(background)}&#34;&#34;&#34;
        )</code></pre>
</details>
<div class="desc"><p>Sets a background color or image to be drawn every time <code><a title="fpdf.fpdf.FPDF.add_page" href="#fpdf.fpdf.FPDF.add_page">FPDF.add_page()</a></code> is called, or removes a previously set background.
The method can be called before the first page is created and the value is retained from page to page.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>background</code></strong></dt>
<dd>either a string representing a file path or URL to an image,
an io.BytesIO containing an image as bytes, an instance of <code>PIL.Image.Image</code>, drawing.DeviceRGB
or a RGB tuple representing a color to fill the background with or <code>None</code> to remove the background</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.set_page_label"><code class="name flex">
<span>def <span class="ident">set_page_label</span></span>(<span>self,<br>label_style: str | <a title="fpdf.enums.PageLabelStyle" href="enums.html#fpdf.enums.PageLabelStyle">PageLabelStyle</a> = None,<br>label_prefix: str = None,<br>label_start: int = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L927-L960" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@check_page
def set_page_label(
    self,
    label_style: Union[str, PageLabelStyle] = None,
    label_prefix: str = None,
    label_start: int = None,
):
    &#34;&#34;&#34;
    Enable `fpdf.output.PDFPageLabel` to be inserted on every page.
    This will be displayed by some PDF readers to identify pages.
    &#34;&#34;&#34;
    current_page_label = None
    if self.page in self.pages:
        current_page_label = self.pages[self.page].get_page_label()
    elif self.page &gt; 1:
        current_page_label = self.pages[self.page - 1].get_page_label()
    new_page_label = None
    if label_style or label_prefix or label_start:
        if current_page_label:
            if label_style is None:
                label_style = current_page_label.get_style()
            if label_prefix is None:
                label_prefix = current_page_label.get_prefix()
            if label_start is None and not (
                self.toc_placeholder and self.toc_placeholder.reset_page_indices
            ):
                label_start = current_page_label.get_start()
        label_style = (
            PageLabelStyle.coerce(label_style, case_sensitive=True)
            if label_style
            else None
        )
        new_page_label = PDFPageLabel(label_style, label_prefix, label_start)
    self.pages[self.page].set_page_label(current_page_label, new_page_label)</code></pre>
</details>
<div class="desc"><p>Enable <code><a title="fpdf.output.PDFPageLabel" href="output.html#fpdf.output.PDFPageLabel">PDFPageLabel</a></code> to be inserted on every page.
This will be displayed by some PDF readers to identify pages.</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.set_producer"><code class="name flex">
<span>def <span class="ident">set_producer</span></span>(<span>self, producer)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L835-L837" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def set_producer(self, producer):
    &#34;&#34;&#34;Producer of document&#34;&#34;&#34;
    self.producer = producer</code></pre>
</details>
<div class="desc"><p>Producer of document</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.set_right_margin"><code class="name flex">
<span>def <span class="ident">set_right_margin</span></span>(<span>self, margin)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L596-L603" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def set_right_margin(self, margin):
    &#34;&#34;&#34;
    Sets the document right margin.

    Args:
        margin (float): margin in the unit specified to FPDF constructor
    &#34;&#34;&#34;
    self.r_margin = margin</code></pre>
</details>
<div class="desc"><p>Sets the document right margin.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>margin</code></strong> :&ensp;<code>float</code></dt>
<dd>margin in the unit specified to FPDF constructor</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.set_section_title_styles"><code class="name flex">
<span>def <span class="ident">set_section_title_styles</span></span>(<span>self,<br>level0,<br>level1=None,<br>level2=None,<br>level3=None,<br>level4=None,<br>level5=None,<br>level6=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L5406-L5442" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def set_section_title_styles(
    self,
    level0,
    level1=None,
    level2=None,
    level3=None,
    level4=None,
    level5=None,
    level6=None,
):
    &#34;&#34;&#34;
    Defines a style for section titles.
    After calling this method, calls to `FPDF.start_section` will render section names visually.

    Args:
        level0 (TextStyle): style for the top level section titles
        level1 (TextStyle): optional style for the level 1 section titles
        level2 (TextStyle): optional style for the level 2 section titles
        level3 (TextStyle): optional style for the level 3 section titles
        level4 (TextStyle): optional style for the level 4 section titles
        level5 (TextStyle): optional style for the level 5 section titles
        level6 (TextStyle): optional style for the level 6 section titles
    &#34;&#34;&#34;
    for level in (level0, level1, level2, level3, level4, level5, level6):
        if level and not isinstance(level, TextStyle):
            raise TypeError(
                f&#34;Arguments must all be TextStyle instances, got: {type(level)}&#34;
            )
    self.section_title_styles = {
        0: level0,
        1: level1,
        2: level2,
        3: level3,
        4: level4,
        5: level5,
        6: level6,
    }</code></pre>
</details>
<div class="desc"><p>Defines a style for section titles.
After calling this method, calls to <code><a title="fpdf.fpdf.FPDF.start_section" href="#fpdf.fpdf.FPDF.start_section">FPDF.start_section()</a></code> will render section names visually.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>level0</code></strong> :&ensp;<code>TextStyle</code></dt>
<dd>style for the top level section titles</dd>
<dt><strong><code>level1</code></strong> :&ensp;<code>TextStyle</code></dt>
<dd>optional style for the level 1 section titles</dd>
<dt><strong><code>level2</code></strong> :&ensp;<code>TextStyle</code></dt>
<dd>optional style for the level 2 section titles</dd>
<dt><strong><code>level3</code></strong> :&ensp;<code>TextStyle</code></dt>
<dd>optional style for the level 3 section titles</dd>
<dt><strong><code>level4</code></strong> :&ensp;<code>TextStyle</code></dt>
<dd>optional style for the level 4 section titles</dd>
<dt><strong><code>level5</code></strong> :&ensp;<code>TextStyle</code></dt>
<dd>optional style for the level 5 section titles</dd>
<dt><strong><code>level6</code></strong> :&ensp;<code>TextStyle</code></dt>
<dd>optional style for the level 6 section titles</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.set_stretching"><code class="name flex">
<span>def <span class="ident">set_stretching</span></span>(<span>self, stretching)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L2294-L2306" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def set_stretching(self, stretching):
    &#34;&#34;&#34;
    Sets horizontal font stretching.
    By default, no stretching is set (which is equivalent to a value of 100).

    Args:
        stretching (float): horizontal stretching (scaling) in percents.
    &#34;&#34;&#34;
    if self.font_stretching == stretching:
        return
    self.font_stretching = stretching
    if self.page &gt; 0:
        self._out(f&#34;BT {stretching:.2f} Tz ET&#34;)</code></pre>
</details>
<div class="desc"><p>Sets horizontal font stretching.
By default, no stretching is set (which is equivalent to a value of 100).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>stretching</code></strong> :&ensp;<code>float</code></dt>
<dd>horizontal stretching (scaling) in percents.</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.set_subject"><code class="name flex">
<span>def <span class="ident">set_subject</span></span>(<span>self, subject)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L798-L805" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def set_subject(self, subject):
    &#34;&#34;&#34;
    Defines the subject of the document.

    Args:
        subject (str): the document main subject
    &#34;&#34;&#34;
    self.subject = subject</code></pre>
</details>
<div class="desc"><p>Defines the subject of the document.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>subject</code></strong> :&ensp;<code>str</code></dt>
<dd>the document main subject</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.set_text_color"><code class="name flex">
<span>def <span class="ident">set_text_color</span></span>(<span>self, r, g=-1, b=-1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L1236-L1249" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def set_text_color(self, r, g=-1, b=-1):
    &#34;&#34;&#34;
    Defines the color used for text.
    Accepts either a single greyscale value, 3 values as RGB components, a single `#abc` or `#abcdef` hexadecimal color string,
    or an instance of `fpdf.drawing.DeviceCMYK`, `fpdf.drawing.DeviceRGB` or `fpdf.drawing.DeviceGray`.
    The method can be called before the first page is created and the value is retained from page to page.

    Args:
        r (int, tuple, fpdf.drawing.DeviceGray, fpdf.drawing.DeviceRGB): if `g` and `b` are given, this indicates the red component.
            Else, this indicates the grey level. The value must be between 0 and 255.
        g (int): green component (between 0 and 255)
        b (int): blue component (between 0 and 255)
    &#34;&#34;&#34;
    self.text_color = convert_to_device_color(r, g, b)</code></pre>
</details>
<div class="desc"><p>Defines the color used for text.
Accepts either a single greyscale value, 3 values as RGB components, a single <code>#abc</code> or <code>#abcdef</code> hexadecimal color string,
or an instance of <code><a title="fpdf.drawing.DeviceCMYK" href="drawing.html#fpdf.drawing.DeviceCMYK">DeviceCMYK</a></code>, <code><a title="fpdf.drawing.DeviceRGB" href="drawing.html#fpdf.drawing.DeviceRGB">DeviceRGB</a></code> or <code><a title="fpdf.drawing.DeviceGray" href="drawing.html#fpdf.drawing.DeviceGray">DeviceGray</a></code>.
The method can be called before the first page is created and the value is retained from page to page.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>r</code></strong> :&ensp;<code>int, tuple, <a title="fpdf.drawing.DeviceGray" href="drawing.html#fpdf.drawing.DeviceGray">DeviceGray</a>, <a title="fpdf.drawing.DeviceRGB" href="drawing.html#fpdf.drawing.DeviceRGB">DeviceRGB</a></code></dt>
<dd>if <code>g</code> and <code>b</code> are given, this indicates the red component.
Else, this indicates the grey level. The value must be between 0 and 255.</dd>
<dt><strong><code>g</code></strong> :&ensp;<code>int</code></dt>
<dd>green component (between 0 and 255)</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>int</code></dt>
<dd>blue component (between 0 and 255)</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.set_text_shaping"><code class="name flex">
<span>def <span class="ident">set_text_shaping</span></span>(<span>self,<br>use_shaping_engine: bool = True,<br>features: dict = None,<br>direction: str | <a title="fpdf.enums.TextDirection" href="enums.html#fpdf.enums.TextDirection">TextDirection</a> = None,<br>script: str = None,<br>language: str = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L666-L743" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def set_text_shaping(
    self,
    use_shaping_engine: bool = True,
    features: dict = None,
    direction: Union[str, TextDirection] = None,
    script: str = None,
    language: str = None,
):
    &#34;&#34;&#34;
    Enable or disable text shaping engine when rendering text.
    If features, direction, script or language are not specified the shaping engine will try
    to guess the values based on the input text.

    Args:
        use_shaping_engine: enable or disable the use of the shaping engine to process the text
        features: a dictionary containing 4 digit OpenType features and whether each feature
            should be enabled or disabled
            example: features={&#34;kern&#34;: False, &#34;liga&#34;: False}
        direction: the direction the text should be rendered, either &#34;ltr&#34; (left to right)
            or &#34;rtl&#34; (right to left).
        script: a valid OpenType script tag like &#34;arab&#34; or &#34;latn&#34;
        language: a valid OpenType language tag like &#34;eng&#34; or &#34;fra&#34;
    &#34;&#34;&#34;
    if not use_shaping_engine:
        self.text_shaping = None
        return

    try:
        # pylint: disable=import-outside-toplevel, unused-import
        import uharfbuzz
    except ImportError as exc:
        raise FPDFException(
            &#34;The uharfbuzz package could not be imported, but is required for text shaping. Try: pip install uharfbuzz&#34;
        ) from exc

    #
    # Features must be a dictionary containing opentype features and a boolean flag
    # stating whether the feature should be enabled or disabled.
    #
    # e.g. features={&#34;liga&#34;: True, &#34;kern&#34;: False}
    #
    # https://harfbuzz.github.io/shaping-opentype-features.html
    #

    if features and not isinstance(features, dict):
        raise FPDFException(
            &#34;Features must be a dictionary. See text shaping documentation&#34;
        )
    if not features:
        features = {}

    # Buffer properties (direction, script and language)
    # if the properties are not provided, Harfbuzz &#34;guessing&#34; logic is used.
    # https://harfbuzz.github.io/setting-buffer-properties.html
    # Valid harfbuzz directions are ltr (left to right), rtl (right to left),
    # ttb (top to bottom) or btt (bottom to top)

    text_direction = None
    if direction:
        text_direction = (
            direction
            if isinstance(direction, TextDirection)
            else TextDirection.coerce(direction)
        )
        if text_direction not in [TextDirection.LTR, TextDirection.RTL]:
            raise FPDFException(
                &#34;FPDF2 only accept ltr (left to right) or rtl (right to left) directions for now.&#34;
            )

    self.text_shaping = {
        &#34;use_shaping_engine&#34;: True,
        &#34;features&#34;: features,
        &#34;direction&#34;: text_direction,
        &#34;script&#34;: script,
        &#34;language&#34;: language,
        &#34;fragment_direction&#34;: None,
        &#34;paragraph_direction&#34;: None,
    }</code></pre>
</details>
<div class="desc"><p>Enable or disable text shaping engine when rendering text.
If features, direction, script or language are not specified the shaping engine will try
to guess the values based on the input text.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>use_shaping_engine</code></strong></dt>
<dd>enable or disable the use of the shaping engine to process the text</dd>
<dt><strong><code>features</code></strong></dt>
<dd>a dictionary containing 4 digit OpenType features and whether each feature
should be enabled or disabled
example: features={"kern": False, "liga": False}</dd>
<dt><strong><code>direction</code></strong></dt>
<dd>the direction the text should be rendered, either "ltr" (left to right)
or "rtl" (right to left).</dd>
<dt><strong><code>script</code></strong></dt>
<dd>a valid OpenType script tag like "arab" or "latn"</dd>
<dt><strong><code>language</code></strong></dt>
<dd>a valid OpenType language tag like "eng" or "fra"</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.set_title"><code class="name flex">
<span>def <span class="ident">set_title</span></span>(<span>self, title)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L770-L782" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def set_title(self, title):
    &#34;&#34;&#34;
    Defines the title of the document.

    Most PDF readers will display it when viewing the document.
    There is also a related `fpdf.prefs.ViewerPreferences` entry:

        pdf.viewer_preferences = ViewerPreferences(display_doc_title=True)

    Args:
        title (str): the title
    &#34;&#34;&#34;
    self.title = title</code></pre>
</details>
<div class="desc"><p>Defines the title of the document.</p>
<p>Most PDF readers will display it when viewing the document.
There is also a related <code><a title="fpdf.prefs.ViewerPreferences" href="prefs.html#fpdf.prefs.ViewerPreferences">ViewerPreferences</a></code> entry:</p>
<pre><code>pdf.viewer_preferences = ViewerPreferences(display_doc_title=True)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code></dt>
<dd>the title</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.set_top_margin"><code class="name flex">
<span>def <span class="ident">set_top_margin</span></span>(<span>self, margin)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L587-L594" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def set_top_margin(self, margin):
    &#34;&#34;&#34;
    Sets the document top margin.

    Args:
        margin (float): margin in the unit specified to FPDF constructor
    &#34;&#34;&#34;
    self.t_margin = margin</code></pre>
</details>
<div class="desc"><p>Sets the document top margin.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>margin</code></strong> :&ensp;<code>float</code></dt>
<dd>margin in the unit specified to FPDF constructor</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.set_x"><code class="name flex">
<span>def <span class="ident">set_x</span></span>(<span>self, x)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L4845-L4853" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def set_x(self, x):
    &#34;&#34;&#34;
    Defines the abscissa of the current position.
    If the value provided is negative, it is relative to the right of the page.

    Args:
        x (float): the new current abscissa
    &#34;&#34;&#34;
    self.x = x if x &gt;= 0 else self.w + x</code></pre>
</details>
<div class="desc"><p>Defines the abscissa of the current position.
If the value provided is negative, it is relative to the right of the page.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>the new current abscissa</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.set_xmp_metadata"><code class="name flex">
<span>def <span class="ident">set_xmp_metadata</span></span>(<span>self, xmp_metadata)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L851-L858" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def set_xmp_metadata(self, xmp_metadata):
    if &#34;&lt;?xpacket&#34; in xmp_metadata[:50]:
        raise ValueError(
            &#34;fpdf2 already performs XMP metadata wrapping in a &lt;?xpacket&gt; tag&#34;
        )
    self.xmp_metadata = xmp_metadata
    if xmp_metadata:
        self._set_min_pdf_version(&#34;1.4&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fpdf.FPDF.set_xy"><code class="name flex">
<span>def <span class="ident">set_xy</span></span>(<span>self, x, y)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L4874-L4884" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def set_xy(self, x, y):
    &#34;&#34;&#34;
    Defines the abscissa and ordinate of the current position.
    If the values provided are negative, they are relative respectively to the right and bottom of the page.

    Args:
        x (float): the new current abscissa
        y (float): the new current ordinate
    &#34;&#34;&#34;
    self.set_y(y)
    self.set_x(x)</code></pre>
</details>
<div class="desc"><p>Defines the abscissa and ordinate of the current position.
If the values provided are negative, they are relative respectively to the right and bottom of the page.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>the new current abscissa</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>the new current ordinate</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.set_y"><code class="name flex">
<span>def <span class="ident">set_y</span></span>(<span>self, y)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L4863-L4872" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def set_y(self, y):
    &#34;&#34;&#34;
    Moves the current abscissa back to the left margin and sets the ordinate.
    If the value provided is negative, it is relative to the bottom of the page.

    Args:
        y (float): the new current ordinate
    &#34;&#34;&#34;
    self.x = self.l_margin
    self.y = y if y &gt;= 0 else self.h + y</code></pre>
</details>
<div class="desc"><p>Moves the current abscissa back to the left margin and sets the ordinate.
If the value provided is negative, it is relative to the bottom of the page.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>the new current ordinate</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.sign"><code class="name flex">
<span>def <span class="ident">sign</span></span>(<span>self,<br>key,<br>cert,<br>extra_certs=(),<br>hashalgo='sha256',<br>contact_info=None,<br>location=None,<br>signing_time=None,<br>reason=None,<br>flags=(&lt;AnnotationFlag.PRINT: 4&gt;, &lt;AnnotationFlag.LOCKED: 128&gt;))</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L4946-L5001" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@check_page
def sign(
    self,
    key,
    cert,
    extra_certs=(),
    hashalgo=&#34;sha256&#34;,
    contact_info=None,
    location=None,
    signing_time=None,
    reason=None,
    flags=(AnnotationFlag.PRINT, AnnotationFlag.LOCKED),
):
    &#34;&#34;&#34;
    Args:
        key: certificate private key
        cert (cryptography.x509.Certificate): certificate
        extra_certs (list[cryptography.x509.Certificate]): list of additional PKCS12 certificates
        hashalgo (str): hashing algorithm used, passed to `hashlib.new`
        contact_info (str): optional information provided by the signer to enable
            a recipient to contact the signer to verify the signature
        location (str): optional CPU host name or physical location of the signing
        signing_time (datetime): optional time of signing
        reason (str): optional signing reason
        flags (Tuple[fpdf.enums.AnnotationFlag], Tuple[str]): optional list of flags defining annotation properties
    &#34;&#34;&#34;
    if not signer:
        raise EnvironmentError(
            &#34;endesive.signer not available - PDF cannot be signed - Try: pip install endesive&#34;
        )
    if self._sign_key:
        raise FPDFException(&#34;.sign* methods should be called only once&#34;)

    self._sign_key = key
    self._sign_cert = cert
    self._sign_extra_certs = extra_certs
    self._sign_hashalgo = hashalgo
    self._sign_time = signing_time or self.creation_date

    annotation = PDFAnnotation(
        &#34;Widget&#34;,
        field_type=&#34;Sig&#34;,
        x=0,
        y=0,
        width=0,
        height=0,
        flags=flags,
        title=&#34;signature&#34;,
        value=Signature(
            contact_info=contact_info,
            location=location,
            m=PDFDate(self._sign_time),
            reason=reason,
        ),
    )
    self.pages[self.page].annots.append(annotation)</code></pre>
</details>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>key</code></strong></dt>
<dd>certificate private key</dd>
<dt><strong><code>cert</code></strong> :&ensp;<code>cryptography.x509.Certificate</code></dt>
<dd>certificate</dd>
<dt><strong><code>extra_certs</code></strong> :&ensp;<code>list[cryptography.x509.Certificate]</code></dt>
<dd>list of additional PKCS12 certificates</dd>
<dt><strong><code>hashalgo</code></strong> :&ensp;<code>str</code></dt>
<dd>hashing algorithm used, passed to <code>hashlib.new</code></dd>
<dt><strong><code>contact_info</code></strong> :&ensp;<code>str</code></dt>
<dd>optional information provided by the signer to enable
a recipient to contact the signer to verify the signature</dd>
<dt><strong><code>location</code></strong> :&ensp;<code>str</code></dt>
<dd>optional CPU host name or physical location of the signing</dd>
<dt><strong><code>signing_time</code></strong> :&ensp;<code>datetime</code></dt>
<dd>optional time of signing</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code>str</code></dt>
<dd>optional signing reason</dd>
<dt><strong><code>flags</code></strong> :&ensp;<code>Tuple[<a title="fpdf.enums.AnnotationFlag" href="enums.html#fpdf.enums.AnnotationFlag">AnnotationFlag</a>], Tuple[str]</code></dt>
<dd>optional list of flags defining annotation properties</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.sign_pkcs12"><code class="name flex">
<span>def <span class="ident">sign_pkcs12</span></span>(<span>self,<br>pkcs_filepath,<br>password=None,<br>hashalgo='sha256',<br>contact_info=None,<br>location=None,<br>signing_time=None,<br>reason=None,<br>flags=(&lt;AnnotationFlag.PRINT: 4&gt;, &lt;AnnotationFlag.LOCKED: 128&gt;))</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L4901-L4944" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def sign_pkcs12(
    self,
    pkcs_filepath,
    password=None,
    hashalgo=&#34;sha256&#34;,
    contact_info=None,
    location=None,
    signing_time=None,
    reason=None,
    flags=(AnnotationFlag.PRINT, AnnotationFlag.LOCKED),
):
    &#34;&#34;&#34;
    Args:
        pkcs_filepath (str): file path to a .pfx or .p12 PKCS12,
            in the binary format described by RFC 7292
        password (bytes-like): the password to use to decrypt the data.
            `None` if the PKCS12 is not encrypted.
        hashalgo (str): hashing algorithm used, passed to `hashlib.new`
        contact_info (str): optional information provided by the signer to enable
            a recipient to contact the signer to verify the signature
        location (str): optional CPU host name or physical location of the signing
        signing_time (datetime): optional time of signing
        reason (str): optional signing reason
        flags (Tuple[fpdf.enums.AnnotationFlag], Tuple[str]): optional list of flags defining annotation properties
    &#34;&#34;&#34;
    if not signer:
        raise EnvironmentError(
            &#34;endesive.signer not available - PDF cannot be signed - Try: pip install endesive&#34;
        )
    with open(pkcs_filepath, &#34;rb&#34;) as pkcs_file:
        key, cert, extra_certs = pkcs12.load_key_and_certificates(
            pkcs_file.read(), password
        )
    self.sign(
        key=key,
        cert=cert,
        extra_certs=extra_certs,
        hashalgo=hashalgo,
        contact_info=contact_info,
        location=location,
        signing_time=signing_time,
        reason=reason,
        flags=flags,
    )</code></pre>
</details>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>pkcs_filepath</code></strong> :&ensp;<code>str</code></dt>
<dd>file path to a .pfx or .p12 PKCS12,
in the binary format described by RFC 7292</dd>
<dt><strong><code>password</code></strong> :&ensp;<code>bytes-like</code></dt>
<dd>the password to use to decrypt the data.
<code>None</code> if the PKCS12 is not encrypted.</dd>
<dt><strong><code>hashalgo</code></strong> :&ensp;<code>str</code></dt>
<dd>hashing algorithm used, passed to <code>hashlib.new</code></dd>
<dt><strong><code>contact_info</code></strong> :&ensp;<code>str</code></dt>
<dd>optional information provided by the signer to enable
a recipient to contact the signer to verify the signature</dd>
<dt><strong><code>location</code></strong> :&ensp;<code>str</code></dt>
<dd>optional CPU host name or physical location of the signing</dd>
<dt><strong><code>signing_time</code></strong> :&ensp;<code>datetime</code></dt>
<dd>optional time of signing</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code>str</code></dt>
<dd>optional signing reason</dd>
<dt><strong><code>flags</code></strong> :&ensp;<code>Tuple[<a title="fpdf.enums.AnnotationFlag" href="enums.html#fpdf.enums.AnnotationFlag">AnnotationFlag</a>], Tuple[str]</code></dt>
<dd>optional list of flags defining annotation properties</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.skew"><code class="name flex">
<span>def <span class="ident">skew</span></span>(<span>self, ax=0, ay=0, x=None, y=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L2895-L2927" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@check_page
@contextmanager
def skew(self, ax=0, ay=0, x=None, y=None):
    &#34;&#34;&#34;
    Method to perform a skew transformation originating from a given center.
    It must be used as a context-manager using `with`:

        with skew(ax=15, ay=15, x=x, y=y):
            pdf.something()

    The skew transformation affects all elements which are printed inside the indented
    context (with the exception of clickable areas).

    Args:
        ax (float): angle of skew in the horizontal direction in degrees
        ay (float): angle of skew in the vertical direction in degrees
        x (float): abscissa of the center of the skew transformation
        y (float): ordinate of the center of the skew transformation
    &#34;&#34;&#34;
    lim_val = 2**32
    if x is None:
        x = self.x
    if y is None:
        y = self.y
    ax = max(min(math.tan(ax * (math.pi / 180)), lim_val), -lim_val)
    ay = max(min(math.tan(ay * (math.pi / 180)), lim_val), -lim_val)
    cx, cy = x * self.k, (self.h - y) * self.k
    with self.local_context():
        self._out(
            f&#34;1 {ay:.5f} {ax:.5f} 1 {cx:.2f} {cy:.2f} cm &#34;
            f&#34;1 0 0 1 -{cx:.2f} -{cy:.2f} cm&#34;
        )
        yield</code></pre>
</details>
<div class="desc"><p>Method to perform a skew transformation originating from a given center.
It must be used as a context-manager using <code>with</code>:</p>
<pre><code>with skew(ax=15, ay=15, x=x, y=y):
    pdf.something()
</code></pre>
<p>The skew transformation affects all elements which are printed inside the indented
context (with the exception of clickable areas).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>float</code></dt>
<dd>angle of skew in the horizontal direction in degrees</dd>
<dt><strong><code>ay</code></strong> :&ensp;<code>float</code></dt>
<dd>angle of skew in the vertical direction in degrees</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>abscissa of the center of the skew transformation</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>ordinate of the center of the skew transformation</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.solid_arc"><code class="name flex">
<span>def <span class="ident">solid_arc</span></span>(<span>self, x, y, a, start_angle, end_angle, b=None, inclination=0, clockwise=False, style=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L1986-L2029" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def solid_arc(
    self,
    x,
    y,
    a,
    start_angle,
    end_angle,
    b=None,
    inclination=0,
    clockwise=False,
    style=None,
):
    &#34;&#34;&#34;
    Outputs a solid arc. A solid arc combines an arc and a triangle to form a pie slice
    It can be drawn (border only), filled (with no border) or both.

    Args:
        x (float): Abscissa of upper-left bounding box.
        y (float): Ordinate of upper-left bounding box.
        a (float): Semi-major axis.
        b (float): Semi-minor axis, if None, equals to a (default: None).
        start_angle (float): Start angle of the arc (in degrees).
        end_angle (float): End angle of the arc (in degrees).
        inclination (float): Inclination of the arc in respect of the x-axis (default: 0).
        clockwise (bool): Way of drawing the arc (True: clockwise, False: counterclockwise) (default: False).
        style (str): Style of rendering. Possible values are:

        * `D` or None: draw border. This is the default value.
        * `F`: fill
        * `DF` or `FD`: draw and fill
    &#34;&#34;&#34;
    self.arc(
        x,
        y,
        a,
        start_angle,
        end_angle,
        b,
        inclination,
        clockwise,
        True,
        True,
        style,
    )</code></pre>
</details>
<div class="desc"><p>Outputs a solid arc. A solid arc combines an arc and a triangle to form a pie slice
It can be drawn (border only), filled (with no border) or both.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>Abscissa of upper-left bounding box.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>Ordinate of upper-left bounding box.</dd>
<dt><strong><code>a</code></strong> :&ensp;<code>float</code></dt>
<dd>Semi-major axis.</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>float</code></dt>
<dd>Semi-minor axis, if None, equals to a (default: None).</dd>
<dt><strong><code>start_angle</code></strong> :&ensp;<code>float</code></dt>
<dd>Start angle of the arc (in degrees).</dd>
<dt><strong><code>end_angle</code></strong> :&ensp;<code>float</code></dt>
<dd>End angle of the arc (in degrees).</dd>
<dt><strong><code>inclination</code></strong> :&ensp;<code>float</code></dt>
<dd>Inclination of the arc in respect of the x-axis (default: 0).</dd>
<dt><strong><code>clockwise</code></strong> :&ensp;<code>bool</code></dt>
<dd>Way of drawing the arc (True: clockwise, False: counterclockwise) (default: False).</dd>
<dt><strong><code>style</code></strong> :&ensp;<code>str</code></dt>
<dd>Style of rendering. Possible values are:</dd>
</dl>
<ul>
<li><code>D</code> or None: draw border. This is the default value.</li>
<li><code>F</code>: fill</li>
<li><code>DF</code> or <code>FD</code>: draw and fill</li>
</ul></div>
</dd>
<dt id="fpdf.fpdf.FPDF.star"><code class="name flex">
<span>def <span class="ident">star</span></span>(<span>self, x, y, r_in, r_out, corners, rotate_degrees=0, style=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L1806-L1835" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@check_page
def star(self, x, y, r_in, r_out, corners, rotate_degrees=0, style=None):
    &#34;&#34;&#34;
    Outputs a regular star with n corners.
    It can be rotated.
    It can be drawn (border only), filled (with no border) or both.

    Args:
        x (float): Abscissa of star&#39;s centre.
        y (float): Ordinate of star&#39;s centre.
        r_in (float): radius of internal circle.
        r_out (float): radius of external circle.
        corners (int): number of star&#39;s corners.
        rotate_degrees (float): Optional degree amount to rotate star clockwise.

        style (fpdf.enums.RenderStyle, str): Optional style of rendering. Possible values are:
        * `D`: draw border. This is the default value.
        * `F`: fill.
        * `DF` or `FD`: draw and fill.
    &#34;&#34;&#34;
    th = math.radians(rotate_degrees)
    point_list = []
    for i in range(0, (corners * 2) + 1):
        corner_x = x + (r_out if i % 2 == 0 else r_in) * math.sin(th)
        corner_y = y + (r_out if i % 2 == 0 else r_in) * math.cos(th)
        point_list.append((corner_x, corner_y))

        th += math.radians(180 / corners)

    self.polyline(point_list, polygon=True, style=style)</code></pre>
</details>
<div class="desc"><p>Outputs a regular star with n corners.
It can be rotated.
It can be drawn (border only), filled (with no border) or both.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>Abscissa of star's centre.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>Ordinate of star's centre.</dd>
<dt><strong><code>r_in</code></strong> :&ensp;<code>float</code></dt>
<dd>radius of internal circle.</dd>
<dt><strong><code>r_out</code></strong> :&ensp;<code>float</code></dt>
<dd>radius of external circle.</dd>
<dt><strong><code>corners</code></strong> :&ensp;<code>int</code></dt>
<dd>number of star's corners.</dd>
<dt><strong><code>rotate_degrees</code></strong> :&ensp;<code>float</code></dt>
<dd>Optional degree amount to rotate star clockwise.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.enums.RenderStyle" href="enums.html#fpdf.enums.RenderStyle">RenderStyle</a>, str</code></dt>
<dd>Optional style of rendering. Possible values are:</dd>
</dl>
<ul>
<li><code>D</code>: draw border. This is the default value.</li>
<li><code>F</code>: fill.</li>
<li><code>DF</code> or <code>FD</code>: draw and fill.</li>
</ul></div>
</dd>
<dt id="fpdf.fpdf.FPDF.start_section"><code class="name flex">
<span>def <span class="ident">start_section</span></span>(<span>self, name, level=0, strict=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L5444-L5513" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@check_page
def start_section(self, name, level=0, strict=True):
    &#34;&#34;&#34;
    Start a section in the document outline.
    If section_title_styles have been configured,
    render the section name visually as a title.

    Args:
        name (str): section name
        level (int): section level in the document outline. 0 means top-level.
        strict (bool): whether to raise an exception if levels increase incorrectly,
            for example with a level-3 section following a level-1 section.
    &#34;&#34;&#34;
    if level &lt; 0:
        raise ValueError(&#39;&#34;level&#34; mut be equal or greater than zero&#39;)
    if strict and self._outline and level &gt; self._outline[-1].level + 1:
        raise ValueError(
            f&#34;Incoherent hierarchy: cannot start a level {level} section after a level {self._outline[-1].level} one&#34;
        )
    dest = DestinationXYZ(self.page, top=self.h_pt - self.y * self.k)
    outline_struct_elem = None
    if self.section_title_styles:
        text_style = self.section_title_styles[level]
        # We first check if adding this multi-cell will trigger a page break:
        if text_style.size_pt is not None:
            prev_font_size_pt = self.font_size_pt
            self.font_size_pt = text_style.size_pt
        # check if l_margin value is of type Align or string
        align = Align.L
        if isinstance(text_style.l_margin, (Align, str)):
            align = Align.coerce(text_style.l_margin)
        page_break_triggered = self.multi_cell(
            w=self.epw,
            h=self.font_size,
            text=name,
            new_x=XPos.LMARGIN,
            new_y=YPos.NEXT,
            dry_run=True,  # =&gt; does not produce any output
            output=MethodReturnValue.PAGE_BREAK,
            align=align,
            padding=Padding(
                top=text_style.t_margin or 0,
                left=(
                    text_style.l_margin
                    if isinstance(text_style.l_margin, (int, float))
                    else 0
                ),
                bottom=text_style.b_margin or 0,
            ),
        )
        if text_style.size_pt is not None:
            self.font_size_pt = prev_font_size_pt
        if page_break_triggered:
            # If so, we trigger a page break manually beforehand:
            self.add_page()
        with self._marked_sequence(title=name) as struct_elem:
            outline_struct_elem = struct_elem
            with self.use_text_style(text_style):
                self.multi_cell(
                    w=self.epw,
                    h=self.font_size,
                    text=name,
                    align=align,
                    new_x=XPos.LMARGIN,
                    new_y=YPos.NEXT,
                    center=text_style.l_margin == Align.C,
                )
    self._outline.append(
        OutlineSection(name, level, self.page, dest, outline_struct_elem)
    )</code></pre>
</details>
<div class="desc"><p>Start a section in the document outline.
If section_title_styles have been configured,
render the section name visually as a title.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>section name</dd>
<dt><strong><code>level</code></strong> :&ensp;<code>int</code></dt>
<dd>section level in the document outline. 0 means top-level.</dd>
<dt><strong><code>strict</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether to raise an exception if levels increase incorrectly,
for example with a level-3 section following a level-1 section.</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.table"><code class="name flex">
<span>def <span class="ident">table</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L5578-L5621" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@check_page
@contextmanager
def table(self, *args, **kwargs):
    &#34;&#34;&#34;
    Inserts a table, that can be built using the `fpdf.table.Table` object yield.
    Detailed usage documentation: https://py-pdf.github.io/fpdf2/Tables.html

    Args:
        rows: optional. Sequence of rows (iterable) of str to initiate the table cells with text content.
        align (str, fpdf.enums.Align): optional, default to CENTER. Sets the table horizontal position
            relative to the page, when it&#39;s not using the full page width.
        borders_layout (str, fpdf.enums.TableBordersLayout): optional, default to ALL. Control what cell
            borders are drawn.
        cell_fill_color (int, tuple, fpdf.drawing.DeviceCMYK, fpdf.drawing.DeviceGray, fpdf.drawing.DeviceRGB): optional.
            Defines the cells background color.
        cell_fill_mode (str, fpdf.enums.TableCellFillMode): optional. Defines which cells are filled
            with color in the background.
        col_widths (int, tuple): optional. Sets column width. Can be a single number or a sequence of numbers.
        first_row_as_headings (bool): optional, default to True. If False, the first row of the table
            is not styled differently from the others.
        gutter_height (float): optional vertical space between rows.
        gutter_width (float): optional horizontal space between columns.
        headings_style (fpdf.fonts.FontFace): optional, default to bold.
            Defines the visual style of the top headings row: size, color, emphasis...
        line_height (number): optional. Defines how much vertical space a line of text will occupy.
        markdown (bool): optional, default to False. Enable markdown interpretation of cells textual content.
        text_align (str, fpdf.enums.Align): optional, default to JUSTIFY. Control text alignment inside cells.
        v_align (str, fpdf.enums.VAlign): optional, default to CENTER. Control vertical alignment of cells content.
        width (number): optional. Sets the table width.
        wrapmode (fpdf.enums.WrapMode): &#34;WORD&#34; for word based line wrapping (default),
            &#34;CHAR&#34; for character based line wrapping.
        padding (number, tuple, Padding): optional. Sets the cell padding. Can be a single number or a sequence
            of numbers, default:0
            If padding for left or right ends up being non-zero then the respective c_margin is ignored.
        outer_border_width (number): optional. The outer_border_width will trigger rendering of the outer
            border of the table with the given width regardless of any other defined border styles.
        num_heading_rows (number): optional. Sets the number of heading rows, default value is 1. If this value is not 1,
            first_row_as_headings needs to be True if num_heading_rows&gt;1 and False if num_heading_rows=0. For backwards compatibility,
            first_row_as_headings is used in case num_heading_rows is 1.
        repeat_headings (fpdf.enums.TableHeadingsDisplay): optional, indicates whether to print table headings on every page, default to 1.
    &#34;&#34;&#34;
    table = Table(self, *args, **kwargs)
    yield table
    table.render()</code></pre>
</details>
<div class="desc"><p>Inserts a table, that can be built using the <code><a title="fpdf.table.Table" href="table.html#fpdf.table.Table">Table</a></code> object yield.
Detailed usage documentation: <a href="https://py-pdf.github.io/fpdf2/Tables.html">https://py-pdf.github.io/fpdf2/Tables.html</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rows</code></strong></dt>
<dd>optional. Sequence of rows (iterable) of str to initiate the table cells with text content.</dd>
<dt><strong><code>align</code></strong> :&ensp;<code>str, <a title="fpdf.enums.Align" href="enums.html#fpdf.enums.Align">Align</a></code></dt>
<dd>optional, default to CENTER. Sets the table horizontal position
relative to the page, when it's not using the full page width.</dd>
<dt><strong><code>borders_layout</code></strong> :&ensp;<code>str, <a title="fpdf.enums.TableBordersLayout" href="enums.html#fpdf.enums.TableBordersLayout">TableBordersLayout</a></code></dt>
<dd>optional, default to ALL. Control what cell
borders are drawn.</dd>
<dt><strong><code>cell_fill_color</code></strong> :&ensp;<code>int, tuple, <a title="fpdf.drawing.DeviceCMYK" href="drawing.html#fpdf.drawing.DeviceCMYK">DeviceCMYK</a>, <a title="fpdf.drawing.DeviceGray" href="drawing.html#fpdf.drawing.DeviceGray">DeviceGray</a>, <a title="fpdf.drawing.DeviceRGB" href="drawing.html#fpdf.drawing.DeviceRGB">DeviceRGB</a></code></dt>
<dd>optional.
Defines the cells background color.</dd>
<dt><strong><code>cell_fill_mode</code></strong> :&ensp;<code>str, <a title="fpdf.enums.TableCellFillMode" href="enums.html#fpdf.enums.TableCellFillMode">TableCellFillMode</a></code></dt>
<dd>optional. Defines which cells are filled
with color in the background.</dd>
<dt><strong><code>col_widths</code></strong> :&ensp;<code>int, tuple</code></dt>
<dd>optional. Sets column width. Can be a single number or a sequence of numbers.</dd>
<dt><strong><code>first_row_as_headings</code></strong> :&ensp;<code>bool</code></dt>
<dd>optional, default to True. If False, the first row of the table
is not styled differently from the others.</dd>
<dt><strong><code>gutter_height</code></strong> :&ensp;<code>float</code></dt>
<dd>optional vertical space between rows.</dd>
<dt><strong><code>gutter_width</code></strong> :&ensp;<code>float</code></dt>
<dd>optional horizontal space between columns.</dd>
<dt><strong><code>headings_style</code></strong> :&ensp;<code><a title="fpdf.fonts.FontFace" href="fonts.html#fpdf.fonts.FontFace">FontFace</a></code></dt>
<dd>optional, default to bold.
Defines the visual style of the top headings row: size, color, emphasis&hellip;</dd>
<dt><strong><code>line_height</code></strong> :&ensp;<code>number</code></dt>
<dd>optional. Defines how much vertical space a line of text will occupy.</dd>
<dt><strong><code>markdown</code></strong> :&ensp;<code>bool</code></dt>
<dd>optional, default to False. Enable markdown interpretation of cells textual content.</dd>
<dt><strong><code>text_align</code></strong> :&ensp;<code>str, <a title="fpdf.enums.Align" href="enums.html#fpdf.enums.Align">Align</a></code></dt>
<dd>optional, default to JUSTIFY. Control text alignment inside cells.</dd>
<dt><strong><code>v_align</code></strong> :&ensp;<code>str, <a title="fpdf.enums.VAlign" href="enums.html#fpdf.enums.VAlign">VAlign</a></code></dt>
<dd>optional, default to CENTER. Control vertical alignment of cells content.</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>number</code></dt>
<dd>optional. Sets the table width.</dd>
<dt><strong><code>wrapmode</code></strong> :&ensp;<code><a title="fpdf.enums.WrapMode" href="enums.html#fpdf.enums.WrapMode">WrapMode</a></code></dt>
<dd>"WORD" for word based line wrapping (default),
"CHAR" for character based line wrapping.</dd>
<dt><strong><code>padding</code></strong> :&ensp;<code>number, tuple, Padding</code></dt>
<dd>optional. Sets the cell padding. Can be a single number or a sequence
of numbers, default:0
If padding for left or right ends up being non-zero then the respective c_margin is ignored.</dd>
<dt><strong><code>outer_border_width</code></strong> :&ensp;<code>number</code></dt>
<dd>optional. The outer_border_width will trigger rendering of the outer
border of the table with the given width regardless of any other defined border styles.</dd>
<dt><strong><code>num_heading_rows</code></strong> :&ensp;<code>number</code></dt>
<dd>optional. Sets the number of heading rows, default value is 1. If this value is not 1,
first_row_as_headings needs to be True if num_heading_rows&gt;1 and False if num_heading_rows=0. For backwards compatibility,
first_row_as_headings is used in case num_heading_rows is 1.</dd>
<dt><strong><code>repeat_headings</code></strong> :&ensp;<code><a title="fpdf.enums.TableHeadingsDisplay" href="enums.html#fpdf.enums.TableHeadingsDisplay">TableHeadingsDisplay</a></code></dt>
<dd>optional, indicates whether to print table headings on every page, default to 1.</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.text"><code class="name flex">
<span>def <span class="ident">text</span></span>(<span>self, x, y, text='')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L2770-L2817" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@check_page
@support_deprecated_txt_arg
def text(self, x, y, text=&#34;&#34;):
    &#34;&#34;&#34;
    Prints a character string. The origin is on the left of the first character,
    on the baseline. This method allows placing a string precisely on the page,
    but it is usually easier to use the `FPDF.cell()`, `FPDF.multi_cell() or `FPDF.write()` methods.

    Args:
        x (float): abscissa of the origin
        y (float): ordinate of the origin
        text (str): string to print
        txt (str): [**DEPRECATED since v2.7.6**] string to print

    Notes
    -----

    `text()` lacks many of the features available in `FPDF.write()`,
    `FPDF.cell()` and `FPDF.multi_cell()` like markdown and text shaping.
    &#34;&#34;&#34;
    if not self.font_family:
        raise FPDFException(&#34;No font set, you need to call set_font() beforehand&#34;)
    text = self.normalize_text(text)
    if not self.current_font_is_set_on_page:
        self._out(self._set_font_for_page(self.current_font, self.font_size_pt))
    sl = [f&#34;BT {x * self.k:.2f} {(self.h - y) * self.k:.2f} Td&#34;]
    if self.text_mode != TextMode.FILL:
        sl.append(f&#34; {self.text_mode} Tr {self.line_width:.2f} w&#34;)
    sl.append(f&#34;{self.current_font.encode_text(text)} ET&#34;)
    if (
        text != &#34;&#34; and (self.underline or self.strikethrough)
    ) or self._record_text_quad_points:
        w = self.get_string_width(text, normalized=True, markdown=False)
        if text != &#34;&#34;:
            if self.underline:
                sl.append(self._do_underline(x, y, w))
            if self.strikethrough:
                sl.append(self._do_strikethrough(x, y, w))
        if self._record_text_quad_points:
            h = self.font_size
            y -= 0.8 * h  # same coefficient as in _render_styled_text_line()
            self._add_quad_points(x, y, w, h)
    attr_l = []
    if self.fill_color != self.text_color:
        attr_l.append(f&#34;{self.text_color.serialize().lower()}&#34;)
    if attr_l:
        sl = [&#34;q&#34;] + attr_l + sl + [&#34;Q&#34;]
    self._out(&#34; &#34;.join(sl))</code></pre>
</details>
<div class="desc"><p>Prints a character string. The origin is on the left of the first character,
on the baseline. This method allows placing a string precisely on the page,
but it is usually easier to use the <code><a title="fpdf.fpdf.FPDF.cell" href="#fpdf.fpdf.FPDF.cell">FPDF.cell()</a></code>, <code><a title="fpdf.fpdf.FPDF.multi_cell" href="#fpdf.fpdf.FPDF.multi_cell">FPDF.multi_cell()</a> or </code>FPDF.write()` methods.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>abscissa of the origin</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>ordinate of the origin</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>string to print</dd>
<dt><strong><code>txt</code></strong> :&ensp;<code>str</code></dt>
<dd>[<strong>DEPRECATED since v2.7.6</strong>] string to print</dd>
</dl>
<h2 id="notes">Notes</h2>
<p><code>text()</code> lacks many of the features available in <code><a title="fpdf.fpdf.FPDF.write" href="#fpdf.fpdf.FPDF.write">FPDF.write()</a></code>,
<code><a title="fpdf.fpdf.FPDF.cell" href="#fpdf.fpdf.FPDF.cell">FPDF.cell()</a></code> and <code><a title="fpdf.fpdf.FPDF.multi_cell" href="#fpdf.fpdf.FPDF.multi_cell">FPDF.multi_cell()</a></code> like markdown and text shaping.</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.text_annotation"><code class="name flex">
<span>def <span class="ident">text_annotation</span></span>(<span>self, x, y, text, w=1, h=1, name=None, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L2532-L2559" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@check_page
def text_annotation(self, x, y, text, w=1, h=1, name=None, **kwargs):
    &#34;&#34;&#34;
    Puts a text annotation on a rectangular area of the page.

    Args:
        x (float): horizontal position (from the left) to the left side of the link rectangle
        y (float): vertical position (from the top) to the bottom side of the link rectangle
        text (str): text to display
        w (float): optional width of the link rectangle
        h (float): optional height of the link rectangle
        name (fpdf.enums.AnnotationName, str): optional icon that shall be used in displaying the annotation
        flags (Tuple[fpdf.enums.AnnotationFlag], Tuple[str]): optional list of flags defining annotation properties
        title (str): the text label that shall be displayed in the title bar of the annotation’s
            pop-up window when open and active. This entry shall identify the user who added the annotation.
    &#34;&#34;&#34;
    annotation = AnnotationDict(
        &#34;Text&#34;,
        x * self.k,
        self.h_pt - y * self.k,
        w * self.k,
        h * self.k,
        contents=text,
        name=AnnotationName.coerce(name) if name else None,
        **kwargs,
    )
    self.pages[self.page].annots.append(annotation)
    return annotation</code></pre>
</details>
<div class="desc"><p>Puts a text annotation on a rectangular area of the page.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>horizontal position (from the left) to the left side of the link rectangle</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>vertical position (from the top) to the bottom side of the link rectangle</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>text to display</dd>
<dt><strong><code>w</code></strong> :&ensp;<code>float</code></dt>
<dd>optional width of the link rectangle</dd>
<dt><strong><code>h</code></strong> :&ensp;<code>float</code></dt>
<dd>optional height of the link rectangle</dd>
<dt><strong><code>name</code></strong> :&ensp;<code><a title="fpdf.enums.AnnotationName" href="enums.html#fpdf.enums.AnnotationName">AnnotationName</a>, str</code></dt>
<dd>optional icon that shall be used in displaying the annotation</dd>
<dt><strong><code>flags</code></strong> :&ensp;<code>Tuple[<a title="fpdf.enums.AnnotationFlag" href="enums.html#fpdf.enums.AnnotationFlag">AnnotationFlag</a>], Tuple[str]</code></dt>
<dd>optional list of flags defining annotation properties</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code></dt>
<dd>the text label that shall be displayed in the title bar of the annotation’s
pop-up window when open and active. This entry shall identify the user who added the annotation.</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.text_columns"><code class="name flex">
<span>def <span class="ident">text_columns</span></span>(<span>self,<br>text: str | None = None,<br>img: str | None = None,<br>img_fill_width: bool = False,<br>ncols: int = 1,<br>gutter: float = 10,<br>balance: bool = False,<br>text_align: <a title="fpdf.enums.Align" href="enums.html#fpdf.enums.Align">Align</a> | str = 'LEFT',<br>line_height: float = 1,<br>l_margin: float = None,<br>r_margin: float = None,<br>print_sh: bool = False,<br>wrapmode: <a title="fpdf.enums.WrapMode" href="enums.html#fpdf.enums.WrapMode">WrapMode</a> = WrapMode.WORD,<br>skip_leading_spaces: bool = False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L4393-L4445" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@check_page
def text_columns(
    self,
    text: Optional[str] = None,
    img: Optional[str] = None,
    img_fill_width: bool = False,
    ncols: int = 1,
    gutter: float = 10,
    balance: bool = False,
    text_align: Union[Align, str] = &#34;LEFT&#34;,
    line_height: float = 1,
    l_margin: float = None,
    r_margin: float = None,
    print_sh: bool = False,
    wrapmode: WrapMode = WrapMode.WORD,
    skip_leading_spaces: bool = False,
):
    &#34;&#34;&#34;Establish a layout with multiple columns to fill with text.
    Args:
        text (str, optional): A first piece of text to insert.
        ncols (int, optional): the number of columns to create. (Default: 1).
        gutter (float, optional): The distance between the columns. (Default: 10).
        balance: (bool, optional): Specify whether multiple columns should end at approximately
            the same height, if they don&#39;t fill the page. (Default: False)
        text_align (Align or str, optional): The alignment of the text within the region.
            (Default: &#34;LEFT&#34;)
        line_height (float, optional): A multiplier relative to the font size changing the
            vertical space occupied by a line of text. (Default: 1.0).
        l_margin (float, optional): Override the current left page margin.
        r_margin (float, optional): Override the current right page margin.
        print_sh (bool, optional): Treat a soft-hyphen (\\u00ad) as a printable character,
            instead of a line breaking opportunity. (Default: False)
        wrapmode (fpdf.enums.WrapMode, optional): &#34;WORD&#34; for word based line wrapping,
            &#34;CHAR&#34; for character based line wrapping. (Default: &#34;WORD&#34;)
        skip_leading_spaces (bool, optional): On each line, any space characters at the
            beginning will be skipped if True. (Default: False)
    &#34;&#34;&#34;
    return TextColumns(
        self,
        text=text,
        img=img,
        img_fill_width=img_fill_width,
        ncols=ncols,
        gutter=gutter,
        balance=balance,
        text_align=text_align,
        line_height=line_height,
        l_margin=l_margin,
        r_margin=r_margin,
        print_sh=print_sh,
        wrapmode=wrapmode,
        skip_leading_spaces=skip_leading_spaces,
    )</code></pre>
</details>
<div class="desc"><p>Establish a layout with multiple columns to fill with text.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A first piece of text to insert.</dd>
<dt><strong><code>ncols</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>the number of columns to create. (Default: 1).</dd>
<dt><strong><code>gutter</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The distance between the columns. (Default: 10).</dd>
<dt><strong><code>balance</code></strong></dt>
<dd>(bool, optional): Specify whether multiple columns should end at approximately
the same height, if they don't fill the page. (Default: False)</dd>
<dt><strong><code>text_align</code></strong> :&ensp;<code>Align</code> or <code>str</code>, optional</dt>
<dd>The alignment of the text within the region.
(Default: "LEFT")</dd>
<dt><strong><code>line_height</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>A multiplier relative to the font size changing the
vertical space occupied by a line of text. (Default: 1.0).</dd>
<dt><strong><code>l_margin</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Override the current left page margin.</dd>
<dt><strong><code>r_margin</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Override the current right page margin.</dd>
<dt><strong><code>print_sh</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Treat a soft-hyphen (\u00ad) as a printable character,
instead of a line breaking opportunity. (Default: False)</dd>
<dt><strong><code>wrapmode</code></strong> :&ensp;<code><a title="fpdf.enums.WrapMode" href="enums.html#fpdf.enums.WrapMode">WrapMode</a></code>, optional</dt>
<dd>"WORD" for word based line wrapping,
"CHAR" for character based line wrapping. (Default: "WORD")</dd>
<dt><strong><code>skip_leading_spaces</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>On each line, any space characters at the
beginning will be skipped if True. (Default: False)</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.unbreakable"><code class="name flex">
<span>def <span class="ident">unbreakable</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L5309-L5337" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@contextmanager
def unbreakable(self):
    &#34;&#34;&#34;
    Ensures that all rendering performed in this context appear on a single page
    by performing page break beforehand if need be.

    Notes
    -----

    Using this method means to duplicate the FPDF `bytearray` buffer:
    when generating large PDFs, doubling memory usage may be troublesome.
    &#34;&#34;&#34;
    prev_page, prev_y = self.page, self.y
    recorder = FPDFRecorder(self, accept_page_break=False)
    recorder.page_break_triggered = False
    self._in_unbreakable = True
    LOGGER.debug(&#34;Starting unbreakable block&#34;)
    yield recorder
    y_scroll = recorder.y - prev_y + (recorder.page - prev_page) * self.eph
    if prev_y + y_scroll &gt; self.page_break_trigger or recorder.page &gt; prev_page:
        LOGGER.debug(&#34;Performing page jump due to unbreakable height&#34;)
        recorder.rewind()
        # pylint: disable=protected-access
        # Performing this call through .pdf so that it does not get recorded &amp; replayed:
        recorder.pdf._perform_page_break()
        recorder.replay()
        recorder.page_break_triggered = True
    self._in_unbreakable = False
    LOGGER.debug(&#34;Ending unbreakable block&#34;)</code></pre>
</details>
<div class="desc"><p>Ensures that all rendering performed in this context appear on a single page
by performing page break beforehand if need be.</p>
<h2 id="notes">Notes</h2>
<p>Using this method means to duplicate the FPDF <code>bytearray</code> buffer:
when generating large PDFs, doubling memory usage may be troublesome.</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.use_font_face"><code class="name flex">
<span>def <span class="ident">use_font_face</span></span>(<span>self,<br>font_face: <a title="fpdf.fonts.FontFace" href="fonts.html#fpdf.fonts.FontFace">FontFace</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L5539-L5576" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@contextmanager
def use_font_face(self, font_face: FontFace):
    &#34;&#34;&#34;
    Sets the provided `fpdf.fonts.FontFace` in a local context,
    then restore font settings back to they were initially.
    This method must be used as a context manager using `with`:

        with pdf.use_font_face(FontFace(emphasis=&#34;BOLD&#34;, color=255, size_pt=42)):
            put_some_text()

    Known limitation: in case of a page jump in this local context,
    the temporary style may &#34;leak&#34; in the header() &amp; footer().
    &#34;&#34;&#34;
    if not font_face:
        yield
        return
    prev_font = (self.font_family, self.font_style, self.font_size_pt)
    self.set_font(
        font_face.family or self.font_family,
        (
            font_face.emphasis.style
            if font_face.emphasis is not None
            else self.font_style
        ),
        font_face.size_pt or self.font_size_pt,
    )
    self.current_font_is_set_on_page = False
    prev_text_color = self.text_color
    if font_face.color is not None and font_face.color != self.text_color:
        self.set_text_color(font_face.color)
    prev_fill_color = self.fill_color
    if font_face.fill_color is not None:
        self.set_fill_color(font_face.fill_color)
    yield
    if font_face.fill_color is not None:
        self.set_fill_color(prev_fill_color)
    self.text_color = prev_text_color
    self.set_font(*prev_font)</code></pre>
</details>
<div class="desc"><p>Sets the provided <code><a title="fpdf.fonts.FontFace" href="fonts.html#fpdf.fonts.FontFace">FontFace</a></code> in a local context,
then restore font settings back to they were initially.
This method must be used as a context manager using <code>with</code>:</p>
<pre><code>with pdf.use_font_face(FontFace(emphasis="BOLD", color=255, size_pt=42)):
    put_some_text()
</code></pre>
<p>Known limitation: in case of a page jump in this local context,
the temporary style may "leak" in the header() &amp; footer().</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.use_pattern"><code class="name flex">
<span>def <span class="ident">use_pattern</span></span>(<span>self, shading)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L1366-L1381" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@contextmanager
@check_page
def use_pattern(self, shading):
    &#34;&#34;&#34;
    Create a context for using a shading pattern on the current page.
    &#34;&#34;&#34;
    self._resource_catalog.add(PDFResourceType.SHADDING, shading, self.page)
    pattern = shading.get_pattern()
    pattern_name = self._resource_catalog.add(
        PDFResourceType.PATTERN, pattern, self.page
    )
    self._out(f&#34;/Pattern cs /{pattern_name} scn&#34;)
    try:
        yield
    finally:
        self._out(self.draw_color.serialize().lower())</code></pre>
</details>
<div class="desc"><p>Create a context for using a shading pattern on the current page.</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.use_text_style"><code class="name flex">
<span>def <span class="ident">use_text_style</span></span>(<span>self,<br>text_style: <a title="fpdf.fonts.TextStyle" href="fonts.html#fpdf.fonts.TextStyle">TextStyle</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L5515-L5537" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@contextmanager
def use_text_style(self, text_style: TextStyle):
    prev_l_margin = None
    if text_style:
        if text_style.t_margin:
            self.ln(text_style.t_margin)
        if text_style.l_margin:
            if isinstance(text_style.l_margin, (float, int)):
                prev_l_margin = self.l_margin
                self.l_margin = text_style.l_margin
                self.x = self.l_margin
            else:
                LOGGER.debug(
                    &#34;Unsupported &#39;%s&#39; value provided as l_margin to .use_text_style()&#34;,
                    text_style.l_margin,
                )
    with self.use_font_face(text_style):
        yield
    if text_style and text_style.b_margin:
        self.ln(text_style.b_margin)
    if prev_l_margin is not None:
        self.l_margin = prev_l_margin
        self.x = self.l_margin</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fpdf.FPDF.will_page_break"><code class="name flex">
<span>def <span class="ident">will_page_break</span></span>(<span>self, height)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L3886-L3900" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def will_page_break(self, height):
    &#34;&#34;&#34;
    Let you know if adding an element will trigger a page break,
    based on its height and the current ordinate (`y` position).

    Args:
        height (float): height of the section that would be added, e.g. a cell

    Returns: a boolean indicating if a page break would occur
    &#34;&#34;&#34;
    return (
        self.y + height &gt; self.page_break_trigger
        and not self.in_footer
        and self.accept_page_break
    )</code></pre>
</details>
<div class="desc"><p>Let you know if adding an element will trigger a page break,
based on its height and the current ordinate (<code>y</code> position).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>height</code></strong> :&ensp;<code>float</code></dt>
<dd>height of the section that would be added, e.g. a cell</dd>
</dl>
<p>Returns: a boolean indicating if a page break would occur</p></div>
</dd>
<dt id="fpdf.fpdf.FPDF.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self,<br>h: float = None,<br>text: str = '',<br>link: str = '',<br>print_sh: bool = False,<br>wrapmode: <a title="fpdf.enums.WrapMode" href="enums.html#fpdf.enums.WrapMode">WrapMode</a> = WrapMode.WORD)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L4307-L4391" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@check_page
@support_deprecated_txt_arg
def write(
    self,
    h: float = None,
    text: str = &#34;&#34;,
    link: str = &#34;&#34;,
    print_sh: bool = False,
    wrapmode: WrapMode = WrapMode.WORD,
):
    &#34;&#34;&#34;
    Prints text from the current position.
    When the right margin is reached, a line break occurs at the most recent
    space or soft-hyphen character, and text continues from the left margin.
    A manual break happens any time the \\n character is met,
    Upon method exit, the current position is left just at the end of the text.

    Args:
        h (float): line height. Default value: None, meaning to use the current font size.
        text (str): text content
        link (str): optional link to add on the text, internal
            (identifier returned by `FPDF.add_link`) or external URL.
        print_sh (bool): Treat a soft-hyphen (\\u00ad) as a normal printable
            character, instead of a line breaking opportunity. Default value: False
        wrapmode (fpdf.enums.WrapMode): &#34;WORD&#34; for word based line wrapping (default),
            &#34;CHAR&#34; for character based line wrapping.
        txt (str): [**DEPRECATED since v2.7.6**] text content
    &#34;&#34;&#34;
    wrapmode = WrapMode.coerce(wrapmode)
    if not self.font_family:
        raise FPDFException(&#34;No font set, you need to call set_font() beforehand&#34;)
    if isinstance(h, str):
        raise ValueError(
            &#34;Parameter &#39;h&#39; must be a number, not a string.&#34;
            &#34; You can omit it by passing string content with text=&#34;
        )
    if h is None:
        h = self.font_size

    page_break_triggered = False
    normalized_string = self.normalize_text(text).replace(&#34;\r&#34;, &#34;&#34;)
    styled_text_fragments = (
        self._preload_bidirectional_text(normalized_string, False)
        if self.text_shaping
        else self._preload_font_styles(normalized_string, False)
    )

    text_lines = []
    multi_line_break = MultiLineBreak(
        styled_text_fragments,
        lambda h: max_width,
        (self.c_margin, self.c_margin),
        print_sh=print_sh,
        wrapmode=wrapmode,
    )
    # first line from current x position to right margin
    first_width = self.w - self.x - self.r_margin
    max_width = first_width
    text_line = multi_line_break.get_line()
    # remaining lines fill between margins
    full_width = self.w - self.l_margin - self.r_margin
    max_width = full_width
    while (text_line) is not None:
        text_lines.append(text_line)
        text_line = multi_line_break.get_line()
    if not text_lines:
        return False

    for text_line_index, text_line in enumerate(text_lines):
        if text_line_index &gt; 0:
            self.ln()
        new_page = self._render_styled_text_line(
            text_line,
            h=h,
            border=0,
            new_x=XPos.WCONT,
            new_y=YPos.TOP,
            fill=False,
            link=link,
        )
        page_break_triggered = page_break_triggered or new_page
    if text_line.trailing_nl:
        # The line renderer can&#39;t handle trailing newlines in the text.
        self.ln()
    return page_break_triggered</code></pre>
</details>
<div class="desc"><p>Prints text from the current position.
When the right margin is reached, a line break occurs at the most recent
space or soft-hyphen character, and text continues from the left margin.
A manual break happens any time the \n character is met,
Upon method exit, the current position is left just at the end of the text.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>h</code></strong> :&ensp;<code>float</code></dt>
<dd>line height. Default value: None, meaning to use the current font size.</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>text content</dd>
<dt><strong><code>link</code></strong> :&ensp;<code>str</code></dt>
<dd>optional link to add on the text, internal
(identifier returned by <code><a title="fpdf.fpdf.FPDF.add_link" href="#fpdf.fpdf.FPDF.add_link">FPDF.add_link()</a></code>) or external URL.</dd>
<dt><strong><code>print_sh</code></strong> :&ensp;<code>bool</code></dt>
<dd>Treat a soft-hyphen (\u00ad) as a normal printable
character, instead of a line breaking opportunity. Default value: False</dd>
<dt><strong><code>wrapmode</code></strong> :&ensp;<code><a title="fpdf.enums.WrapMode" href="enums.html#fpdf.enums.WrapMode">WrapMode</a></code></dt>
<dd>"WORD" for word based line wrapping (default),
"CHAR" for character based line wrapping.</dd>
<dt><strong><code>txt</code></strong> :&ensp;<code>str</code></dt>
<dd>[<strong>DEPRECATED since v2.7.6</strong>] text content</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.write_html"><code class="name flex">
<span>def <span class="ident">write_html</span></span>(<span>self, text, *args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L421-L449" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def write_html(self, text, *args, **kwargs):
    &#34;&#34;&#34;
    Parse HTML and convert it to PDF.
    cf. https://py-pdf.github.io/fpdf2/HTML.html

    Args:
        text (str): HTML content to render
        image_map (function): an optional one-argument function that map `&lt;img&gt;` &#34;src&#34; to new image URLs
        li_tag_indent (int): [**DEPRECATED since v2.7.9**]
            numeric indentation of `&lt;li&gt;` elements - Set `tag_styles` instead
        dd_tag_indent (int): [**DEPRECATED since v2.7.9**]
            numeric indentation of `&lt;dd&gt;` elements - Set `tag_styles` instead
        table_line_separators (bool): enable horizontal line separators in `&lt;table&gt;`. Defaults to `False`.
        ul_bullet_char (str): bullet character preceding `&lt;li&gt;` items in `&lt;ul&gt;` lists.
            Can also be configured using the HTML `type` attribute of `&lt;ul&gt;` tags.
        li_prefix_color (tuple, str, fpdf.drawing.DeviceCMYK, fpdf.drawing.DeviceGray, fpdf.drawing.DeviceRGB): color for bullets
            or numbers preceding `&lt;li&gt;` tags. This applies to both `&lt;ul&gt;` &amp; `&lt;ol&gt;` lists.
        heading_sizes (dict): [**DEPRECATED since v2.7.9**]
            font size per heading level names (&#34;h1&#34;, &#34;h2&#34;...) - Set `tag_styles` instead
        pre_code_font (str): [**DEPRECATED since v2.7.9**]
            font to use for `&lt;pre&gt;` &amp; `&lt;code&gt;` blocks - Set `tag_styles` instead
        warn_on_tags_not_matching (bool): control warnings production for unmatched HTML tags. Defaults to `True`.
        tag_indents (dict): [**DEPRECATED since v2.8.0**]
            mapping of HTML tag names to numeric values representing their horizontal left indentation. - Set `tag_styles` instead
        tag_styles (dict[str, fpdf.fonts.TextStyle]): mapping of HTML tag names to `fpdf.TextStyle` or `fpdf.FontFace` instances
    &#34;&#34;&#34;
    html2pdf = self.HTML2FPDF_CLASS(self, *args, **kwargs)
    with self.local_context():
        html2pdf.feed(text)</code></pre>
</details>
<div class="desc"><p>Parse HTML and convert it to PDF.
cf. <a href="https://py-pdf.github.io/fpdf2/HTML.html">https://py-pdf.github.io/fpdf2/HTML.html</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>HTML content to render</dd>
<dt><strong><code>image_map</code></strong> :&ensp;<code>function</code></dt>
<dd>an optional one-argument function that map <code>&lt;img&gt;</code> "src" to new image URLs</dd>
<dt><strong><code>li_tag_indent</code></strong> :&ensp;<code>int</code></dt>
<dd>[<strong>DEPRECATED since v2.7.9</strong>]
numeric indentation of <code>&lt;li&gt;</code> elements - Set <code>tag_styles</code> instead</dd>
<dt><strong><code>dd_tag_indent</code></strong> :&ensp;<code>int</code></dt>
<dd>[<strong>DEPRECATED since v2.7.9</strong>]
numeric indentation of <code>&lt;dd&gt;</code> elements - Set <code>tag_styles</code> instead</dd>
<dt><strong><code>table_line_separators</code></strong> :&ensp;<code>bool</code></dt>
<dd>enable horizontal line separators in <code>&lt;table&gt;</code>. Defaults to <code>False</code>.</dd>
<dt><strong><code>ul_bullet_char</code></strong> :&ensp;<code>str</code></dt>
<dd>bullet character preceding <code>&lt;li&gt;</code> items in <code>&lt;ul&gt;</code> lists.
Can also be configured using the HTML <code>type</code> attribute of <code>&lt;ul&gt;</code> tags.</dd>
<dt><strong><code>li_prefix_color</code></strong> :&ensp;<code>tuple, str, <a title="fpdf.drawing.DeviceCMYK" href="drawing.html#fpdf.drawing.DeviceCMYK">DeviceCMYK</a>, <a title="fpdf.drawing.DeviceGray" href="drawing.html#fpdf.drawing.DeviceGray">DeviceGray</a>, <a title="fpdf.drawing.DeviceRGB" href="drawing.html#fpdf.drawing.DeviceRGB">DeviceRGB</a></code></dt>
<dd>color for bullets
or numbers preceding <code>&lt;li&gt;</code> tags. This applies to both <code>&lt;ul&gt;</code> &amp; <code>&lt;ol&gt;</code> lists.</dd>
<dt><strong><code>heading_sizes</code></strong> :&ensp;<code>dict</code></dt>
<dd>[<strong>DEPRECATED since v2.7.9</strong>]
font size per heading level names ("h1", "h2"&hellip;) - Set <code>tag_styles</code> instead</dd>
<dt><strong><code>pre_code_font</code></strong> :&ensp;<code>str</code></dt>
<dd>[<strong>DEPRECATED since v2.7.9</strong>]
font to use for <code>&lt;pre&gt;</code> &amp; <code>&lt;code&gt;</code> blocks - Set <code>tag_styles</code> instead</dd>
<dt><strong><code>warn_on_tags_not_matching</code></strong> :&ensp;<code>bool</code></dt>
<dd>control warnings production for unmatched HTML tags. Defaults to <code>True</code>.</dd>
<dt><strong><code>tag_indents</code></strong> :&ensp;<code>dict</code></dt>
<dd>[<strong>DEPRECATED since v2.8.0</strong>]
mapping of HTML tag names to numeric values representing their horizontal left indentation. - Set <code>tag_styles</code> instead</dd>
<dt><strong><code>tag_styles</code></strong> :&ensp;<code>dict[str, <a title="fpdf.fonts.TextStyle" href="fonts.html#fpdf.fonts.TextStyle">TextStyle</a>]</code></dt>
<dd>mapping of HTML tag names to <code>fpdf.TextStyle</code> or <code>fpdf.FontFace</code> instances</dd>
</dl></div>
</dd>
<dt id="fpdf.fpdf.FPDF.x_by_align"><code class="name flex">
<span>def <span class="ident">x_by_align</span></span>(<span>self, x, w, h, img_info, keep_aspect_ratio)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fpdf.py#L4593-L4603" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def x_by_align(self, x, w, h, img_info, keep_aspect_ratio):
    if keep_aspect_ratio:
        _, _, w, h = img_info.scale_inside_box(0, 0, w, h)
    x = Align.coerce(x)
    if x == Align.C:
        return (self.w - w) / 2
    if x == Align.R:
        return self.w - w - self.r_margin
    if x == Align.L:
        return self.l_margin
    raise ValueError(f&#34;Unsupported &#39;x&#39; value passed to .image(): {x}&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fpdf.fpdf.ImageInfo"><code class="flex name class">
<span>class <span class="ident">ImageInfo</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/image_datastructures.py#L5-L49" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class ImageInfo(dict):
    &#34;&#34;&#34;Information about an image used in the PDF document (base class).
    We subclass this to distinguish between raster and vector images.&#34;&#34;&#34;

    @property
    def width(self):
        &#34;Intrinsic image width&#34;
        return self[&#34;w&#34;]

    @property
    def height(self):
        &#34;Intrinsic image height&#34;
        return self[&#34;h&#34;]

    @property
    def rendered_width(self):
        &#34;Only available if the image has been placed on the document&#34;
        return self[&#34;rendered_width&#34;]

    @property
    def rendered_height(self):
        &#34;Only available if the image has been placed on the document&#34;
        return self[&#34;rendered_height&#34;]

    def __str__(self):
        d = {
            k: (&#34;...&#34; if k in (&#34;data&#34;, &#34;iccp&#34;, &#34;smask&#34;) else v) for k, v in self.items()
        }
        return f&#34;self.__class__.__name__({d})&#34;

    def scale_inside_box(self, x, y, w, h):
        &#34;&#34;&#34;
        Make an image fit within a bounding box, maintaining its proportions.
        In the reduced dimension it will be centered within the available space.
        &#34;&#34;&#34;
        ratio = self.width / self.height
        if h * ratio &lt; w:
            new_w = h * ratio
            new_h = h
            x += (w - new_w) / 2
        else:  # =&gt; too wide, limiting width:
            new_h = w / ratio
            new_w = w
            y += (h - new_h) / 2
        return x, y, new_w, new_h</code></pre>
</details>
<div class="desc"><p>Information about an image used in the PDF document (base class).
We subclass this to distinguish between raster and vector images.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fpdf.image_datastructures.RasterImageInfo" href="image_datastructures.html#fpdf.image_datastructures.RasterImageInfo">RasterImageInfo</a></li>
<li><a title="fpdf.image_datastructures.VectorImageInfo" href="image_datastructures.html#fpdf.image_datastructures.VectorImageInfo">VectorImageInfo</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.fpdf.ImageInfo.height"><code class="name">prop <span class="ident">height</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/image_datastructures.py#L14-L17" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def height(self):
    &#34;Intrinsic image height&#34;
    return self[&#34;h&#34;]</code></pre>
</details>
<div class="desc"><p>Intrinsic image height</p></div>
</dd>
<dt id="fpdf.fpdf.ImageInfo.rendered_height"><code class="name">prop <span class="ident">rendered_height</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/image_datastructures.py#L24-L27" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def rendered_height(self):
    &#34;Only available if the image has been placed on the document&#34;
    return self[&#34;rendered_height&#34;]</code></pre>
</details>
<div class="desc"><p>Only available if the image has been placed on the document</p></div>
</dd>
<dt id="fpdf.fpdf.ImageInfo.rendered_width"><code class="name">prop <span class="ident">rendered_width</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/image_datastructures.py#L19-L22" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def rendered_width(self):
    &#34;Only available if the image has been placed on the document&#34;
    return self[&#34;rendered_width&#34;]</code></pre>
</details>
<div class="desc"><p>Only available if the image has been placed on the document</p></div>
</dd>
<dt id="fpdf.fpdf.ImageInfo.width"><code class="name">prop <span class="ident">width</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/image_datastructures.py#L9-L12" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def width(self):
    &#34;Intrinsic image width&#34;
    return self[&#34;w&#34;]</code></pre>
</details>
<div class="desc"><p>Intrinsic image width</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.fpdf.ImageInfo.scale_inside_box"><code class="name flex">
<span>def <span class="ident">scale_inside_box</span></span>(<span>self, x, y, w, h)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/image_datastructures.py#L35-L49" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def scale_inside_box(self, x, y, w, h):
    &#34;&#34;&#34;
    Make an image fit within a bounding box, maintaining its proportions.
    In the reduced dimension it will be centered within the available space.
    &#34;&#34;&#34;
    ratio = self.width / self.height
    if h * ratio &lt; w:
        new_w = h * ratio
        new_h = h
        x += (w - new_w) / 2
    else:  # =&gt; too wide, limiting width:
        new_h = w / ratio
        new_w = w
        y += (h - new_h) / 2
    return x, y, new_w, new_h</code></pre>
</details>
<div class="desc"><p>Make an image fit within a bounding box, maintaining its proportions.
In the reduced dimension it will be centered within the available space.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.fpdf.RasterImageInfo"><code class="flex name class">
<span>class <span class="ident">RasterImageInfo</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/image_datastructures.py#L52-L63" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class RasterImageInfo(ImageInfo):
    &#34;Information about a raster image used in the PDF document&#34;

    def size_in_document_units(self, w, h, scale=1):
        if w == 0 and h == 0:  # Put image at 72 dpi
            w = self[&#34;w&#34;] / scale
            h = self[&#34;h&#34;] / scale
        elif w == 0:
            w = h * self[&#34;w&#34;] / self[&#34;h&#34;]
        elif h == 0:
            h = w * self[&#34;h&#34;] / self[&#34;w&#34;]
        return w, h</code></pre>
</details>
<div class="desc"><p>Information about a raster image used in the PDF document</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fpdf.image_datastructures.ImageInfo" href="image_datastructures.html#fpdf.image_datastructures.ImageInfo">ImageInfo</a></li>
<li>builtins.dict</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.fpdf.RasterImageInfo.height"><code class="name">prop <span class="ident">height</span></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.image_datastructures.ImageInfo" href="image_datastructures.html#fpdf.image_datastructures.ImageInfo">ImageInfo</a></code>.<code><a title="fpdf.image_datastructures.ImageInfo.height" href="image_datastructures.html#fpdf.image_datastructures.ImageInfo.height">height</a></code>
</p>
<div class="desc inherited"><p>Intrinsic image height</p></div>
</dd>
<dt id="fpdf.fpdf.RasterImageInfo.rendered_height"><code class="name">prop <span class="ident">rendered_height</span></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.image_datastructures.ImageInfo" href="image_datastructures.html#fpdf.image_datastructures.ImageInfo">ImageInfo</a></code>.<code><a title="fpdf.image_datastructures.ImageInfo.rendered_height" href="image_datastructures.html#fpdf.image_datastructures.ImageInfo.rendered_height">rendered_height</a></code>
</p>
<div class="desc inherited"><p>Only available if the image has been placed on the document</p></div>
</dd>
<dt id="fpdf.fpdf.RasterImageInfo.rendered_width"><code class="name">prop <span class="ident">rendered_width</span></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.image_datastructures.ImageInfo" href="image_datastructures.html#fpdf.image_datastructures.ImageInfo">ImageInfo</a></code>.<code><a title="fpdf.image_datastructures.ImageInfo.rendered_width" href="image_datastructures.html#fpdf.image_datastructures.ImageInfo.rendered_width">rendered_width</a></code>
</p>
<div class="desc inherited"><p>Only available if the image has been placed on the document</p></div>
</dd>
<dt id="fpdf.fpdf.RasterImageInfo.width"><code class="name">prop <span class="ident">width</span></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.image_datastructures.ImageInfo" href="image_datastructures.html#fpdf.image_datastructures.ImageInfo">ImageInfo</a></code>.<code><a title="fpdf.image_datastructures.ImageInfo.width" href="image_datastructures.html#fpdf.image_datastructures.ImageInfo.width">width</a></code>
</p>
<div class="desc inherited"><p>Intrinsic image width</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.fpdf.RasterImageInfo.scale_inside_box"><code class="name flex">
<span>def <span class="ident">scale_inside_box</span></span>(<span>self, x, y, w, h)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.image_datastructures.ImageInfo" href="image_datastructures.html#fpdf.image_datastructures.ImageInfo">ImageInfo</a></code>.<code><a title="fpdf.image_datastructures.ImageInfo.scale_inside_box" href="image_datastructures.html#fpdf.image_datastructures.ImageInfo.scale_inside_box">scale_inside_box</a></code>
</p>
<div class="desc inherited"><p>Make an image fit within a bounding box, maintaining its proportions.
In the reduced dimension it will be centered within the available space.</p></div>
</dd>
<dt id="fpdf.fpdf.RasterImageInfo.size_in_document_units"><code class="name flex">
<span>def <span class="ident">size_in_document_units</span></span>(<span>self, w, h, scale=1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/image_datastructures.py#L55-L63" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def size_in_document_units(self, w, h, scale=1):
    if w == 0 and h == 0:  # Put image at 72 dpi
        w = self[&#34;w&#34;] / scale
        h = self[&#34;h&#34;] / scale
    elif w == 0:
        w = h * self[&#34;w&#34;] / self[&#34;h&#34;]
    elif h == 0:
        h = w * self[&#34;h&#34;] / self[&#34;w&#34;]
    return w, h</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fpdf.fpdf.TextMode"><code class="flex name class">
<span>class <span class="ident">TextMode</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/enums.py#L1016-L1026" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TextMode(CoerciveIntEnum):
    &#34;Values described in PDF spec section &#39;Text Rendering Mode&#39;&#34;

    FILL = 0
    STROKE = 1
    FILL_STROKE = 2
    INVISIBLE = 3
    FILL_CLIP = 4
    STROKE_CLIP = 5
    FILL_STROKE_CLIP = 6
    CLIP = 7</code></pre>
</details>
<div class="desc"><p>Values described in PDF spec section 'Text Rendering Mode'</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fpdf.enums.CoerciveIntEnum" href="enums.html#fpdf.enums.CoerciveIntEnum">CoerciveIntEnum</a></li>
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fpdf.fpdf.TextMode.CLIP"><code class="name">var <span class="ident">CLIP</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="fpdf.fpdf.TextMode.FILL"><code class="name">var <span class="ident">FILL</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="fpdf.fpdf.TextMode.FILL_CLIP"><code class="name">var <span class="ident">FILL_CLIP</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="fpdf.fpdf.TextMode.FILL_STROKE"><code class="name">var <span class="ident">FILL_STROKE</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="fpdf.fpdf.TextMode.FILL_STROKE_CLIP"><code class="name">var <span class="ident">FILL_STROKE_CLIP</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="fpdf.fpdf.TextMode.INVISIBLE"><code class="name">var <span class="ident">INVISIBLE</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="fpdf.fpdf.TextMode.STROKE"><code class="name">var <span class="ident">STROKE</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="fpdf.fpdf.TextMode.STROKE_CLIP"><code class="name">var <span class="ident">STROKE_CLIP</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="fpdf.fpdf.TextMode.coerce"><code class="name flex">
<span>def <span class="ident">coerce</span></span>(<span>value)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.enums.CoerciveIntEnum" href="enums.html#fpdf.enums.CoerciveIntEnum">CoerciveIntEnum</a></code>.<code><a title="fpdf.enums.CoerciveIntEnum.coerce" href="enums.html#fpdf.enums.CoerciveIntEnum.coerce">coerce</a></code>
</p>
<div class="desc inherited"><p>Attempt to coerce <code>value</code> into a member of this enumeration …</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.fpdf.TitleStyle"><code class="flex name class">
<span>class <span class="ident">TitleStyle</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/fonts.py#L193-L203" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TitleStyle(TextStyle):
    def __init__(self, *args, **kwargs):
        warnings.warn(
            (
                &#34;fpdf.TitleStyle is deprecated since 2.8.0.&#34;
                &#34; It has been replaced by fpdf.TextStyle.&#34;
            ),
            DeprecationWarning,
            stacklevel=get_stack_level(),
        )
        super().__init__(*args, **kwargs)</code></pre>
</details>
<div class="desc"><p>Subclass of <code>FontFace</code> that allows to specify vertical &amp; horizontal spacing</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fpdf.fonts.TextStyle" href="fonts.html#fpdf.fonts.TextStyle">TextStyle</a></li>
<li><a title="fpdf.fonts.FontFace" href="fonts.html#fpdf.fonts.FontFace">FontFace</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fpdf.fpdf.TitleStyle.combine"><code class="name flex">
<span>def <span class="ident">combine</span></span>(<span>default_style, override_style)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.fonts.TextStyle" href="fonts.html#fpdf.fonts.TextStyle">TextStyle</a></code>.<code><a title="fpdf.fonts.TextStyle.combine" href="fonts.html#fpdf.fonts.TextStyle.combine">combine</a></code>
</p>
<div class="desc inherited"><p>Create a combined FontFace with all the supplied features of the two styles. When both
the default and override styles provide a feature, prefer the …</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.fpdf.TitleStyle.replace"><code class="name flex">
<span>def <span class="ident">replace</span></span>(<span>self,<br>/,<br>font_family=None,<br>emphasis=None,<br>font_size_pt=None,<br>color=None,<br>fill_color=None,<br>t_margin=None,<br>l_margin=None,<br>b_margin=None)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.fonts.TextStyle" href="fonts.html#fpdf.fonts.TextStyle">TextStyle</a></code>.<code><a title="fpdf.fonts.TextStyle.replace" href="fonts.html#fpdf.fonts.TextStyle.replace">replace</a></code>
</p>
<div class="desc inherited"><p>Create a new TextStyle instance, with new values for some attributes.
Same as <code>dataclasses.replace()</code></p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.fpdf.VectorImageInfo"><code class="flex name class">
<span>class <span class="ident">VectorImageInfo</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/image_datastructures.py#L66-L69" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class VectorImageInfo(ImageInfo):
    &#34;Information about a vector image used in the PDF document&#34;

    # pass</code></pre>
</details>
<div class="desc"><p>Information about a vector image used in the PDF document</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fpdf.image_datastructures.ImageInfo" href="image_datastructures.html#fpdf.image_datastructures.ImageInfo">ImageInfo</a></li>
<li>builtins.dict</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.fpdf.VectorImageInfo.height"><code class="name">prop <span class="ident">height</span></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.image_datastructures.ImageInfo" href="image_datastructures.html#fpdf.image_datastructures.ImageInfo">ImageInfo</a></code>.<code><a title="fpdf.image_datastructures.ImageInfo.height" href="image_datastructures.html#fpdf.image_datastructures.ImageInfo.height">height</a></code>
</p>
<div class="desc inherited"><p>Intrinsic image height</p></div>
</dd>
<dt id="fpdf.fpdf.VectorImageInfo.rendered_height"><code class="name">prop <span class="ident">rendered_height</span></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.image_datastructures.ImageInfo" href="image_datastructures.html#fpdf.image_datastructures.ImageInfo">ImageInfo</a></code>.<code><a title="fpdf.image_datastructures.ImageInfo.rendered_height" href="image_datastructures.html#fpdf.image_datastructures.ImageInfo.rendered_height">rendered_height</a></code>
</p>
<div class="desc inherited"><p>Only available if the image has been placed on the document</p></div>
</dd>
<dt id="fpdf.fpdf.VectorImageInfo.rendered_width"><code class="name">prop <span class="ident">rendered_width</span></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.image_datastructures.ImageInfo" href="image_datastructures.html#fpdf.image_datastructures.ImageInfo">ImageInfo</a></code>.<code><a title="fpdf.image_datastructures.ImageInfo.rendered_width" href="image_datastructures.html#fpdf.image_datastructures.ImageInfo.rendered_width">rendered_width</a></code>
</p>
<div class="desc inherited"><p>Only available if the image has been placed on the document</p></div>
</dd>
<dt id="fpdf.fpdf.VectorImageInfo.width"><code class="name">prop <span class="ident">width</span></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.image_datastructures.ImageInfo" href="image_datastructures.html#fpdf.image_datastructures.ImageInfo">ImageInfo</a></code>.<code><a title="fpdf.image_datastructures.ImageInfo.width" href="image_datastructures.html#fpdf.image_datastructures.ImageInfo.width">width</a></code>
</p>
<div class="desc inherited"><p>Intrinsic image width</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.fpdf.VectorImageInfo.scale_inside_box"><code class="name flex">
<span>def <span class="ident">scale_inside_box</span></span>(<span>self, x, y, w, h)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.image_datastructures.ImageInfo" href="image_datastructures.html#fpdf.image_datastructures.ImageInfo">ImageInfo</a></code>.<code><a title="fpdf.image_datastructures.ImageInfo.scale_inside_box" href="image_datastructures.html#fpdf.image_datastructures.ImageInfo.scale_inside_box">scale_inside_box</a></code>
</p>
<div class="desc inherited"><p>Make an image fit within a bounding box, maintaining its proportions.
In the reduced dimension it will be centered within the available space.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.fpdf.XPos"><code class="flex name class">
<span>class <span class="ident">XPos</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/enums.py#L1029-L1054" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class XPos(CoerciveEnum):
    &#34;Positional values in horizontal direction for use after printing text.&#34;

    LEFT = intern(&#34;LEFT&#34;)  # self.x
    &#34;left end of the cell&#34;

    RIGHT = intern(&#34;RIGHT&#34;)  # self.x + w
    &#34;right end of the cell (default)&#34;

    START = intern(&#34;START&#34;)
    &#34;left start of actual text&#34;

    END = intern(&#34;END&#34;)
    &#34;right end of actual text&#34;

    WCONT = intern(&#34;WCONT&#34;)
    &#34;for write() to continue next (slightly left of END)&#34;

    CENTER = intern(&#34;CENTER&#34;)
    &#34;center of actual text&#34;

    LMARGIN = intern(&#34;LMARGIN&#34;)  # self.l_margin
    &#34;left page margin (start of printable area)&#34;

    RMARGIN = intern(&#34;RMARGIN&#34;)  # self.w - self.r_margin
    &#34;right page margin (end of printable area)&#34;</code></pre>
</details>
<div class="desc"><p>Positional values in horizontal direction for use after printing text.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fpdf.enums.CoerciveEnum" href="enums.html#fpdf.enums.CoerciveEnum">CoerciveEnum</a></li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fpdf.fpdf.XPos.CENTER"><code class="name">var <span class="ident">CENTER</span></code></dt>
<dd>
<div class="desc"><p>center of actual text</p></div>
</dd>
<dt id="fpdf.fpdf.XPos.END"><code class="name">var <span class="ident">END</span></code></dt>
<dd>
<div class="desc"><p>right end of actual text</p></div>
</dd>
<dt id="fpdf.fpdf.XPos.LEFT"><code class="name">var <span class="ident">LEFT</span></code></dt>
<dd>
<div class="desc"><p>left end of the cell</p></div>
</dd>
<dt id="fpdf.fpdf.XPos.LMARGIN"><code class="name">var <span class="ident">LMARGIN</span></code></dt>
<dd>
<div class="desc"><p>left page margin (start of printable area)</p></div>
</dd>
<dt id="fpdf.fpdf.XPos.RIGHT"><code class="name">var <span class="ident">RIGHT</span></code></dt>
<dd>
<div class="desc"><p>right end of the cell (default)</p></div>
</dd>
<dt id="fpdf.fpdf.XPos.RMARGIN"><code class="name">var <span class="ident">RMARGIN</span></code></dt>
<dd>
<div class="desc"><p>right page margin (end of printable area)</p></div>
</dd>
<dt id="fpdf.fpdf.XPos.START"><code class="name">var <span class="ident">START</span></code></dt>
<dd>
<div class="desc"><p>left start of actual text</p></div>
</dd>
<dt id="fpdf.fpdf.XPos.WCONT"><code class="name">var <span class="ident">WCONT</span></code></dt>
<dd>
<div class="desc"><p>for write() to continue next (slightly left of END)</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="fpdf.fpdf.XPos.coerce"><code class="name flex">
<span>def <span class="ident">coerce</span></span>(<span>value, case_sensitive=False)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.enums.CoerciveEnum" href="enums.html#fpdf.enums.CoerciveEnum">CoerciveEnum</a></code>.<code><a title="fpdf.enums.CoerciveEnum.coerce" href="enums.html#fpdf.enums.CoerciveEnum.coerce">coerce</a></code>
</p>
<div class="desc inherited"><p>Attempt to coerce <code>value</code> into a member of this enumeration …</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.fpdf.YPos"><code class="flex name class">
<span>class <span class="ident">YPos</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f84b3017bd8f88f238cfa776838a896efb9a5f53/fpdf/enums.py#L1057-L1073" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class YPos(CoerciveEnum):
    &#34;Positional values in vertical direction for use after printing text&#34;

    TOP = intern(&#34;TOP&#34;)  # self.y
    &#34;top of the first line (default)&#34;

    LAST = intern(&#34;LAST&#34;)
    &#34;top of the last line (same as TOP for single-line text)&#34;

    NEXT = intern(&#34;NEXT&#34;)  # LAST + h
    &#34;top of next line (bottom of current text)&#34;

    TMARGIN = intern(&#34;TMARGIN&#34;)  # self.t_margin
    &#34;top page margin (start of printable area)&#34;

    BMARGIN = intern(&#34;BMARGIN&#34;)  # self.h - self.b_margin
    &#34;bottom page margin (end of printable area)&#34;</code></pre>
</details>
<div class="desc"><p>Positional values in vertical direction for use after printing text</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fpdf.enums.CoerciveEnum" href="enums.html#fpdf.enums.CoerciveEnum">CoerciveEnum</a></li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fpdf.fpdf.YPos.BMARGIN"><code class="name">var <span class="ident">BMARGIN</span></code></dt>
<dd>
<div class="desc"><p>bottom page margin (end of printable area)</p></div>
</dd>
<dt id="fpdf.fpdf.YPos.LAST"><code class="name">var <span class="ident">LAST</span></code></dt>
<dd>
<div class="desc"><p>top of the last line (same as TOP for single-line text)</p></div>
</dd>
<dt id="fpdf.fpdf.YPos.NEXT"><code class="name">var <span class="ident">NEXT</span></code></dt>
<dd>
<div class="desc"><p>top of next line (bottom of current text)</p></div>
</dd>
<dt id="fpdf.fpdf.YPos.TMARGIN"><code class="name">var <span class="ident">TMARGIN</span></code></dt>
<dd>
<div class="desc"><p>top page margin (start of printable area)</p></div>
</dd>
<dt id="fpdf.fpdf.YPos.TOP"><code class="name">var <span class="ident">TOP</span></code></dt>
<dd>
<div class="desc"><p>top of the first line (default)</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="fpdf.fpdf.YPos.coerce"><code class="name flex">
<span>def <span class="ident">coerce</span></span>(<span>value, case_sensitive=False)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.enums.CoerciveEnum" href="enums.html#fpdf.enums.CoerciveEnum">CoerciveEnum</a></code>.<code><a title="fpdf.enums.CoerciveEnum.coerce" href="enums.html#fpdf.enums.CoerciveEnum.coerce">coerce</a></code>
</p>
<div class="desc inherited"><p>Attempt to coerce <code>value</code> into a member of this enumeration …</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fpdf" href="index.html">fpdf</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="fpdf.fpdf.PAGE_FORMATS" href="#fpdf.fpdf.PAGE_FORMATS">PAGE_FORMATS</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="fpdf.fpdf.get_page_format" href="#fpdf.fpdf.get_page_format">get_page_format</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fpdf.fpdf.FPDF" href="#fpdf.fpdf.FPDF">FPDF</a></code></h4>
<ul class="">
<li><code><a title="fpdf.fpdf.FPDF.DEFAULT_DRAW_COLOR" href="graphics_state.html#fpdf.fpdf.FPDF.DEFAULT_DRAW_COLOR">DEFAULT_DRAW_COLOR</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.DEFAULT_FILL_COLOR" href="graphics_state.html#fpdf.fpdf.FPDF.DEFAULT_FILL_COLOR">DEFAULT_FILL_COLOR</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.DEFAULT_TEXT_COLOR" href="graphics_state.html#fpdf.fpdf.FPDF.DEFAULT_TEXT_COLOR">DEFAULT_TEXT_COLOR</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.HTML2FPDF_CLASS" href="#fpdf.fpdf.FPDF.HTML2FPDF_CLASS">HTML2FPDF_CLASS</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.MARKDOWN_BOLD_MARKER" href="#fpdf.fpdf.FPDF.MARKDOWN_BOLD_MARKER">MARKDOWN_BOLD_MARKER</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.MARKDOWN_ESCAPE_CHARACTER" href="#fpdf.fpdf.FPDF.MARKDOWN_ESCAPE_CHARACTER">MARKDOWN_ESCAPE_CHARACTER</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.MARKDOWN_ITALICS_MARKER" href="#fpdf.fpdf.FPDF.MARKDOWN_ITALICS_MARKER">MARKDOWN_ITALICS_MARKER</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.MARKDOWN_LINK_COLOR" href="#fpdf.fpdf.FPDF.MARKDOWN_LINK_COLOR">MARKDOWN_LINK_COLOR</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.MARKDOWN_LINK_REGEX" href="#fpdf.fpdf.FPDF.MARKDOWN_LINK_REGEX">MARKDOWN_LINK_REGEX</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.MARKDOWN_LINK_UNDERLINE" href="#fpdf.fpdf.FPDF.MARKDOWN_LINK_UNDERLINE">MARKDOWN_LINK_UNDERLINE</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.MARKDOWN_STRIKETHROUGH_MARKER" href="#fpdf.fpdf.FPDF.MARKDOWN_STRIKETHROUGH_MARKER">MARKDOWN_STRIKETHROUGH_MARKER</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.MARKDOWN_UNDERLINE_MARKER" href="#fpdf.fpdf.FPDF.MARKDOWN_UNDERLINE_MARKER">MARKDOWN_UNDERLINE_MARKER</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF._get_current_graphics_state" href="graphics_state.html#fpdf.fpdf.FPDF._get_current_graphics_state">_get_current_graphics_state</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF._is_current_graphics_state_nested" href="graphics_state.html#fpdf.fpdf.FPDF._is_current_graphics_state_nested">_is_current_graphics_state_nested</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF._pop_local_stack" href="graphics_state.html#fpdf.fpdf.FPDF._pop_local_stack">_pop_local_stack</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF._push_local_stack" href="graphics_state.html#fpdf.fpdf.FPDF._push_local_stack">_push_local_stack</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.accept_page_break" href="#fpdf.fpdf.FPDF.accept_page_break">accept_page_break</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.add_action" href="#fpdf.fpdf.FPDF.add_action">add_action</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.add_font" href="#fpdf.fpdf.FPDF.add_font">add_font</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.add_link" href="#fpdf.fpdf.FPDF.add_link">add_link</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.add_output_intent" href="#fpdf.fpdf.FPDF.add_output_intent">add_output_intent</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.add_page" href="#fpdf.fpdf.FPDF.add_page">add_page</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.add_text_markup_annotation" href="#fpdf.fpdf.FPDF.add_text_markup_annotation">add_text_markup_annotation</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.alias_nb_pages" href="#fpdf.fpdf.FPDF.alias_nb_pages">alias_nb_pages</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.arc" href="#fpdf.fpdf.FPDF.arc">arc</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.bezier" href="#fpdf.fpdf.FPDF.bezier">bezier</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.cell" href="#fpdf.fpdf.FPDF.cell">cell</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.char_vpos" href="graphics_state.html#fpdf.fpdf.FPDF.char_vpos">char_vpos</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.circle" href="#fpdf.fpdf.FPDF.circle">circle</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.code39" href="#fpdf.fpdf.FPDF.code39">code39</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.core_fonts_encoding" href="#fpdf.fpdf.FPDF.core_fonts_encoding">core_fonts_encoding</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.dashed_line" href="#fpdf.fpdf.FPDF.dashed_line">dashed_line</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.default_page_dimensions" href="#fpdf.fpdf.FPDF.default_page_dimensions">default_page_dimensions</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.denom_lift" href="graphics_state.html#fpdf.fpdf.FPDF.denom_lift">denom_lift</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.denom_scale" href="graphics_state.html#fpdf.fpdf.FPDF.denom_scale">denom_scale</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.draw_path" href="#fpdf.fpdf.FPDF.draw_path">draw_path</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.drawing_context" href="#fpdf.fpdf.FPDF.drawing_context">drawing_context</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.ellipse" href="#fpdf.fpdf.FPDF.ellipse">ellipse</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.elliptic_clip" href="#fpdf.fpdf.FPDF.elliptic_clip">elliptic_clip</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.embed_file" href="#fpdf.fpdf.FPDF.embed_file">embed_file</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.emphasis" href="#fpdf.fpdf.FPDF.emphasis">emphasis</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.eph" href="#fpdf.fpdf.FPDF.eph">eph</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.epw" href="#fpdf.fpdf.FPDF.epw">epw</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.file_attachment_annotation" href="#fpdf.fpdf.FPDF.file_attachment_annotation">file_attachment_annotation</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.file_id" href="#fpdf.fpdf.FPDF.file_id">file_id</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.font_face" href="graphics_state.html#fpdf.fpdf.FPDF.font_face">font_face</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.footer" href="#fpdf.fpdf.FPDF.footer">footer</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.free_text_annotation" href="#fpdf.fpdf.FPDF.free_text_annotation">free_text_annotation</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.get_fallback_font" href="#fpdf.fpdf.FPDF.get_fallback_font">get_fallback_font</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.get_page_label" href="#fpdf.fpdf.FPDF.get_page_label">get_page_label</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.get_string_width" href="#fpdf.fpdf.FPDF.get_string_width">get_string_width</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.get_x" href="#fpdf.fpdf.FPDF.get_x">get_x</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.get_y" href="#fpdf.fpdf.FPDF.get_y">get_y</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.header" href="#fpdf.fpdf.FPDF.header">header</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.highlight" href="#fpdf.fpdf.FPDF.highlight">highlight</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.image" href="#fpdf.fpdf.FPDF.image">image</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.ink_annotation" href="#fpdf.fpdf.FPDF.ink_annotation">ink_annotation</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.insert_toc_placeholder" href="#fpdf.fpdf.FPDF.insert_toc_placeholder">insert_toc_placeholder</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.interleaved2of5" href="#fpdf.fpdf.FPDF.interleaved2of5">interleaved2of5</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.is_ttf_font" href="#fpdf.fpdf.FPDF.is_ttf_font">is_ttf_font</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.line" href="#fpdf.fpdf.FPDF.line">line</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.link" href="#fpdf.fpdf.FPDF.link">link</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.ln" href="#fpdf.fpdf.FPDF.ln">ln</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.local_context" href="#fpdf.fpdf.FPDF.local_context">local_context</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.mirror" href="#fpdf.fpdf.FPDF.mirror">mirror</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.multi_cell" href="#fpdf.fpdf.FPDF.multi_cell">multi_cell</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.new_path" href="#fpdf.fpdf.FPDF.new_path">new_path</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.nom_lift" href="graphics_state.html#fpdf.fpdf.FPDF.nom_lift">nom_lift</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.nom_scale" href="graphics_state.html#fpdf.fpdf.FPDF.nom_scale">nom_scale</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.normalize_text" href="#fpdf.fpdf.FPDF.normalize_text">normalize_text</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.offset_rendering" href="#fpdf.fpdf.FPDF.offset_rendering">offset_rendering</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.output" href="#fpdf.fpdf.FPDF.output">output</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.output_intents" href="#fpdf.fpdf.FPDF.output_intents">output_intents</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.page" href="#fpdf.fpdf.FPDF.page">page</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.page_layout" href="#fpdf.fpdf.FPDF.page_layout">page_layout</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.page_mode" href="#fpdf.fpdf.FPDF.page_mode">page_mode</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.page_no" href="#fpdf.fpdf.FPDF.page_no">page_no</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.pages_count" href="#fpdf.fpdf.FPDF.pages_count">pages_count</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.polygon" href="#fpdf.fpdf.FPDF.polygon">polygon</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.polyline" href="#fpdf.fpdf.FPDF.polyline">polyline</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.preload_image" href="#fpdf.fpdf.FPDF.preload_image">preload_image</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.rect" href="#fpdf.fpdf.FPDF.rect">rect</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.rect_clip" href="#fpdf.fpdf.FPDF.rect_clip">rect_clip</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.regular_polygon" href="#fpdf.fpdf.FPDF.regular_polygon">regular_polygon</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.rotate" href="#fpdf.fpdf.FPDF.rotate">rotate</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.rotation" href="#fpdf.fpdf.FPDF.rotation">rotation</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.round_clip" href="#fpdf.fpdf.FPDF.round_clip">round_clip</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_author" href="#fpdf.fpdf.FPDF.set_author">set_author</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_auto_page_break" href="#fpdf.fpdf.FPDF.set_auto_page_break">set_auto_page_break</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_char_spacing" href="#fpdf.fpdf.FPDF.set_char_spacing">set_char_spacing</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_compression" href="#fpdf.fpdf.FPDF.set_compression">set_compression</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_creation_date" href="#fpdf.fpdf.FPDF.set_creation_date">set_creation_date</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_creator" href="#fpdf.fpdf.FPDF.set_creator">set_creator</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_dash_pattern" href="#fpdf.fpdf.FPDF.set_dash_pattern">set_dash_pattern</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_display_mode" href="#fpdf.fpdf.FPDF.set_display_mode">set_display_mode</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_doc_option" href="#fpdf.fpdf.FPDF.set_doc_option">set_doc_option</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_draw_color" href="#fpdf.fpdf.FPDF.set_draw_color">set_draw_color</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_encryption" href="#fpdf.fpdf.FPDF.set_encryption">set_encryption</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_fallback_fonts" href="#fpdf.fpdf.FPDF.set_fallback_fonts">set_fallback_fonts</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_fill_color" href="#fpdf.fpdf.FPDF.set_fill_color">set_fill_color</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_font" href="#fpdf.fpdf.FPDF.set_font">set_font</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_font_size" href="#fpdf.fpdf.FPDF.set_font_size">set_font_size</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_image_filter" href="#fpdf.fpdf.FPDF.set_image_filter">set_image_filter</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_keywords" href="#fpdf.fpdf.FPDF.set_keywords">set_keywords</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_lang" href="#fpdf.fpdf.FPDF.set_lang">set_lang</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_left_margin" href="#fpdf.fpdf.FPDF.set_left_margin">set_left_margin</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_line_width" href="#fpdf.fpdf.FPDF.set_line_width">set_line_width</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_link" href="#fpdf.fpdf.FPDF.set_link">set_link</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_margin" href="#fpdf.fpdf.FPDF.set_margin">set_margin</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_margins" href="#fpdf.fpdf.FPDF.set_margins">set_margins</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_page_background" href="#fpdf.fpdf.FPDF.set_page_background">set_page_background</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_page_label" href="#fpdf.fpdf.FPDF.set_page_label">set_page_label</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_producer" href="#fpdf.fpdf.FPDF.set_producer">set_producer</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_right_margin" href="#fpdf.fpdf.FPDF.set_right_margin">set_right_margin</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_section_title_styles" href="#fpdf.fpdf.FPDF.set_section_title_styles">set_section_title_styles</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_stretching" href="#fpdf.fpdf.FPDF.set_stretching">set_stretching</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_subject" href="#fpdf.fpdf.FPDF.set_subject">set_subject</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_text_color" href="#fpdf.fpdf.FPDF.set_text_color">set_text_color</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_text_shaping" href="#fpdf.fpdf.FPDF.set_text_shaping">set_text_shaping</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_title" href="#fpdf.fpdf.FPDF.set_title">set_title</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_top_margin" href="#fpdf.fpdf.FPDF.set_top_margin">set_top_margin</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_x" href="#fpdf.fpdf.FPDF.set_x">set_x</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_xmp_metadata" href="#fpdf.fpdf.FPDF.set_xmp_metadata">set_xmp_metadata</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_xy" href="#fpdf.fpdf.FPDF.set_xy">set_xy</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.set_y" href="#fpdf.fpdf.FPDF.set_y">set_y</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.sign" href="#fpdf.fpdf.FPDF.sign">sign</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.sign_pkcs12" href="#fpdf.fpdf.FPDF.sign_pkcs12">sign_pkcs12</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.single_resources_object" href="#fpdf.fpdf.FPDF.single_resources_object">single_resources_object</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.skew" href="#fpdf.fpdf.FPDF.skew">skew</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.solid_arc" href="#fpdf.fpdf.FPDF.solid_arc">solid_arc</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.star" href="#fpdf.fpdf.FPDF.star">star</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.start_section" href="#fpdf.fpdf.FPDF.start_section">start_section</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.sub_lift" href="graphics_state.html#fpdf.fpdf.FPDF.sub_lift">sub_lift</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.sub_scale" href="graphics_state.html#fpdf.fpdf.FPDF.sub_scale">sub_scale</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.sup_lift" href="graphics_state.html#fpdf.fpdf.FPDF.sup_lift">sup_lift</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.sup_scale" href="graphics_state.html#fpdf.fpdf.FPDF.sup_scale">sup_scale</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.table" href="#fpdf.fpdf.FPDF.table">table</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.text" href="#fpdf.fpdf.FPDF.text">text</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.text_annotation" href="#fpdf.fpdf.FPDF.text_annotation">text_annotation</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.text_columns" href="#fpdf.fpdf.FPDF.text_columns">text_columns</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.unbreakable" href="#fpdf.fpdf.FPDF.unbreakable">unbreakable</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.use_font_face" href="#fpdf.fpdf.FPDF.use_font_face">use_font_face</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.use_pattern" href="#fpdf.fpdf.FPDF.use_pattern">use_pattern</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.use_text_style" href="#fpdf.fpdf.FPDF.use_text_style">use_text_style</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.will_page_break" href="#fpdf.fpdf.FPDF.will_page_break">will_page_break</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.write" href="#fpdf.fpdf.FPDF.write">write</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.write_html" href="#fpdf.fpdf.FPDF.write_html">write_html</a></code></li>
<li><code><a title="fpdf.fpdf.FPDF.x_by_align" href="#fpdf.fpdf.FPDF.x_by_align">x_by_align</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.fpdf.ImageInfo" href="#fpdf.fpdf.ImageInfo">ImageInfo</a></code></h4>
<ul class="">
<li><code><a title="fpdf.fpdf.ImageInfo.height" href="#fpdf.fpdf.ImageInfo.height">height</a></code></li>
<li><code><a title="fpdf.fpdf.ImageInfo.rendered_height" href="#fpdf.fpdf.ImageInfo.rendered_height">rendered_height</a></code></li>
<li><code><a title="fpdf.fpdf.ImageInfo.rendered_width" href="#fpdf.fpdf.ImageInfo.rendered_width">rendered_width</a></code></li>
<li><code><a title="fpdf.fpdf.ImageInfo.scale_inside_box" href="#fpdf.fpdf.ImageInfo.scale_inside_box">scale_inside_box</a></code></li>
<li><code><a title="fpdf.fpdf.ImageInfo.width" href="#fpdf.fpdf.ImageInfo.width">width</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.fpdf.RasterImageInfo" href="#fpdf.fpdf.RasterImageInfo">RasterImageInfo</a></code></h4>
<ul class="">
<li><code><a title="fpdf.fpdf.RasterImageInfo.height" href="image_datastructures.html#fpdf.fpdf.RasterImageInfo.height">height</a></code></li>
<li><code><a title="fpdf.fpdf.RasterImageInfo.rendered_height" href="image_datastructures.html#fpdf.fpdf.RasterImageInfo.rendered_height">rendered_height</a></code></li>
<li><code><a title="fpdf.fpdf.RasterImageInfo.rendered_width" href="image_datastructures.html#fpdf.fpdf.RasterImageInfo.rendered_width">rendered_width</a></code></li>
<li><code><a title="fpdf.fpdf.RasterImageInfo.scale_inside_box" href="image_datastructures.html#fpdf.fpdf.RasterImageInfo.scale_inside_box">scale_inside_box</a></code></li>
<li><code><a title="fpdf.fpdf.RasterImageInfo.size_in_document_units" href="#fpdf.fpdf.RasterImageInfo.size_in_document_units">size_in_document_units</a></code></li>
<li><code><a title="fpdf.fpdf.RasterImageInfo.width" href="image_datastructures.html#fpdf.fpdf.RasterImageInfo.width">width</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.fpdf.TextMode" href="#fpdf.fpdf.TextMode">TextMode</a></code></h4>
<ul class="two-column">
<li><code><a title="fpdf.fpdf.TextMode.CLIP" href="#fpdf.fpdf.TextMode.CLIP">CLIP</a></code></li>
<li><code><a title="fpdf.fpdf.TextMode.FILL" href="#fpdf.fpdf.TextMode.FILL">FILL</a></code></li>
<li><code><a title="fpdf.fpdf.TextMode.FILL_CLIP" href="#fpdf.fpdf.TextMode.FILL_CLIP">FILL_CLIP</a></code></li>
<li><code><a title="fpdf.fpdf.TextMode.FILL_STROKE" href="#fpdf.fpdf.TextMode.FILL_STROKE">FILL_STROKE</a></code></li>
<li><code><a title="fpdf.fpdf.TextMode.FILL_STROKE_CLIP" href="#fpdf.fpdf.TextMode.FILL_STROKE_CLIP">FILL_STROKE_CLIP</a></code></li>
<li><code><a title="fpdf.fpdf.TextMode.INVISIBLE" href="#fpdf.fpdf.TextMode.INVISIBLE">INVISIBLE</a></code></li>
<li><code><a title="fpdf.fpdf.TextMode.STROKE" href="#fpdf.fpdf.TextMode.STROKE">STROKE</a></code></li>
<li><code><a title="fpdf.fpdf.TextMode.STROKE_CLIP" href="#fpdf.fpdf.TextMode.STROKE_CLIP">STROKE_CLIP</a></code></li>
<li><code><a title="fpdf.fpdf.TextMode.coerce" href="enums.html#fpdf.fpdf.TextMode.coerce">coerce</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.fpdf.TitleStyle" href="#fpdf.fpdf.TitleStyle">TitleStyle</a></code></h4>
<ul class="">
<li><code><a title="fpdf.fpdf.TitleStyle.combine" href="fonts.html#fpdf.fpdf.TitleStyle.combine">combine</a></code></li>
<li><code><a title="fpdf.fpdf.TitleStyle.replace" href="fonts.html#fpdf.fpdf.TitleStyle.replace">replace</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.fpdf.VectorImageInfo" href="#fpdf.fpdf.VectorImageInfo">VectorImageInfo</a></code></h4>
<ul class="">
<li><code><a title="fpdf.fpdf.VectorImageInfo.height" href="image_datastructures.html#fpdf.fpdf.VectorImageInfo.height">height</a></code></li>
<li><code><a title="fpdf.fpdf.VectorImageInfo.rendered_height" href="image_datastructures.html#fpdf.fpdf.VectorImageInfo.rendered_height">rendered_height</a></code></li>
<li><code><a title="fpdf.fpdf.VectorImageInfo.rendered_width" href="image_datastructures.html#fpdf.fpdf.VectorImageInfo.rendered_width">rendered_width</a></code></li>
<li><code><a title="fpdf.fpdf.VectorImageInfo.scale_inside_box" href="image_datastructures.html#fpdf.fpdf.VectorImageInfo.scale_inside_box">scale_inside_box</a></code></li>
<li><code><a title="fpdf.fpdf.VectorImageInfo.width" href="image_datastructures.html#fpdf.fpdf.VectorImageInfo.width">width</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.fpdf.XPos" href="#fpdf.fpdf.XPos">XPos</a></code></h4>
<ul class="two-column">
<li><code><a title="fpdf.fpdf.XPos.CENTER" href="#fpdf.fpdf.XPos.CENTER">CENTER</a></code></li>
<li><code><a title="fpdf.fpdf.XPos.END" href="#fpdf.fpdf.XPos.END">END</a></code></li>
<li><code><a title="fpdf.fpdf.XPos.LEFT" href="#fpdf.fpdf.XPos.LEFT">LEFT</a></code></li>
<li><code><a title="fpdf.fpdf.XPos.LMARGIN" href="#fpdf.fpdf.XPos.LMARGIN">LMARGIN</a></code></li>
<li><code><a title="fpdf.fpdf.XPos.RIGHT" href="#fpdf.fpdf.XPos.RIGHT">RIGHT</a></code></li>
<li><code><a title="fpdf.fpdf.XPos.RMARGIN" href="#fpdf.fpdf.XPos.RMARGIN">RMARGIN</a></code></li>
<li><code><a title="fpdf.fpdf.XPos.START" href="#fpdf.fpdf.XPos.START">START</a></code></li>
<li><code><a title="fpdf.fpdf.XPos.WCONT" href="#fpdf.fpdf.XPos.WCONT">WCONT</a></code></li>
<li><code><a title="fpdf.fpdf.XPos.coerce" href="enums.html#fpdf.fpdf.XPos.coerce">coerce</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.fpdf.YPos" href="#fpdf.fpdf.YPos">YPos</a></code></h4>
<ul class="two-column">
<li><code><a title="fpdf.fpdf.YPos.BMARGIN" href="#fpdf.fpdf.YPos.BMARGIN">BMARGIN</a></code></li>
<li><code><a title="fpdf.fpdf.YPos.LAST" href="#fpdf.fpdf.YPos.LAST">LAST</a></code></li>
<li><code><a title="fpdf.fpdf.YPos.NEXT" href="#fpdf.fpdf.YPos.NEXT">NEXT</a></code></li>
<li><code><a title="fpdf.fpdf.YPos.TMARGIN" href="#fpdf.fpdf.YPos.TMARGIN">TMARGIN</a></code></li>
<li><code><a title="fpdf.fpdf.YPos.TOP" href="#fpdf.fpdf.YPos.TOP">TOP</a></code></li>
<li><code><a title="fpdf.fpdf.YPos.coerce" href="enums.html#fpdf.fpdf.YPos.coerce">coerce</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
